# 文档

## 功能完成情况



## 使用说明

### 一、安装：

##### 前端部分：

进入前端文件夹`frontend`，在命令行运行`npm install`将依赖项安装在本地node_modules文件夹中

![image-20220823153443765](./img/frontend_install.png)

前端由`vue-cli`搭建，此外，需要安装的库有：

![image-20220823154240755](./img/pack.png)

##### 后端部分：

进入后端文件夹`backend`，命令行运行`pip install -r requirements.txt`

新建五个文件夹：`input_file，model，output，textfile，example`

### 二、运行：

##### 后端部分：

在`backend`文件夹中，执行`python app.py`

![image-20220823154518815](./img/backend.png)

##### 前端部分：

在`frontend`文件夹中，执行`npm run serve`，之后点击前端的链接进入页面

![image-20220823154701221](./img/frontend.png)

### 三、页面简介：

#### 1.所有页面的页眉与页脚：

##### 切换模式：

点击右上角的按钮，可以切换夜间模式和白天模式

##### 查看代码：

点击右下角的气泡跳转到`GitHub`这个项目的代码仓库

![image-20220824213833871](./img/2.png)

#### 2.登录页面/注册页面：

##### 注册：

将鼠标移到AI SERVER字样时会浮出登录框，点击注册，输入自定义的用户名和密码，后端的数据库会记住这个用户，点击返回回到登录界面

##### 登录：

输入之前注册的用户名，或者输入提前准备好的用户（用户名为team，密码为123456）

![image-20220824210916780](./img/1.png)

#### 3.模型管理页面：

##### 展示模型：

展示当前的所有模型的基本资料，如名称、类型、更新时间。通过点击删除按钮，删除这个模型

##### 模型筛选：

上方的搜索框可以按照模型名称展示相对应的模型信息

##### 查看模型信息：

通过点击模型的信息条，可以进入相应模型的信息页面

##### 界面跳转：

点击左上角的按钮返回上一个页面，点击”导入模型“按钮，进入模型导入界面

![image-20220824220336432](./img/3.png)

#### 4.模型导入界面：

##### 导入模型：

选择所有数据之后，点击中间的导入按键，跳转到模型的信息界面

##### 返回：

通过点击返回按键，回到模型管理界面

![image-20220824215248710](./img/4.png)

#### 5.模型信息页面：



#### 6.模型部署页面：
##### 详情页面：

通过标签页切换进入。显示这个模型的基本信息，如平均响应时间、最大响应时间等。

![img](./img/deploy_detail.png)

##### 快速返回测试：

输入 Python 预处理代码和 JSON 参数或者文件，点击提交上传。
![img](./img/deploy_quickresponse.png)
返回结果如下。
![img](./img/deploy_response.png)

##### 等待返回：

点击按钮进入等待返回测试页面。上传 Python 预处理文件和代码，进行等待返回测试。
![img](./img/deploy_delayresponse.png)



## 前端技术框架
### 文件组织

### 技术概述(主要是使用的依赖插件,讲述该技术的优势以及在本次作业中的应用)

1.ts 例：使用ts相比于js的优势，ts在这次作业中主要的应用地方
2.vuex
3.axios
4.prismjs
能够高亮代码，优势是支持配置功能，引入简单。在本次作业中用于显示响应代码。
5.gsap
6.element-plus
UI 库，提供了卡片样式、表单组织、表格页面等功能。用于部署页面。
7.router？

### 实现细节详解（每个部分不一定包括，也不限于：1，页面截图+简单布局介绍；2，接口处如何从前端获取信息以及从后端接受信息反馈，将信息进行展示；3，亮点css或者js样式动画；4.可以对照大作业得分点介绍自己页面的完成情况，5............................）
#### 登录页面

#### 模型管理页面+模型导入页面

#### 模型信息页面(概述，测试，部署)

#### web部署页面(概述，快速返回，等待返回，任务详情)
**概述页面**：使用 element-plus 的 ElTable 组件，使用 onMounted 钩子，在组件挂载时请求 /get_deployment_info/<deployment> 接口，将信息封装为类型为 Indicator 的信息。
**快速返回**：采用左右布局的方式，左侧为请求表单，右侧为返回响应，均用 ElCard 组件承载。左侧表单使用 ElForm 组织。文件上传上由于 ElUpload 组建需要上传文件的接口，跟后端接口设计不符合，因此采用原生 input 标签。访问
**等待返回**：使用 ElTable 显示任务以及操作，可以上传文件来完成。
**任务详情**：通过 ElCard 显示结果。通过路由参数获取任务id, 再在 store 里查询详情信息，并请求后端 /getdeploymenttask 获取结果。请求结果使用 CodeViewer 显示。

## 后端技术框架
后端的结构基本如下图所示：
![img](./img/backend_frame.jpg)

### 文件组织



### 技术概述

#### 数据交互

我们采用sqlite数据库。采用数据库可以在节省内存，并且在服务停机后仍然能够保留数据，便于调试，测试服务。sqlite数据库是一个轻量级的数据库，在python中可以调用其对应的管理库sqlite3进行管理。此外，sqlite数据库也是一个关系型数据库，我们的模型数据，部署数据等等因为其经常需要用一种属性来查询另一种属性，因此非常适合使用关系型数据库。

##### 对数据库的操作

我们主要有四种对数据库的操作。
第一种是查找，我们在数据库的使用函数中调用sqlite的命令，例如：

~~~python
c.execute('SELECT modelname, modeltype, time FROM models WHERE user = ?', (user,))
~~~

即在models表单中查找user对应的所有条目的模型名，模型类型和创建时间。查找使用sqlite中的SELECT语句。

~~~python
row = c.fetchone()
answer = c.fetchall()
~~~

选择后使用fetchone或fetchall来获取一条满足条件的条目或是所有满足条件的条目。

第二种是插入，我们在数据库的使用函数中调用sqlite的命令，例如：

~~~python
c.execute('INSERT INTO delayresponsetasks VALUES (?,?,?,?,?)', 
                    (user, taskid, modelname, deployment, 'None'))
~~~

即在delayresponsetasks表单中插入一行数据。插入使用INSERT语句。插入操作之后需要commit我们做的修改。

第三种是修改，我们在数据库的使用函数中调用sqlite的命令，例如：

~~~python
c.execute('''UPDATE deployments SET status = ?
                    WHERE user = ? AND modelname = ? AND deployment = ?''' , 
                    (status, user, modelname, deployment))
~~~

即修改deployments表单中所有满足WHERE的条件的表单项的status。修改使用UPDATE语句。修改操作之后需要commit我们做的修改。

第四种是删除，我们在数据库的使用函数中调用sqlite的命令，例如：

~~~python
c.execute('DELETE FROM models WHERE user = ? AND modelname = ?', 
                    (user, modelname))
~~~

即删除models表单中所有满足后面条件的表单项。删除使用DELETE语句。删除之后需要commit提交我们的修改。

##### 数据库维护的表单

我们的数据库维护了五个表单，分别管理用户、模型、模型变量、部署、等待返回id。

~~~python
c.execute('''CREATE TABLE users 
                        (user TEXT, password TEXT, roll TEXT, 
                        modelid NUMBER, delayresponsetaskid NUMBER, 
                        waittaskid NUMBER);''')
~~~

第一个是用户表单（users）。用户表单记录用户信息，维护了用户的用户名、密码、身份（管理员/普通用户，便于以后的开发）、模型id（用于后续写id系统）、任务id（用于给等待返回的task分配不重复的id，这个表单项从1开始往上加）、部署id（用于后续写id系统）。一般使用用户名作为索引去获取其他信息。

~~~python
c.execute('''CREATE TABLE models 
                        (user TEXT, modelid NUMBER, 
                        modelname TEXT, modeltype TEXT, 
                        time TEXT, modelroute TEXT, 
                        algorithm TEXT, engine TEXT, 
                        description TEXT);''')
~~~

第二个是模型表单（models）。模型表单存储模型信息，维护了模型所属的用户，模型的id（供以后的id系统使用），模型名，模型类型，模型创建时间，模型文件的存储路径，模型算法，模型使用引擎，模型描述。一般使用用户或着使用用户和模型名一起来作为索引查找对应的表单项。

~~~python
c.execute('''CREATE TABLE variables 
                        (user TEXT, id NUMBER, modelname TEXT, 
                        inout TEXT, name TEXT, 
                        type TEXT, value TEXT, dim TEXT, optype TEXT);''')
~~~

第三个是模型变量表（variables）。模型变量表存储模型变量的信息，因为一个模型往往有多个输入变量和输出变量，所以这部分不存在模型表单中。模型变量表单维护了模型所属用户名，模型id（供以后的id系统使用），模型名，输入变量/输出变量（取值为input或output），变量名，变量类型，变量取值，维数，optype。通常使用用户名+模型名作为索引。

~~~python
c.execute('''CREATE TABLE deployments 
                        (user TEXT, modelname TEXT, 
                        deployment TEXT, status TEXT, time TEXT, 
                        times INTEGER, averagecost REAL, 
                        maxcost REAL, mincost REAL, 
                        firstvisit TEXT, lastvisit TEXT);''')
~~~

第四个是部署表单（deployments）。部署表单存储部署信息和部署的性能信息，维护了用户名，模型名，部署名，部署状态（启动/暂停），创建时间，访问次数，平均响应时间，最大响应时间，最小响应时间，第一次访问的日期时间，最后一次访问的日期时间。因为部署名是全局唯一的，所以只要用部署名作为索引即可。

~~~python
c.execute('''CREATE TABLE delayresponsetasks
                        (user TEXT, id TEXT, 
                        modelname TEXT, deployment TEXT, file TEXT);''')
~~~

第五个是等待返回任务表单（delayresponsetasks）。该表单主要存储部署之后的等待返回任务，维护了用户名，任务id，模型名，部署名，存储结果文件名的信息。一般使用部署名+任务id作为索引查询存储结果文件名。

#### 模型运行

#### 模型有效性判断

对pmml文件：

​		1、判断其作为xml文件是否是良构的。具体实现为：调用`xml.etree`库中的`ElementTree`模块，直接使用try..except语句调用parse方法，若调用成功，则xml文件时良构的。

​		2、验证其是否符合对应版本的pmml规则。具体实现为：从pmml官网上下载不同版本（3.1-4.4.1）的pmml对应的`xsd`文件，使用`generateDS` 解析 XSD 文件，生成相应的 Python module并储存在`backend/check_pmml_xsd`文件夹中。接收pmml文件后读取其版本，并调用对应版本的moudle，与验证xml良构性相似，使用parse方法以验证pmml文件的正确性。

对onnx文件:

​		直接调用onnx库的`onnx.checker.check_model()`来验证模型的有效性

#### 模型服务监控
可以通过前端接口查看当前部署的模型服务的性能指标（仅限快速返回），实现方式为：
* 在数据库内为每个模型维护如下变量：`deployment-部署名称`，`times-执行次数`，`averagecost-平均响应时间`，`maxcost-最大响应时间`，`mincost-最小响应时间`，`firstvisit-第一次访问时间点`，`lastvisit-最近一次访问时间点`；
* 每次调用快速返回接口时，使用`database.setdeploymentperformance`函数更新上述变量；
* 当前端发出监控服务性能的申请时，使用`database.getdeploymentperformance`函数返回上述指标。


#### 自定义预处理
##### 接口设计
（待补充）

##### 预处理函数
为了方便使用，我们为用户提供了几种常见输入文件的预处理函数，文件格式包括：`.jpg`，`.txt`，`.mp4`，`jpg/mp4格式的base64编码`，`.csv`，`.zip`。用户可以通过直接修改下方函数（比如根据传入文件的类型取消部分代码的注释），完成简单的预处理工作。该函数存储在主目录下的`sample_for_user.py`中。
```python
import json
import os
import prepare as preprocess
def prepare(input_type, file):
    if isinstance(file, str):
        # 如果您传入的是字符串可以直接使用json.loads
        return json.loads(file)
    else:
        filepath = './input_file/' + file.filename
        file.save(filepath)
        data = None
        
        # todo
        # 如果您传入的是jpg
        # data = preprocess.readimg(input_type[0], filepath, file)
        # 如果您传入的是mp4
        # data = preprocess.readmp4(input_type[0], filepath, file)
        # 如果您传入的是txt
        # data = preprocess.readtxt(input_type, filepath, file)
        # 如果您传入的是csv
        # data = preprocess.readcsv(input_type, filepath, file)
        # 如果您传入的是zip
        # data = preprocess.readzip(input_type, filepath, file)
        
        os.remove(filepath)
        return data
```

### 接口信息

#### 登陆页面接口

##### /login (post)：登录

访问数据库的users表单，在其中查找用户对应的密码是否与输入的密码相符合。

##### /register (post)：注册用户

先判重，如果用户名不重复在users表单中新建一项。

#### 模型管理页面接口

##### /getusermodel (post)：获取某用户下的所有模型

在数据库中的models表单下查询指定用户的所有模型，返回简略信息。

#### 模型导入页面接口

##### /upload(post)：上传

接收前端上传的模型并储存，验证有模型效性，读取模型信息（包括模型算法、输入（字段名、类型、取值[如有]、维数[如有]）和目标变量），并储存在数据库中

#### 模型信息页面接口

##### /getmodelinfo(post)：获取一个模型的详细信息

接收前端发来的模型名，用户名和密码，在models表单中查询相关信息，返回一个详细信息。

#### 模型测试页面接口

##### /testmodel_test(post)：测试模型

接收前端发来的测试数据，返回预测结果。其中前端发来数据之后首先要判断测试数据的类型（是字符串还是文件），之后调用相应的文件处理器进行处理。目前我们支持文件为jpg、txt、csv、mp4。此外，我们本身还支持json传输。

处理后得到统一的几种格式，之后使用模型预测技术进行预测，将结果返回。

#### 模型部署页面接口

#### 服务性能
这一部分需要用到`docker+k8s`模块。
##### docker镜像搭建：
首先本地安装docker。在后端根目录下创建`Dockerfile`，将需要安装的第三方库写成`requirements.txt`文件形式，从而可以使用`DockerFile`快速搭建镜像。文件中未指定`python`版本，且第三方库通过清华镜像站安装，原则上能够适应各种运行环境。
```DockerFile
FROM python
ENV PATH /usr/local/bin:$PATH
ADD . /
WORKDIR /
RUN pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
RUN /usr/local/bin/python -m pip install --upgrade pip
RUN pip install opencv-python-headless
RUN pip install -r requirements.txt
CMD ["python", "app.py"]
```
使用以下命令创建镜像（其中`ai-server`为项目名，可以更换为任意自定义名称）：
```powershell
docker build -f Dockerfile -t ai-server .
```
创建完成后，可以使用`docker images`查看镜像。执行命令`docker run ai-server`，命令行显示以下结果，说明镜像成功运行：
![img](./img/docker_image_run.png)
##### 分配指定CPU核数和内存量

##### 模型伸缩（高并发/负载均衡）