#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Aug 15 11:37:34 2022 by generateDS.py version 2.40.13.
# Python 3.10.1 (tags/v3.10.1:2cd268a, Dec  6 2021, 19:10:37) [MSC v.1929 64 bit (AMD64)]
#
# Command line options:
#   ('-o', 'pmml_40.py')
#
# Command line arguments:
#   pmml-4-0.xsd
#
# Command line:
#   generateDS.py -o "pmml_40.py" pmml-4-0.xsd
#
# Current working directory (os.getcwd()):
#   Scripts
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % float(input_data)).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            input_data = input_data.strip()
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    s1 = s1.replace('\n', '&#10;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ACTIVATION_FUNCTION(str, Enum):
    THRESHOLD='threshold'
    LOGISTIC='logistic'
    TANH='tanh'
    IDENTITY='identity'
    EXPONENTIAL='exponential'
    RECIPROCAL='reciprocal'
    SQUARE='square'
    GAUSS='Gauss'
    SINE='sine'
    COSINE='cosine'
    ELLIOTT='Elliott'
    ARCTAN='arctan'
    RADIAL_BASIS='radialBasis'


class COMPARE_FUNCTION(str, Enum):
    ABS_DIFF='absDiff'
    GAUSS_SIM='gaussSim'
    DELTA='delta'
    EQUAL='equal'
    TABLE='table'


class CUMULATIVE_LINK_FUNCTION(str, Enum):
    LOGIT='logit'
    PROBIT='probit'
    CLOGLOG='cloglog'
    LOGLOG='loglog'
    CAUCHIT='cauchit'


class DATATYPE(str, Enum):
    STRING='string'
    INTEGER='integer'
    FLOAT='float'
    DOUBLE='double'
    BOOLEAN='boolean'
    DATE='date'
    TIME='time'
    DATE_TIME='dateTime'
    DATE_DAYS_SINCE_0='dateDaysSince[0]'
    DATE_DAYS_SINCE_1960='dateDaysSince[1960]'
    DATE_DAYS_SINCE_1970='dateDaysSince[1970]'
    DATE_DAYS_SINCE_1980='dateDaysSince[1980]'
    TIME_SECONDS='timeSeconds'
    DATE_TIME_SECONDS_SINCE_0='dateTimeSecondsSince[0]'
    DATE_TIME_SECONDS_SINCE_1960='dateTimeSecondsSince[1960]'
    DATE_TIME_SECONDS_SINCE_1970='dateTimeSecondsSince[1970]'
    DATE_TIME_SECONDS_SINCE_1980='dateTimeSecondsSince[1980]'


class DELIMITER(str, Enum):
    SAME_TIME_WINDOW='sameTimeWindow'
    ACROSS_TIME_WINDOWS='acrossTimeWindows'


class FIELD_USAGE_TYPE(str, Enum):
    ACTIVE='active'
    PREDICTED='predicted'
    SUPPLEMENTARY='supplementary'
    GROUP='group'
    ORDER='order'
    FREQUENCY_WEIGHT='frequencyWeight'
    ANALYSIS_WEIGHT='analysisWeight'


class GAP(str, Enum):
    TRUE='true'
    FALSE='false'
    UNKNOWN='unknown'


class INTERPOLATION_METHOD(str, Enum):
    NONE='none'
    LINEAR='linear'
    EXPONENTIAL_SPLINE='exponentialSpline'
    CUBIC_SPLINE='cubicSpline'


class INVALID_VALUE_TREATMENT_METHOD(str, Enum):
    RETURN_INVALID='returnInvalid'
    AS_IS='asIs'
    AS_MISSING='asMissing'


class LINK_FUNCTION(str, Enum):
    CLOGLOG='cloglog'
    IDENTITY='identity'
    LOG='log'
    LOGC='logc'
    LOGIT='logit'
    LOGLOG='loglog'
    NEGBIN='negbin'
    ODDSPOWER='oddspower'
    POWER='power'
    PROBIT='probit'


class MINING_FUNCTION(str, Enum):
    ASSOCIATION_RULES='associationRules'
    SEQUENCES='sequences'
    CLASSIFICATION='classification'
    REGRESSION='regression'
    CLUSTERING='clustering'
    TIME_SERIES='timeSeries'


class MISSING_VALUE_STRATEGY(str, Enum):
    LAST_PREDICTION='lastPrediction'
    NULL_PREDICTION='nullPrediction'
    DEFAULT_CHILD='defaultChild'
    WEIGHTED_CONFIDENCE='weightedConfidence'
    AGGREGATE_NODES='aggregateNodes'
    NONE='none'


class MISSING_VALUE_TREATMENT_METHOD(str, Enum):
    AS_IS='asIs'
    AS_MEAN='asMean'
    AS_MODE='asMode'
    AS_MEDIAN='asMedian'
    AS_VALUE='asValue'


class MULTIPLE_MODEL_METHOD(str, Enum):
    MAJORITY_VOTE='majorityVote'
    WEIGHTED_MAJORITY_VOTE='weightedMajorityVote'
    AVERAGE='average'
    WEIGHTED_AVERAGE='weightedAverage'
    MEDIAN='median'
    MAX='max'
    SUM='sum'
    SELECT_FIRST='selectFirst'
    SELECT_ALL='selectAll'


class NN_NORMALIZATION_METHOD(str, Enum):
    NONE='none'
    SIMPLEMAX='simplemax'
    SOFTMAX='softmax'


class NO_TRUE_CHILD_STRATEGY(str, Enum):
    RETURN_NULL_PREDICTION='returnNullPrediction'
    RETURN_LAST_PREDICTION='returnLastPrediction'


class OPTYPE(str, Enum):
    CATEGORICAL='categorical'
    ORDINAL='ordinal'
    CONTINUOUS='continuous'


class OUTLIER_TREATMENT_METHOD(str, Enum):
    AS_IS='asIs'
    AS_MISSING_VALUES='asMissingValues'
    AS_EXTREME_VALUES='asExtremeValues'


class REGRESSIONNORMALIZATIONMETHOD(str, Enum):
    NONE='none'
    SIMPLEMAX='simplemax'
    SOFTMAX='softmax'
    LOGIT='logit'
    PROBIT='probit'
    CLOGLOG='cloglog'
    EXP='exp'
    LOGLOG='loglog'
    CAUCHIT='cauchit'


class RESULT_FEATURE(str, Enum):
    PREDICTED_VALUE='predictedValue'
    PREDICTED_DISPLAY_VALUE='predictedDisplayValue'
    PROBABILITY='probability'
    RESIDUAL='residual'
    STANDARD_ERROR='standardError'
    CLUSTER_ID='clusterId'
    CLUSTER_AFFINITY='clusterAffinity'
    ENTITY_ID='entityId'
    ENTITY_AFFINITY='entityAffinity'
    WARNING='warning'
    RULE_VALUE='ruleValue'


class RULE_FEATURE(str, Enum):
    ANTECEDENT='antecedent'
    CONSEQUENT='consequent'
    RULE='rule'
    RULE_ID='ruleId'
    CONFIDENCE='confidence'
    SUPPORT='support'
    LIFT='lift'


class SVM_CLASSIFICATION_METHOD(str, Enum):
    ONE_AGAINST_ALL='OneAgainstAll'
    ONE_AGAINST_ONE='OneAgainstOne'


class SVM_REPRESENTATION(str, Enum):
    SUPPORT_VECTORS='SupportVectors'
    COEFFICIENTS='Coefficients'


class TIME_ANCHOR(str, Enum):
    DATE_TIME_MILLISECDONDS_SINCE_0='dateTimeMillisecdondsSince[0]'
    DATE_TIME_MILLISECDONDS_SINCE_1960='dateTimeMillisecdondsSince[1960]'
    DATE_TIME_MILLISECDONDS_SINCE_1970='dateTimeMillisecdondsSince[1970]'
    DATE_TIME_MILLISECDONDS_SINCE_1980='dateTimeMillisecdondsSince[1980]'
    DATE_TIME_SECDONDS_SINCE_0='dateTimeSecdondsSince[0]'
    DATE_TIME_SECDONDS_SINCE_1960='dateTimeSecdondsSince[1960]'
    DATE_TIME_SECDONDS_SINCE_1970='dateTimeSecdondsSince[1970]'
    DATE_TIME_SECDONDS_SINCE_1980='dateTimeSecdondsSince[1980]'
    DATE_DAYS_SINCE_0='dateDaysSince[0]'
    DATE_DAYS_SINCE_1960='dateDaysSince[1960]'
    DATE_DAYS_SINCE_1970='dateDaysSince[1970]'
    DATE_DAYS_SINCE_1980='dateDaysSince[1980]'
    DATE_MONTHS_SINCE_0='dateMonthsSince[0]'
    DATE_MONTHS_SINCE_1960='dateMonthsSince[1960]'
    DATE_MONTHS_SINCE_1970='dateMonthsSince[1970]'
    DATE_MONTHS_SINCE_1980='dateMonthsSince[1980]'
    DATE_YEARS_SINCE_0='dateYearsSince[0]'


class TIME_EXCEPTION_TYPE(str, Enum):
    EXCLUDE='exclude'
    INCLUDE='include'


class TIMESERIES_ALGORITHM(str, Enum):
    ARIMA='ARIMA'
    EXPONENTIAL_SMOOTHING='ExponentialSmoothing'
    SEASONAL_TREND_DECOMPOSITION='SeasonalTrendDecomposition'
    SPECTRAL_ANALYSIS='SpectralAnalysis'


class TIMESERIES_USAGE(str, Enum):
    ORIGINAL='original'
    LOGICAL='logical'
    PREDICTION='prediction'


class VALID_TIME_SPEC(str, Enum):
    INCLUDE_ALL='includeAll'
    INCLUDE_FROM_TO='includeFromTo'
    EXCLUDE_FROM_TO='excludeFromTo'
    INCLUDE_SET='includeSet'
    EXCLUDE_SET='excludeSet'


class algorithmType(str, Enum):
    RECOMMENDATION='recommendation'
    EXCLUSIVE_RECOMMENDATION='exclusiveRecommendation'
    RULE_ASSOCIATION='ruleAssociation'


class booleanOperatorType(str, Enum):
    OR='or'
    AND='and'
    XOR='xor'
    SURROGATE='surrogate'


class booleanOperatorType4(str, Enum):
    IS_IN='isIn'
    IS_NOT_IN='isNotIn'


class castIntegerType(str, Enum):
    ROUND='round'
    CEILING='ceiling'
    FLOOR='floor'


class closureType(str, Enum):
    OPEN_CLOSED='openClosed'
    OPEN_OPEN='openOpen'
    CLOSED_OPEN='closedOpen'
    CLOSED_CLOSED='closedClosed'


class criterionType(str, Enum):
    WEIGHTED_SUM='weightedSum'
    WEIGHTED_MAX='weightedMax'
    FIRST_HIT='firstHit'


class dataUsageType(str, Enum):
    TRAINING='training'
    TEST='test'
    VALIDATION='validation'


class distributionType(str, Enum):
    BINOMIAL='binomial'
    GAMMA='gamma'
    IGAUSS='igauss'
    NEGBIN='negbin'
    NORMAL='normal'
    POISSON='poisson'
    TWEEDIE='tweedie'


class documentNormalizationType(str, Enum):
    NONE='none'
    COSINE='cosine'


class functionType(str, Enum):
    COUNT='count'
    SUM='sum'
    AVERAGE='average'
    MIN='min'
    MAX='max'
    MULTISET='multiset'


class globalTermWeightsType(str, Enum):
    INVERSE_DOCUMENT_FREQUENCY='inverseDocumentFrequency'
    NONE='none'
    GFIDF='GFIDF'
    NORMAL='normal'
    PROBABILISTIC_INVERSE='probabilisticInverse'


class isCenterFieldType(str, Enum):
    TRUE='true'
    FALSE='false'


class isCyclicType(str, Enum):
    _0='0'
    _1='1'


class isRecursiveType(str, Enum):
    NO='no'
    YES='yes'


class kindType(str, Enum):
    DIAGONAL='diagonal'
    SYMMETRIC='symmetric'
    ANY='any'


class kindType3(str, Enum):
    DISTANCE='distance'
    SIMILARITY='similarity'


class localTermWeightsType(str, Enum):
    TERM_FREQUENCY='termFrequency'
    BINARY='binary'
    LOGARITHMIC='logarithmic'
    AUGMENTED_NORMALIZED_TERM_FREQUENCY='augmentedNormalizedTermFrequency'


class methodType(str, Enum):
    INDICATOR='indicator'


class modelClassType(str, Enum):
    CENTER_BASED='centerBased'
    DISTRIBUTION_BASED='distributionBased'


class modelTypeType(str, Enum):
    LINEAR_REGRESSION='linearRegression'
    STEPWISE_POLYNOMIAL_REGRESSION='stepwisePolynomialRegression'
    LOGISTIC_REGRESSION='logisticRegression'


class modelTypeType5(str, Enum):
    REGRESSION='regression'
    GENERAL_LINEAR='generalLinear'
    MULTINOMIAL_LOGISTIC='multinomialLogistic'
    ORDINAL_MULTINOMIAL='ordinalMultinomial'
    GENERALIZED_LINEAR='generalizedLinear'
    COX_REGRESSION='CoxRegression'


class operatorType(str, Enum):
    EQUAL='equal'
    NOT_EQUAL='notEqual'
    LESS_THAN='lessThan'
    LESS_OR_EQUAL='lessOrEqual'
    GREATER_THAN='greaterThan'
    GREATER_OR_EQUAL='greaterOrEqual'
    IS_MISSING='isMissing'
    IS_NOT_MISSING='isNotMissing'


class propertyType(str, Enum):
    VALID='valid'
    INVALID='invalid'
    MISSING='missing'


class rankBasisType(str, Enum):
    CONFIDENCE='confidence'
    SUPPORT='support'
    LIFT='lift'


class rankOrderType(str, Enum):
    DESCENDING='descending'
    ASCENDING='ascending'


class similarityTypeType(str, Enum):
    EUCLIDEAN='euclidean'
    COSINE='cosine'


class splitCharacteristicType(str, Enum):
    BINARY_SPLIT='binarySplit'
    MULTI_SPLIT='multiSplit'


class splitCharacteristicType7(str, Enum):
    BINARY_SPLIT='binarySplit'
    MULTI_SPLIT='multiSplit'


class transformationType(str, Enum):
    NONE='none'
    LOGARITHMIC='logarithmic'
    SQUAREROOT='squareroot'


class trendType(str, Enum):
    ADDITIVE='additive'
    DAMPED_ADDITIVE='damped_additive'
    MULTIPLICATIVE='multiplicative'
    DAMPED_MULTIPLICATIVE='damped_multiplicative'
    DOUBLE_EXPONENTIAL='double_exponential'


class typeType(str, Enum):
    INT='int'
    REAL='real'
    STRING='string'


class typeType1(str, Enum):
    MODEL='Model'
    ERROR='Error'
    TOTAL='Total'


class typeType6(str, Enum):
    MODEL='model'
    ROBUST='robust'


class typeType8(str, Enum):
    ADDITIVE='additive'
    MULTIPLICATIVE='multiplicative'


class weightedType(str, Enum):
    _0='0'
    _1='1'


class weightedType2(str, Enum):
    _0='0'
    _1='1'


class PMML(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, version=None, Header=None, MiningBuildTask=None, DataDictionary=None, TransformationDictionary=None, AssociationModel=None, ClusteringModel=None, GeneralRegressionModel=None, MiningModel=None, NaiveBayesModel=None, NeuralNetwork=None, RegressionModel=None, RuleSetModel=None, SequenceModel=None, SupportVectorMachineModel=None, TextModel=None, TimeSeriesModel=None, TreeModel=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.Header = Header
        self.Header_nsprefix_ = None
        self.MiningBuildTask = MiningBuildTask
        self.MiningBuildTask_nsprefix_ = None
        self.DataDictionary = DataDictionary
        self.DataDictionary_nsprefix_ = None
        self.TransformationDictionary = TransformationDictionary
        self.TransformationDictionary_nsprefix_ = None
        if AssociationModel is None:
            self.AssociationModel = []
        else:
            self.AssociationModel = AssociationModel
        self.AssociationModel_nsprefix_ = None
        if ClusteringModel is None:
            self.ClusteringModel = []
        else:
            self.ClusteringModel = ClusteringModel
        self.ClusteringModel_nsprefix_ = None
        if GeneralRegressionModel is None:
            self.GeneralRegressionModel = []
        else:
            self.GeneralRegressionModel = GeneralRegressionModel
        self.GeneralRegressionModel_nsprefix_ = None
        if MiningModel is None:
            self.MiningModel = []
        else:
            self.MiningModel = MiningModel
        self.MiningModel_nsprefix_ = None
        if NaiveBayesModel is None:
            self.NaiveBayesModel = []
        else:
            self.NaiveBayesModel = NaiveBayesModel
        self.NaiveBayesModel_nsprefix_ = None
        if NeuralNetwork is None:
            self.NeuralNetwork = []
        else:
            self.NeuralNetwork = NeuralNetwork
        self.NeuralNetwork_nsprefix_ = None
        if RegressionModel is None:
            self.RegressionModel = []
        else:
            self.RegressionModel = RegressionModel
        self.RegressionModel_nsprefix_ = None
        if RuleSetModel is None:
            self.RuleSetModel = []
        else:
            self.RuleSetModel = RuleSetModel
        self.RuleSetModel_nsprefix_ = None
        if SequenceModel is None:
            self.SequenceModel = []
        else:
            self.SequenceModel = SequenceModel
        self.SequenceModel_nsprefix_ = None
        if SupportVectorMachineModel is None:
            self.SupportVectorMachineModel = []
        else:
            self.SupportVectorMachineModel = SupportVectorMachineModel
        self.SupportVectorMachineModel_nsprefix_ = None
        if TextModel is None:
            self.TextModel = []
        else:
            self.TextModel = TextModel
        self.TextModel_nsprefix_ = None
        if TimeSeriesModel is None:
            self.TimeSeriesModel = []
        else:
            self.TimeSeriesModel = TimeSeriesModel
        self.TimeSeriesModel_nsprefix_ = None
        if TreeModel is None:
            self.TreeModel = []
        else:
            self.TreeModel = TreeModel
        self.TreeModel_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PMML)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PMML.subclass:
            return PMML.subclass(*args_, **kwargs_)
        else:
            return PMML(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Header(self):
        return self.Header
    def set_Header(self, Header):
        self.Header = Header
    def get_MiningBuildTask(self):
        return self.MiningBuildTask
    def set_MiningBuildTask(self, MiningBuildTask):
        self.MiningBuildTask = MiningBuildTask
    def get_DataDictionary(self):
        return self.DataDictionary
    def set_DataDictionary(self, DataDictionary):
        self.DataDictionary = DataDictionary
    def get_TransformationDictionary(self):
        return self.TransformationDictionary
    def set_TransformationDictionary(self, TransformationDictionary):
        self.TransformationDictionary = TransformationDictionary
    def get_AssociationModel(self):
        return self.AssociationModel
    def set_AssociationModel(self, AssociationModel):
        self.AssociationModel = AssociationModel
    def add_AssociationModel(self, value):
        self.AssociationModel.append(value)
    def insert_AssociationModel_at(self, index, value):
        self.AssociationModel.insert(index, value)
    def replace_AssociationModel_at(self, index, value):
        self.AssociationModel[index] = value
    def get_ClusteringModel(self):
        return self.ClusteringModel
    def set_ClusteringModel(self, ClusteringModel):
        self.ClusteringModel = ClusteringModel
    def add_ClusteringModel(self, value):
        self.ClusteringModel.append(value)
    def insert_ClusteringModel_at(self, index, value):
        self.ClusteringModel.insert(index, value)
    def replace_ClusteringModel_at(self, index, value):
        self.ClusteringModel[index] = value
    def get_GeneralRegressionModel(self):
        return self.GeneralRegressionModel
    def set_GeneralRegressionModel(self, GeneralRegressionModel):
        self.GeneralRegressionModel = GeneralRegressionModel
    def add_GeneralRegressionModel(self, value):
        self.GeneralRegressionModel.append(value)
    def insert_GeneralRegressionModel_at(self, index, value):
        self.GeneralRegressionModel.insert(index, value)
    def replace_GeneralRegressionModel_at(self, index, value):
        self.GeneralRegressionModel[index] = value
    def get_MiningModel(self):
        return self.MiningModel
    def set_MiningModel(self, MiningModel):
        self.MiningModel = MiningModel
    def add_MiningModel(self, value):
        self.MiningModel.append(value)
    def insert_MiningModel_at(self, index, value):
        self.MiningModel.insert(index, value)
    def replace_MiningModel_at(self, index, value):
        self.MiningModel[index] = value
    def get_NaiveBayesModel(self):
        return self.NaiveBayesModel
    def set_NaiveBayesModel(self, NaiveBayesModel):
        self.NaiveBayesModel = NaiveBayesModel
    def add_NaiveBayesModel(self, value):
        self.NaiveBayesModel.append(value)
    def insert_NaiveBayesModel_at(self, index, value):
        self.NaiveBayesModel.insert(index, value)
    def replace_NaiveBayesModel_at(self, index, value):
        self.NaiveBayesModel[index] = value
    def get_NeuralNetwork(self):
        return self.NeuralNetwork
    def set_NeuralNetwork(self, NeuralNetwork):
        self.NeuralNetwork = NeuralNetwork
    def add_NeuralNetwork(self, value):
        self.NeuralNetwork.append(value)
    def insert_NeuralNetwork_at(self, index, value):
        self.NeuralNetwork.insert(index, value)
    def replace_NeuralNetwork_at(self, index, value):
        self.NeuralNetwork[index] = value
    def get_RegressionModel(self):
        return self.RegressionModel
    def set_RegressionModel(self, RegressionModel):
        self.RegressionModel = RegressionModel
    def add_RegressionModel(self, value):
        self.RegressionModel.append(value)
    def insert_RegressionModel_at(self, index, value):
        self.RegressionModel.insert(index, value)
    def replace_RegressionModel_at(self, index, value):
        self.RegressionModel[index] = value
    def get_RuleSetModel(self):
        return self.RuleSetModel
    def set_RuleSetModel(self, RuleSetModel):
        self.RuleSetModel = RuleSetModel
    def add_RuleSetModel(self, value):
        self.RuleSetModel.append(value)
    def insert_RuleSetModel_at(self, index, value):
        self.RuleSetModel.insert(index, value)
    def replace_RuleSetModel_at(self, index, value):
        self.RuleSetModel[index] = value
    def get_SequenceModel(self):
        return self.SequenceModel
    def set_SequenceModel(self, SequenceModel):
        self.SequenceModel = SequenceModel
    def add_SequenceModel(self, value):
        self.SequenceModel.append(value)
    def insert_SequenceModel_at(self, index, value):
        self.SequenceModel.insert(index, value)
    def replace_SequenceModel_at(self, index, value):
        self.SequenceModel[index] = value
    def get_SupportVectorMachineModel(self):
        return self.SupportVectorMachineModel
    def set_SupportVectorMachineModel(self, SupportVectorMachineModel):
        self.SupportVectorMachineModel = SupportVectorMachineModel
    def add_SupportVectorMachineModel(self, value):
        self.SupportVectorMachineModel.append(value)
    def insert_SupportVectorMachineModel_at(self, index, value):
        self.SupportVectorMachineModel.insert(index, value)
    def replace_SupportVectorMachineModel_at(self, index, value):
        self.SupportVectorMachineModel[index] = value
    def get_TextModel(self):
        return self.TextModel
    def set_TextModel(self, TextModel):
        self.TextModel = TextModel
    def add_TextModel(self, value):
        self.TextModel.append(value)
    def insert_TextModel_at(self, index, value):
        self.TextModel.insert(index, value)
    def replace_TextModel_at(self, index, value):
        self.TextModel[index] = value
    def get_TimeSeriesModel(self):
        return self.TimeSeriesModel
    def set_TimeSeriesModel(self, TimeSeriesModel):
        self.TimeSeriesModel = TimeSeriesModel
    def add_TimeSeriesModel(self, value):
        self.TimeSeriesModel.append(value)
    def insert_TimeSeriesModel_at(self, index, value):
        self.TimeSeriesModel.insert(index, value)
    def replace_TimeSeriesModel_at(self, index, value):
        self.TimeSeriesModel[index] = value
    def get_TreeModel(self):
        return self.TreeModel
    def set_TreeModel(self, TreeModel):
        self.TreeModel = TreeModel
    def add_TreeModel(self, value):
        self.TreeModel.append(value)
    def insert_TreeModel_at(self, index, value):
        self.TreeModel.insert(index, value)
    def replace_TreeModel_at(self, index, value):
        self.TreeModel[index] = value
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def _hasContent(self):
        if (
            self.Header is not None or
            self.MiningBuildTask is not None or
            self.DataDictionary is not None or
            self.TransformationDictionary is not None or
            self.AssociationModel or
            self.ClusteringModel or
            self.GeneralRegressionModel or
            self.MiningModel or
            self.NaiveBayesModel or
            self.NeuralNetwork or
            self.RegressionModel or
            self.RuleSetModel or
            self.SequenceModel or
            self.SupportVectorMachineModel or
            self.TextModel or
            self.TimeSeriesModel or
            self.TreeModel or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PMML', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PMML')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PMML':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PMML')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PMML', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PMML'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PMML', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Header is not None:
            namespaceprefix_ = self.Header_nsprefix_ + ':' if (UseCapturedNS_ and self.Header_nsprefix_) else ''
            self.Header.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Header', pretty_print=pretty_print)
        if self.MiningBuildTask is not None:
            namespaceprefix_ = self.MiningBuildTask_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningBuildTask_nsprefix_) else ''
            self.MiningBuildTask.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningBuildTask', pretty_print=pretty_print)
        if self.DataDictionary is not None:
            namespaceprefix_ = self.DataDictionary_nsprefix_ + ':' if (UseCapturedNS_ and self.DataDictionary_nsprefix_) else ''
            self.DataDictionary.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DataDictionary', pretty_print=pretty_print)
        if self.TransformationDictionary is not None:
            namespaceprefix_ = self.TransformationDictionary_nsprefix_ + ':' if (UseCapturedNS_ and self.TransformationDictionary_nsprefix_) else ''
            self.TransformationDictionary.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TransformationDictionary', pretty_print=pretty_print)
        for AssociationModel_ in self.AssociationModel:
            namespaceprefix_ = self.AssociationModel_nsprefix_ + ':' if (UseCapturedNS_ and self.AssociationModel_nsprefix_) else ''
            AssociationModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssociationModel', pretty_print=pretty_print)
        for ClusteringModel_ in self.ClusteringModel:
            namespaceprefix_ = self.ClusteringModel_nsprefix_ + ':' if (UseCapturedNS_ and self.ClusteringModel_nsprefix_) else ''
            ClusteringModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClusteringModel', pretty_print=pretty_print)
        for GeneralRegressionModel_ in self.GeneralRegressionModel:
            namespaceprefix_ = self.GeneralRegressionModel_nsprefix_ + ':' if (UseCapturedNS_ and self.GeneralRegressionModel_nsprefix_) else ''
            GeneralRegressionModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GeneralRegressionModel', pretty_print=pretty_print)
        for MiningModel_ in self.MiningModel:
            namespaceprefix_ = self.MiningModel_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningModel_nsprefix_) else ''
            MiningModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningModel', pretty_print=pretty_print)
        for NaiveBayesModel_ in self.NaiveBayesModel:
            namespaceprefix_ = self.NaiveBayesModel_nsprefix_ + ':' if (UseCapturedNS_ and self.NaiveBayesModel_nsprefix_) else ''
            NaiveBayesModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NaiveBayesModel', pretty_print=pretty_print)
        for NeuralNetwork_ in self.NeuralNetwork:
            namespaceprefix_ = self.NeuralNetwork_nsprefix_ + ':' if (UseCapturedNS_ and self.NeuralNetwork_nsprefix_) else ''
            NeuralNetwork_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NeuralNetwork', pretty_print=pretty_print)
        for RegressionModel_ in self.RegressionModel:
            namespaceprefix_ = self.RegressionModel_nsprefix_ + ':' if (UseCapturedNS_ and self.RegressionModel_nsprefix_) else ''
            RegressionModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RegressionModel', pretty_print=pretty_print)
        for RuleSetModel_ in self.RuleSetModel:
            namespaceprefix_ = self.RuleSetModel_nsprefix_ + ':' if (UseCapturedNS_ and self.RuleSetModel_nsprefix_) else ''
            RuleSetModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RuleSetModel', pretty_print=pretty_print)
        for SequenceModel_ in self.SequenceModel:
            namespaceprefix_ = self.SequenceModel_nsprefix_ + ':' if (UseCapturedNS_ and self.SequenceModel_nsprefix_) else ''
            SequenceModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SequenceModel', pretty_print=pretty_print)
        for SupportVectorMachineModel_ in self.SupportVectorMachineModel:
            namespaceprefix_ = self.SupportVectorMachineModel_nsprefix_ + ':' if (UseCapturedNS_ and self.SupportVectorMachineModel_nsprefix_) else ''
            SupportVectorMachineModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SupportVectorMachineModel', pretty_print=pretty_print)
        for TextModel_ in self.TextModel:
            namespaceprefix_ = self.TextModel_nsprefix_ + ':' if (UseCapturedNS_ and self.TextModel_nsprefix_) else ''
            TextModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextModel', pretty_print=pretty_print)
        for TimeSeriesModel_ in self.TimeSeriesModel:
            namespaceprefix_ = self.TimeSeriesModel_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeSeriesModel_nsprefix_) else ''
            TimeSeriesModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeSeriesModel', pretty_print=pretty_print)
        for TreeModel_ in self.TreeModel:
            namespaceprefix_ = self.TreeModel_nsprefix_ + ':' if (UseCapturedNS_ and self.TreeModel_nsprefix_) else ''
            TreeModel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TreeModel', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Header':
            obj_ = Header.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Header = obj_
            obj_.original_tagname_ = 'Header'
        elif nodeName_ == 'MiningBuildTask':
            obj_ = MiningBuildTask.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningBuildTask = obj_
            obj_.original_tagname_ = 'MiningBuildTask'
        elif nodeName_ == 'DataDictionary':
            obj_ = DataDictionary.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataDictionary = obj_
            obj_.original_tagname_ = 'DataDictionary'
        elif nodeName_ == 'TransformationDictionary':
            obj_ = TransformationDictionary.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TransformationDictionary = obj_
            obj_.original_tagname_ = 'TransformationDictionary'
        elif nodeName_ == 'AssociationModel':
            obj_ = AssociationModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssociationModel.append(obj_)
            obj_.original_tagname_ = 'AssociationModel'
        elif nodeName_ == 'ClusteringModel':
            obj_ = ClusteringModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClusteringModel.append(obj_)
            obj_.original_tagname_ = 'ClusteringModel'
        elif nodeName_ == 'GeneralRegressionModel':
            obj_ = GeneralRegressionModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GeneralRegressionModel.append(obj_)
            obj_.original_tagname_ = 'GeneralRegressionModel'
        elif nodeName_ == 'MiningModel':
            obj_ = MiningModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningModel.append(obj_)
            obj_.original_tagname_ = 'MiningModel'
        elif nodeName_ == 'NaiveBayesModel':
            obj_ = NaiveBayesModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NaiveBayesModel.append(obj_)
            obj_.original_tagname_ = 'NaiveBayesModel'
        elif nodeName_ == 'NeuralNetwork':
            obj_ = NeuralNetwork.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NeuralNetwork.append(obj_)
            obj_.original_tagname_ = 'NeuralNetwork'
        elif nodeName_ == 'RegressionModel':
            obj_ = RegressionModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RegressionModel.append(obj_)
            obj_.original_tagname_ = 'RegressionModel'
        elif nodeName_ == 'RuleSetModel':
            obj_ = RuleSetModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RuleSetModel.append(obj_)
            obj_.original_tagname_ = 'RuleSetModel'
        elif nodeName_ == 'SequenceModel':
            obj_ = SequenceModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SequenceModel.append(obj_)
            obj_.original_tagname_ = 'SequenceModel'
        elif nodeName_ == 'SupportVectorMachineModel':
            obj_ = SupportVectorMachineModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SupportVectorMachineModel.append(obj_)
            obj_.original_tagname_ = 'SupportVectorMachineModel'
        elif nodeName_ == 'TextModel':
            obj_ = TextModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TextModel.append(obj_)
            obj_.original_tagname_ = 'TextModel'
        elif nodeName_ == 'TimeSeriesModel':
            obj_ = TimeSeriesModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeSeriesModel.append(obj_)
            obj_.original_tagname_ = 'TimeSeriesModel'
        elif nodeName_ == 'TreeModel':
            obj_ = TreeModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TreeModel.append(obj_)
            obj_.original_tagname_ = 'TreeModel'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class PMML


class MiningBuildTask(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MiningBuildTask)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MiningBuildTask.subclass:
            return MiningBuildTask.subclass(*args_, **kwargs_)
        else:
            return MiningBuildTask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='MiningBuildTask', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MiningBuildTask')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MiningBuildTask':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MiningBuildTask')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MiningBuildTask', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MiningBuildTask'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='MiningBuildTask', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class MiningBuildTask


class Extension(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, extender=None, name=None, value=None, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.extender = _cast(None, extender)
        self.extender_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Extension)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Extension.subclass:
            return Extension.subclass(*args_, **kwargs_)
        else:
            return Extension(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_extender(self):
        return self.extender
    def set_extender(self, extender):
        self.extender = extender
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def _hasContent(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Extension', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Extension')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Extension':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Extension')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Extension', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Extension'):
        if self.extender is not None and 'extender' not in already_processed:
            already_processed.add('extender')
            outfile.write(' extender=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.extender), input_name='extender')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Extension', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('extender', node)
        if value is not None and 'extender' not in already_processed:
            already_processed.add('extender')
            self.extender = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'Extension')
        self.anytypeobjs_.append(content_)
# end class Extension


class ArrayType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, n=None, type_=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.n = _cast(int, n)
        self.n_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArrayType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArrayType.subclass:
            return ArrayType.subclass(*args_, **kwargs_)
        else:
            return ArrayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_n(self):
        return self.n
    def set_n(self, n):
        self.n = n
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_typeType(self, value):
        # Validate type typeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['int', 'real', 'string']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArrayType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ArrayType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ArrayType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ArrayType')
        outfile.write('>')
        self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ArrayType'):
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            outfile.write(' n="%s"' % self.gds_format_integer(self.n, input_name='n'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ArrayType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('n', node)
        if value is not None and 'n' not in already_processed:
            already_processed.add('n')
            self.n = self.gds_parse_integer(value, node, 'n')
            self.validate_INT_NUMBER(self.n)    # validate type INT-NUMBER
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType(self.type_)    # validate type typeType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class ArrayType


class INT_SparseArray(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, n=None, defaultValue='0', Indices=None, INT_Entries=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.n = _cast(int, n)
        self.n_nsprefix_ = None
        self.defaultValue = _cast(int, defaultValue)
        self.defaultValue_nsprefix_ = None
        self.Indices = Indices
        self.validate_Indices(self.Indices)
        self.Indices_nsprefix_ = None
        self.INT_Entries = INT_Entries
        self.validate_INT_Entries(self.INT_Entries)
        self.INT_Entries_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INT_SparseArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INT_SparseArray.subclass:
            return INT_SparseArray.subclass(*args_, **kwargs_)
        else:
            return INT_SparseArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Indices(self):
        return self.Indices
    def set_Indices(self, Indices):
        self.Indices = Indices
    def get_INT_Entries(self):
        return self.INT_Entries
    def set_INT_Entries(self, INT_Entries):
        self.INT_Entries = INT_Entries
    def get_n(self):
        return self.n
    def set_n(self, n):
        self.n = n
    def get_defaultValue(self):
        return self.defaultValue
    def set_defaultValue(self, defaultValue):
        self.defaultValue = defaultValue
    def validate_Indices(self, value):
        result = True
        # Validate type Indices, a restriction on xs:int.
        pass
        return result
    def validate_INT_Entries(self, value):
        result = True
        # Validate type INT-Entries, a restriction on xs:int.
        pass
        return result
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Indices is not None or
            self.INT_Entries is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='INT-SparseArray', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INT-SparseArray')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'INT-SparseArray':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INT-SparseArray')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='INT-SparseArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='INT-SparseArray'):
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            outfile.write(' n="%s"' % self.gds_format_integer(self.n, input_name='n'))
        if self.defaultValue != 0 and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            outfile.write(' defaultValue="%s"' % self.gds_format_integer(self.defaultValue, input_name='defaultValue'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='INT-SparseArray', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Indices is not None:
            namespaceprefix_ = self.Indices_nsprefix_ + ':' if (UseCapturedNS_ and self.Indices_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndices>%s</%sIndices>%s' % (namespaceprefix_, self.gds_format_integer_list(self.Indices, input_name='Indices'), namespaceprefix_ , eol_))
        if self.INT_Entries is not None:
            namespaceprefix_ = self.INT_Entries_nsprefix_ + ':' if (UseCapturedNS_ and self.INT_Entries_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINT-Entries>%s</%sINT-Entries>%s' % (namespaceprefix_, self.gds_format_integer_list(self.INT_Entries, input_name='INT-Entries'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('n', node)
        if value is not None and 'n' not in already_processed:
            already_processed.add('n')
            self.n = self.gds_parse_integer(value, node, 'n')
            self.validate_INT_NUMBER(self.n)    # validate type INT-NUMBER
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            self.defaultValue = self.gds_parse_integer(value, node, 'defaultValue')
            self.validate_INT_NUMBER(self.defaultValue)    # validate type INT-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Indices':
            value_ = child_.text
            value_ = self.gds_validate_integer_list(value_, node, 'Indices')
            self.Indices = value_
            self.Indices_nsprefix_ = child_.prefix
            # validate type Indices
            self.validate_Indices(self.Indices)
        elif nodeName_ == 'INT-Entries':
            value_ = child_.text
            value_ = self.gds_validate_integer_list(value_, node, 'INT_Entries')
            self.INT_Entries = value_
            self.INT_Entries_nsprefix_ = child_.prefix
            # validate type INT-Entries
            self.validate_INT_Entries(self.INT_Entries)
# end class INT_SparseArray


class REAL_SparseArray(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, n=None, defaultValue='0', Indices=None, REAL_Entries=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.n = _cast(int, n)
        self.n_nsprefix_ = None
        self.defaultValue = _cast(float, defaultValue)
        self.defaultValue_nsprefix_ = None
        self.Indices = Indices
        self.validate_Indices(self.Indices)
        self.Indices_nsprefix_ = None
        self.REAL_Entries = REAL_Entries
        self.validate_REAL_Entries(self.REAL_Entries)
        self.REAL_Entries_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REAL_SparseArray)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REAL_SparseArray.subclass:
            return REAL_SparseArray.subclass(*args_, **kwargs_)
        else:
            return REAL_SparseArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Indices(self):
        return self.Indices
    def set_Indices(self, Indices):
        self.Indices = Indices
    def get_REAL_Entries(self):
        return self.REAL_Entries
    def set_REAL_Entries(self, REAL_Entries):
        self.REAL_Entries = REAL_Entries
    def get_n(self):
        return self.n
    def set_n(self, n):
        self.n = n
    def get_defaultValue(self):
        return self.defaultValue
    def set_defaultValue(self, defaultValue):
        self.defaultValue = defaultValue
    def validate_Indices(self, value):
        result = True
        # Validate type Indices, a restriction on xs:int.
        pass
        return result
    def validate_REAL_Entries(self, value):
        result = True
        # Validate type REAL-Entries, a restriction on xs:double.
        pass
        return result
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Indices is not None or
            self.REAL_Entries is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='REAL-SparseArray', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('REAL-SparseArray')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'REAL-SparseArray':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='REAL-SparseArray')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='REAL-SparseArray', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='REAL-SparseArray'):
        if self.n is not None and 'n' not in already_processed:
            already_processed.add('n')
            outfile.write(' n="%s"' % self.gds_format_integer(self.n, input_name='n'))
        if self.defaultValue != 0 and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            outfile.write(' defaultValue="%s"' % self.gds_format_double(self.defaultValue, input_name='defaultValue'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='REAL-SparseArray', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Indices is not None:
            namespaceprefix_ = self.Indices_nsprefix_ + ':' if (UseCapturedNS_ and self.Indices_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIndices>%s</%sIndices>%s' % (namespaceprefix_, self.gds_format_integer_list(self.Indices, input_name='Indices'), namespaceprefix_ , eol_))
        if self.REAL_Entries is not None:
            namespaceprefix_ = self.REAL_Entries_nsprefix_ + ':' if (UseCapturedNS_ and self.REAL_Entries_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAL-Entries>%s</%sREAL-Entries>%s' % (namespaceprefix_ , self.gds_format_double_list(self.REAL_Entries, input_name='REAL-Entries'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('n', node)
        if value is not None and 'n' not in already_processed:
            already_processed.add('n')
            self.n = self.gds_parse_integer(value, node, 'n')
            self.validate_INT_NUMBER(self.n)    # validate type INT-NUMBER
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            value = self.gds_parse_double(value, node, 'defaultValue')
            self.defaultValue = value
            self.validate_REAL_NUMBER(self.defaultValue)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Indices':
            value_ = child_.text
            value_ = self.gds_validate_integer_list(value_, node, 'Indices')
            self.Indices = value_
            self.Indices_nsprefix_ = child_.prefix
            # validate type Indices
            self.validate_Indices(self.Indices)
        elif nodeName_ == 'REAL-Entries':
            value_ = child_.text
            value_ = self.gds_validate_double_list(value_, node, 'REAL_Entries')
            self.REAL_Entries = value_
            self.REAL_Entries_nsprefix_ = child_.prefix
            # validate type REAL-Entries
            self.validate_REAL_Entries(self.REAL_Entries)
# end class REAL_SparseArray


class Indices(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Indices)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Indices.subclass:
            return Indices.subclass(*args_, **kwargs_)
        else:
            return Indices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def validate_Indices(self, value):
        result = True
        # Validate type Indices, a restriction on xs:int.
        pass
        return result
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Indices', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Indices')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Indices':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Indices')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Indices', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Indices'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Indices', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Indices


class INT_Entries(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, INT_Entries)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if INT_Entries.subclass:
            return INT_Entries.subclass(*args_, **kwargs_)
        else:
            return INT_Entries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def validate_INT_Entries(self, value):
        result = True
        # Validate type INT-Entries, a restriction on xs:int.
        pass
        return result
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='INT-Entries', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('INT-Entries')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'INT-Entries':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='INT-Entries')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='INT-Entries', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='INT-Entries'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='INT-Entries', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class INT_Entries


class REAL_Entries(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, REAL_Entries)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if REAL_Entries.subclass:
            return REAL_Entries.subclass(*args_, **kwargs_)
        else:
            return REAL_Entries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def validate_REAL_Entries(self, value):
        result = True
        # Validate type REAL-Entries, a restriction on xs:double.
        pass
        return result
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='REAL-Entries', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('REAL-Entries')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'REAL-Entries':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='REAL-Entries')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='REAL-Entries', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='REAL-Entries'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='REAL-Entries', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class REAL_Entries


class Matrix(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, kind='any', nbRows=None, nbCols=None, diagDefault=None, offDiagDefault=None, Array=None, MatCell=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.kind = _cast(None, kind)
        self.kind_nsprefix_ = None
        self.nbRows = _cast(int, nbRows)
        self.nbRows_nsprefix_ = None
        self.nbCols = _cast(int, nbCols)
        self.nbCols_nsprefix_ = None
        self.diagDefault = _cast(float, diagDefault)
        self.diagDefault_nsprefix_ = None
        self.offDiagDefault = _cast(float, offDiagDefault)
        self.offDiagDefault_nsprefix_ = None
        if Array is None:
            self.Array = []
        else:
            self.Array = Array
        self.Array_nsprefix_ = None
        if MatCell is None:
            self.MatCell = []
        else:
            self.MatCell = MatCell
        self.MatCell_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Matrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Matrix.subclass:
            return Matrix.subclass(*args_, **kwargs_)
        else:
            return Matrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def add_Array(self, value):
        self.Array.append(value)
    def insert_Array_at(self, index, value):
        self.Array.insert(index, value)
    def replace_Array_at(self, index, value):
        self.Array[index] = value
    def get_MatCell(self):
        return self.MatCell
    def set_MatCell(self, MatCell):
        self.MatCell = MatCell
    def add_MatCell(self, value):
        self.MatCell.append(value)
    def insert_MatCell_at(self, index, value):
        self.MatCell.insert(index, value)
    def replace_MatCell_at(self, index, value):
        self.MatCell[index] = value
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def get_nbRows(self):
        return self.nbRows
    def set_nbRows(self, nbRows):
        self.nbRows = nbRows
    def get_nbCols(self):
        return self.nbCols
    def set_nbCols(self, nbCols):
        self.nbCols = nbCols
    def get_diagDefault(self):
        return self.diagDefault
    def set_diagDefault(self, diagDefault):
        self.diagDefault = diagDefault
    def get_offDiagDefault(self):
        return self.offDiagDefault
    def set_offDiagDefault(self, offDiagDefault):
        self.offDiagDefault = offDiagDefault
    def validate_kindType(self, value):
        # Validate type kindType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['diagonal', 'symmetric', 'any']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on kindType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Array or
            self.MatCell
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Matrix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Matrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Matrix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Matrix')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Matrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Matrix'):
        if self.kind != "any" and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kind), input_name='kind')), ))
        if self.nbRows is not None and 'nbRows' not in already_processed:
            already_processed.add('nbRows')
            outfile.write(' nbRows="%s"' % self.gds_format_integer(self.nbRows, input_name='nbRows'))
        if self.nbCols is not None and 'nbCols' not in already_processed:
            already_processed.add('nbCols')
            outfile.write(' nbCols="%s"' % self.gds_format_integer(self.nbCols, input_name='nbCols'))
        if self.diagDefault is not None and 'diagDefault' not in already_processed:
            already_processed.add('diagDefault')
            outfile.write(' diagDefault="%s"' % self.gds_format_double(self.diagDefault, input_name='diagDefault'))
        if self.offDiagDefault is not None and 'offDiagDefault' not in already_processed:
            already_processed.add('offDiagDefault')
            outfile.write(' offDiagDefault="%s"' % self.gds_format_double(self.offDiagDefault, input_name='offDiagDefault'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Matrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Array_ in self.Array:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            Array_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
        for MatCell_ in self.MatCell:
            namespaceprefix_ = self.MatCell_nsprefix_ + ':' if (UseCapturedNS_ and self.MatCell_nsprefix_) else ''
            MatCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MatCell', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
            self.validate_kindType(self.kind)    # validate type kindType
        value = find_attr_value_('nbRows', node)
        if value is not None and 'nbRows' not in already_processed:
            already_processed.add('nbRows')
            self.nbRows = self.gds_parse_integer(value, node, 'nbRows')
            self.validate_INT_NUMBER(self.nbRows)    # validate type INT-NUMBER
        value = find_attr_value_('nbCols', node)
        if value is not None and 'nbCols' not in already_processed:
            already_processed.add('nbCols')
            self.nbCols = self.gds_parse_integer(value, node, 'nbCols')
            self.validate_INT_NUMBER(self.nbCols)    # validate type INT-NUMBER
        value = find_attr_value_('diagDefault', node)
        if value is not None and 'diagDefault' not in already_processed:
            already_processed.add('diagDefault')
            value = self.gds_parse_double(value, node, 'diagDefault')
            self.diagDefault = value
            self.validate_REAL_NUMBER(self.diagDefault)    # validate type REAL-NUMBER
        value = find_attr_value_('offDiagDefault', node)
        if value is not None and 'offDiagDefault' not in already_processed:
            already_processed.add('offDiagDefault')
            value = self.gds_parse_double(value, node, 'offDiagDefault')
            self.offDiagDefault = value
            self.validate_REAL_NUMBER(self.offDiagDefault)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array.append(obj_)
            obj_.original_tagname_ = 'Array'
        elif nodeName_ == 'MatCell':
            obj_ = MatCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MatCell.append(obj_)
            obj_.original_tagname_ = 'MatCell'
# end class Matrix


class MatCell(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, row=None, col=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.row = _cast(int, row)
        self.row_nsprefix_ = None
        self.col = _cast(int, col)
        self.col_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MatCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MatCell.subclass:
            return MatCell.subclass(*args_, **kwargs_)
        else:
            return MatCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_row(self):
        return self.row
    def set_row(self, row):
        self.row = row
    def get_col(self):
        return self.col
    def set_col(self, col):
        self.col = col
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MatCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MatCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MatCell':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MatCell')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MatCell', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MatCell'):
        if self.row is not None and 'row' not in already_processed:
            already_processed.add('row')
            outfile.write(' row="%s"' % self.gds_format_integer(self.row, input_name='row'))
        if self.col is not None and 'col' not in already_processed:
            already_processed.add('col')
            outfile.write(' col="%s"' % self.gds_format_integer(self.col, input_name='col'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MatCell', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('row', node)
        if value is not None and 'row' not in already_processed:
            already_processed.add('row')
            self.row = self.gds_parse_integer(value, node, 'row')
            self.validate_INT_NUMBER(self.row)    # validate type INT-NUMBER
        value = find_attr_value_('col', node)
        if value is not None and 'col' not in already_processed:
            already_processed.add('col')
            self.col = self.gds_parse_integer(value, node, 'col')
            self.validate_INT_NUMBER(self.col)    # validate type INT-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class MatCell


class Header(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, copyright=None, description=None, Extension=None, Application=None, Annotation=None, Timestamp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.copyright = _cast(None, copyright)
        self.copyright_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Application = Application
        self.Application_nsprefix_ = None
        if Annotation is None:
            self.Annotation = []
        else:
            self.Annotation = Annotation
        self.Annotation_nsprefix_ = None
        self.Timestamp = Timestamp
        self.Timestamp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Header)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Header.subclass:
            return Header.subclass(*args_, **kwargs_)
        else:
            return Header(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Application(self):
        return self.Application
    def set_Application(self, Application):
        self.Application = Application
    def get_Annotation(self):
        return self.Annotation
    def set_Annotation(self, Annotation):
        self.Annotation = Annotation
    def add_Annotation(self, value):
        self.Annotation.append(value)
    def insert_Annotation_at(self, index, value):
        self.Annotation.insert(index, value)
    def replace_Annotation_at(self, index, value):
        self.Annotation[index] = value
    def get_Timestamp(self):
        return self.Timestamp
    def set_Timestamp(self, Timestamp):
        self.Timestamp = Timestamp
    def get_copyright(self):
        return self.copyright
    def set_copyright(self, copyright):
        self.copyright = copyright
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def _hasContent(self):
        if (
            self.Extension or
            self.Application is not None or
            self.Annotation or
            self.Timestamp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Header', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Header')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Header':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Header')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Header', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Header'):
        if self.copyright is not None and 'copyright' not in already_processed:
            already_processed.add('copyright')
            outfile.write(' copyright=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.copyright), input_name='copyright')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Header', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Application is not None:
            namespaceprefix_ = self.Application_nsprefix_ + ':' if (UseCapturedNS_ and self.Application_nsprefix_) else ''
            self.Application.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Application', pretty_print=pretty_print)
        for Annotation_ in self.Annotation:
            namespaceprefix_ = self.Annotation_nsprefix_ + ':' if (UseCapturedNS_ and self.Annotation_nsprefix_) else ''
            Annotation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Annotation', pretty_print=pretty_print)
        if self.Timestamp is not None:
            namespaceprefix_ = self.Timestamp_nsprefix_ + ':' if (UseCapturedNS_ and self.Timestamp_nsprefix_) else ''
            self.Timestamp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Timestamp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('copyright', node)
        if value is not None and 'copyright' not in already_processed:
            already_processed.add('copyright')
            self.copyright = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Application':
            obj_ = Application.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Application = obj_
            obj_.original_tagname_ = 'Application'
        elif nodeName_ == 'Annotation':
            obj_ = Annotation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Annotation.append(obj_)
            obj_.original_tagname_ = 'Annotation'
        elif nodeName_ == 'Timestamp':
            obj_ = Timestamp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Timestamp = obj_
            obj_.original_tagname_ = 'Timestamp'
# end class Header


class Application(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, version=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Application)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Application.subclass:
            return Application.subclass(*args_, **kwargs_)
        else:
            return Application(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Application', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Application')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Application':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Application')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Application', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Application'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Application', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Application


class Annotation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Annotation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Annotation.subclass:
            return Annotation.subclass(*args_, **kwargs_)
        else:
            return Annotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            self.Extension or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Annotation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Annotation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Annotation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Annotation')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Annotation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Annotation'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Annotation', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'Extension', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_Extension'):
              self.add_Extension(obj_.value)
            elif hasattr(self, 'set_Extension'):
              self.set_Extension(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class Annotation


class Timestamp(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Timestamp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Timestamp.subclass:
            return Timestamp.subclass(*args_, **kwargs_)
        else:
            return Timestamp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            self.Extension or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Timestamp', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Timestamp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Timestamp':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Timestamp')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Timestamp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Timestamp'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Timestamp', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'Extension', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_Extension'):
              self.add_Extension(obj_.value)
            elif hasattr(self, 'set_Extension'):
              self.set_Extension(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class Timestamp


class DataDictionary(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, numberOfFields=None, Extension=None, DataField=None, Taxonomy=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numberOfFields = _cast(int, numberOfFields)
        self.numberOfFields_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if DataField is None:
            self.DataField = []
        else:
            self.DataField = DataField
        self.DataField_nsprefix_ = None
        if Taxonomy is None:
            self.Taxonomy = []
        else:
            self.Taxonomy = Taxonomy
        self.Taxonomy_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataDictionary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataDictionary.subclass:
            return DataDictionary.subclass(*args_, **kwargs_)
        else:
            return DataDictionary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_DataField(self):
        return self.DataField
    def set_DataField(self, DataField):
        self.DataField = DataField
    def add_DataField(self, value):
        self.DataField.append(value)
    def insert_DataField_at(self, index, value):
        self.DataField.insert(index, value)
    def replace_DataField_at(self, index, value):
        self.DataField[index] = value
    def get_Taxonomy(self):
        return self.Taxonomy
    def set_Taxonomy(self, Taxonomy):
        self.Taxonomy = Taxonomy
    def add_Taxonomy(self, value):
        self.Taxonomy.append(value)
    def insert_Taxonomy_at(self, index, value):
        self.Taxonomy.insert(index, value)
    def replace_Taxonomy_at(self, index, value):
        self.Taxonomy[index] = value
    def get_numberOfFields(self):
        return self.numberOfFields
    def set_numberOfFields(self, numberOfFields):
        self.numberOfFields = numberOfFields
    def _hasContent(self):
        if (
            self.Extension or
            self.DataField or
            self.Taxonomy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DataDictionary', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataDictionary')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataDictionary':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataDictionary')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataDictionary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataDictionary'):
        if self.numberOfFields is not None and 'numberOfFields' not in already_processed:
            already_processed.add('numberOfFields')
            outfile.write(' numberOfFields="%s"' % self.gds_format_integer(self.numberOfFields, input_name='numberOfFields'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DataDictionary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for DataField_ in self.DataField:
            namespaceprefix_ = self.DataField_nsprefix_ + ':' if (UseCapturedNS_ and self.DataField_nsprefix_) else ''
            DataField_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DataField', pretty_print=pretty_print)
        for Taxonomy_ in self.Taxonomy:
            namespaceprefix_ = self.Taxonomy_nsprefix_ + ':' if (UseCapturedNS_ and self.Taxonomy_nsprefix_) else ''
            Taxonomy_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Taxonomy', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfFields', node)
        if value is not None and 'numberOfFields' not in already_processed:
            already_processed.add('numberOfFields')
            self.numberOfFields = self.gds_parse_integer(value, node, 'numberOfFields')
            if self.numberOfFields < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DataField':
            obj_ = DataField.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DataField.append(obj_)
            obj_.original_tagname_ = 'DataField'
        elif nodeName_ == 'Taxonomy':
            obj_ = Taxonomy.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Taxonomy.append(obj_)
            obj_.original_tagname_ = 'Taxonomy'
# end class DataDictionary


class DataField(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, optype=None, dataType=None, taxonomy=None, isCyclic='0', Extension=None, Interval=None, Value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.optype = _cast(None, optype)
        self.optype_nsprefix_ = None
        self.dataType = _cast(None, dataType)
        self.dataType_nsprefix_ = None
        self.taxonomy = _cast(None, taxonomy)
        self.taxonomy_nsprefix_ = None
        self.isCyclic = _cast(None, isCyclic)
        self.isCyclic_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
        self.Interval_nsprefix_ = None
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.Value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataField.subclass:
            return DataField.subclass(*args_, **kwargs_)
        else:
            return DataField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Interval(self):
        return self.Interval
    def set_Interval(self, Interval):
        self.Interval = Interval
    def add_Interval(self, value):
        self.Interval.append(value)
    def insert_Interval_at(self, index, value):
        self.Interval.insert(index, value)
    def replace_Interval_at(self, index, value):
        self.Interval[index] = value
    def get_Value(self):
        return self.Value
    def set_Value(self, Value):
        self.Value = Value
    def add_Value(self, value):
        self.Value.append(value)
    def insert_Value_at(self, index, value):
        self.Value.insert(index, value)
    def replace_Value_at(self, index, value):
        self.Value[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_optype(self):
        return self.optype
    def set_optype(self, optype):
        self.optype = optype
    def get_dataType(self):
        return self.dataType
    def set_dataType(self, dataType):
        self.dataType = dataType
    def get_taxonomy(self):
        return self.taxonomy
    def set_taxonomy(self, taxonomy):
        self.taxonomy = taxonomy
    def get_isCyclic(self):
        return self.isCyclic
    def set_isCyclic(self, isCyclic):
        self.isCyclic = isCyclic
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['categorical', 'ordinal', 'continuous']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OPTYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DATATYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_isCyclicType(self, value):
        # Validate type isCyclicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0', '1']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on isCyclicType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.Interval or
            self.Value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DataField', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataField':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataField')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataField'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.optype), input_name='optype')), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataType), input_name='dataType')), ))
        if self.taxonomy is not None and 'taxonomy' not in already_processed:
            already_processed.add('taxonomy')
            outfile.write(' taxonomy=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.taxonomy), input_name='taxonomy')), ))
        if self.isCyclic != "0" and 'isCyclic' not in already_processed:
            already_processed.add('isCyclic')
            outfile.write(' isCyclic=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.isCyclic), input_name='isCyclic')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DataField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Interval_ in self.Interval:
            namespaceprefix_ = self.Interval_nsprefix_ + ':' if (UseCapturedNS_ and self.Interval_nsprefix_) else ''
            Interval_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Interval', pretty_print=pretty_print)
        for Value_ in self.Value:
            namespaceprefix_ = self.Value_nsprefix_ + ':' if (UseCapturedNS_ and self.Value_nsprefix_) else ''
            Value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Value', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
        value = find_attr_value_('taxonomy', node)
        if value is not None and 'taxonomy' not in already_processed:
            already_processed.add('taxonomy')
            self.taxonomy = value
        value = find_attr_value_('isCyclic', node)
        if value is not None and 'isCyclic' not in already_processed:
            already_processed.add('isCyclic')
            self.isCyclic = value
            self.validate_isCyclicType(self.isCyclic)    # validate type isCyclicType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Interval':
            obj_ = Interval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Interval.append(obj_)
            obj_.original_tagname_ = 'Interval'
        elif nodeName_ == 'Value':
            obj_ = Value.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
# end class DataField


class Value(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value=None, displayValue=None, property='valid', Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.displayValue = _cast(None, displayValue)
        self.displayValue_nsprefix_ = None
        self.property = _cast(None, property)
        self.property_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Value)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Value.subclass:
            return Value.subclass(*args_, **kwargs_)
        else:
            return Value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_displayValue(self):
        return self.displayValue
    def set_displayValue(self, displayValue):
        self.displayValue = displayValue
    def get_property(self):
        return self.property
    def set_property(self, property):
        self.property = property
    def validate_propertyType(self, value):
        # Validate type propertyType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['valid', 'invalid', 'missing']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on propertyType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Value', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Value')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Value':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Value')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Value', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Value'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.displayValue is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            outfile.write(' displayValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayValue), input_name='displayValue')), ))
        if self.property != "valid" and 'property' not in already_processed:
            already_processed.add('property')
            outfile.write(' property=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.property), input_name='property')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Value', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('displayValue', node)
        if value is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            self.displayValue = value
        value = find_attr_value_('property', node)
        if value is not None and 'property' not in already_processed:
            already_processed.add('property')
            self.property = value
            self.validate_propertyType(self.property)    # validate type propertyType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Value


class Interval(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, closure=None, leftMargin=None, rightMargin=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.closure = _cast(None, closure)
        self.closure_nsprefix_ = None
        self.leftMargin = _cast(float, leftMargin)
        self.leftMargin_nsprefix_ = None
        self.rightMargin = _cast(float, rightMargin)
        self.rightMargin_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Interval)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Interval.subclass:
            return Interval.subclass(*args_, **kwargs_)
        else:
            return Interval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_closure(self):
        return self.closure
    def set_closure(self, closure):
        self.closure = closure
    def get_leftMargin(self):
        return self.leftMargin
    def set_leftMargin(self, leftMargin):
        self.leftMargin = leftMargin
    def get_rightMargin(self):
        return self.rightMargin
    def set_rightMargin(self, rightMargin):
        self.rightMargin = rightMargin
    def validate_closureType(self, value):
        # Validate type closureType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['openClosed', 'openOpen', 'closedOpen', 'closedClosed']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on closureType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Interval', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Interval')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Interval':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Interval')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Interval', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Interval'):
        if self.closure is not None and 'closure' not in already_processed:
            already_processed.add('closure')
            outfile.write(' closure=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.closure), input_name='closure')), ))
        if self.leftMargin is not None and 'leftMargin' not in already_processed:
            already_processed.add('leftMargin')
            outfile.write(' leftMargin="%s"' % self.gds_format_double(self.leftMargin, input_name='leftMargin'))
        if self.rightMargin is not None and 'rightMargin' not in already_processed:
            already_processed.add('rightMargin')
            outfile.write(' rightMargin="%s"' % self.gds_format_double(self.rightMargin, input_name='rightMargin'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Interval', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('closure', node)
        if value is not None and 'closure' not in already_processed:
            already_processed.add('closure')
            self.closure = value
            self.validate_closureType(self.closure)    # validate type closureType
        value = find_attr_value_('leftMargin', node)
        if value is not None and 'leftMargin' not in already_processed:
            already_processed.add('leftMargin')
            value = self.gds_parse_double(value, node, 'leftMargin')
            self.leftMargin = value
            self.validate_NUMBER(self.leftMargin)    # validate type NUMBER
        value = find_attr_value_('rightMargin', node)
        if value is not None and 'rightMargin' not in already_processed:
            already_processed.add('rightMargin')
            value = self.gds_parse_double(value, node, 'rightMargin')
            self.rightMargin = value
            self.validate_NUMBER(self.rightMargin)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Interval


class DefineFunction(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, optype=None, dataType=None, Extension=None, ParameterField=None, Constant=None, FieldRef=None, NormContinuous=None, NormDiscrete=None, Discretize=None, MapValues=None, Apply=None, Aggregate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.optype = _cast(None, optype)
        self.optype_nsprefix_ = None
        self.dataType = _cast(None, dataType)
        self.dataType_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if ParameterField is None:
            self.ParameterField = []
        else:
            self.ParameterField = ParameterField
        self.ParameterField_nsprefix_ = None
        self.Constant = Constant
        self.Constant_nsprefix_ = None
        self.FieldRef = FieldRef
        self.FieldRef_nsprefix_ = None
        self.NormContinuous = NormContinuous
        self.NormContinuous_nsprefix_ = None
        self.NormDiscrete = NormDiscrete
        self.NormDiscrete_nsprefix_ = None
        self.Discretize = Discretize
        self.Discretize_nsprefix_ = None
        self.MapValues = MapValues
        self.MapValues_nsprefix_ = None
        self.Apply = Apply
        self.Apply_nsprefix_ = None
        self.Aggregate = Aggregate
        self.Aggregate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DefineFunction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DefineFunction.subclass:
            return DefineFunction.subclass(*args_, **kwargs_)
        else:
            return DefineFunction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_ParameterField(self):
        return self.ParameterField
    def set_ParameterField(self, ParameterField):
        self.ParameterField = ParameterField
    def add_ParameterField(self, value):
        self.ParameterField.append(value)
    def insert_ParameterField_at(self, index, value):
        self.ParameterField.insert(index, value)
    def replace_ParameterField_at(self, index, value):
        self.ParameterField[index] = value
    def get_Constant(self):
        return self.Constant
    def set_Constant(self, Constant):
        self.Constant = Constant
    def get_FieldRef(self):
        return self.FieldRef
    def set_FieldRef(self, FieldRef):
        self.FieldRef = FieldRef
    def get_NormContinuous(self):
        return self.NormContinuous
    def set_NormContinuous(self, NormContinuous):
        self.NormContinuous = NormContinuous
    def get_NormDiscrete(self):
        return self.NormDiscrete
    def set_NormDiscrete(self, NormDiscrete):
        self.NormDiscrete = NormDiscrete
    def get_Discretize(self):
        return self.Discretize
    def set_Discretize(self, Discretize):
        self.Discretize = Discretize
    def get_MapValues(self):
        return self.MapValues
    def set_MapValues(self, MapValues):
        self.MapValues = MapValues
    def get_Apply(self):
        return self.Apply
    def set_Apply(self, Apply):
        self.Apply = Apply
    def get_Aggregate(self):
        return self.Aggregate
    def set_Aggregate(self, Aggregate):
        self.Aggregate = Aggregate
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_optype(self):
        return self.optype
    def set_optype(self, optype):
        self.optype = optype
    def get_dataType(self):
        return self.dataType
    def set_dataType(self, dataType):
        self.dataType = dataType
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['categorical', 'ordinal', 'continuous']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OPTYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DATATYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.ParameterField or
            self.Constant is not None or
            self.FieldRef is not None or
            self.NormContinuous is not None or
            self.NormDiscrete is not None or
            self.Discretize is not None or
            self.MapValues is not None or
            self.Apply is not None or
            self.Aggregate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DefineFunction', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DefineFunction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DefineFunction':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DefineFunction')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DefineFunction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DefineFunction'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.optype), input_name='optype')), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataType), input_name='dataType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DefineFunction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for ParameterField_ in self.ParameterField:
            namespaceprefix_ = self.ParameterField_nsprefix_ + ':' if (UseCapturedNS_ and self.ParameterField_nsprefix_) else ''
            ParameterField_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParameterField', pretty_print=pretty_print)
        if self.Constant is not None:
            namespaceprefix_ = self.Constant_nsprefix_ + ':' if (UseCapturedNS_ and self.Constant_nsprefix_) else ''
            self.Constant.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Constant', pretty_print=pretty_print)
        if self.FieldRef is not None:
            namespaceprefix_ = self.FieldRef_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldRef_nsprefix_) else ''
            self.FieldRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldRef', pretty_print=pretty_print)
        if self.NormContinuous is not None:
            namespaceprefix_ = self.NormContinuous_nsprefix_ + ':' if (UseCapturedNS_ and self.NormContinuous_nsprefix_) else ''
            self.NormContinuous.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NormContinuous', pretty_print=pretty_print)
        if self.NormDiscrete is not None:
            namespaceprefix_ = self.NormDiscrete_nsprefix_ + ':' if (UseCapturedNS_ and self.NormDiscrete_nsprefix_) else ''
            self.NormDiscrete.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NormDiscrete', pretty_print=pretty_print)
        if self.Discretize is not None:
            namespaceprefix_ = self.Discretize_nsprefix_ + ':' if (UseCapturedNS_ and self.Discretize_nsprefix_) else ''
            self.Discretize.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Discretize', pretty_print=pretty_print)
        if self.MapValues is not None:
            namespaceprefix_ = self.MapValues_nsprefix_ + ':' if (UseCapturedNS_ and self.MapValues_nsprefix_) else ''
            self.MapValues.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MapValues', pretty_print=pretty_print)
        if self.Apply is not None:
            namespaceprefix_ = self.Apply_nsprefix_ + ':' if (UseCapturedNS_ and self.Apply_nsprefix_) else ''
            self.Apply.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Apply', pretty_print=pretty_print)
        if self.Aggregate is not None:
            namespaceprefix_ = self.Aggregate_nsprefix_ + ':' if (UseCapturedNS_ and self.Aggregate_nsprefix_) else ''
            self.Aggregate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Aggregate', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ParameterField':
            obj_ = ParameterField.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterField.append(obj_)
            obj_.original_tagname_ = 'ParameterField'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Constant = obj_
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldRef = obj_
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'NormContinuous':
            obj_ = NormContinuous.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NormContinuous = obj_
            obj_.original_tagname_ = 'NormContinuous'
        elif nodeName_ == 'NormDiscrete':
            obj_ = NormDiscrete.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NormDiscrete = obj_
            obj_.original_tagname_ = 'NormDiscrete'
        elif nodeName_ == 'Discretize':
            obj_ = Discretize.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Discretize = obj_
            obj_.original_tagname_ = 'Discretize'
        elif nodeName_ == 'MapValues':
            obj_ = MapValues.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MapValues = obj_
            obj_.original_tagname_ = 'MapValues'
        elif nodeName_ == 'Apply':
            obj_ = Apply.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Apply = obj_
            obj_.original_tagname_ = 'Apply'
        elif nodeName_ == 'Aggregate':
            obj_ = Aggregate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Aggregate = obj_
            obj_.original_tagname_ = 'Aggregate'
# end class DefineFunction


class ParameterField(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, optype=None, dataType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.optype = _cast(None, optype)
        self.optype_nsprefix_ = None
        self.dataType = _cast(None, dataType)
        self.dataType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterField.subclass:
            return ParameterField.subclass(*args_, **kwargs_)
        else:
            return ParameterField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_optype(self):
        return self.optype
    def set_optype(self, optype):
        self.optype = optype
    def get_dataType(self):
        return self.dataType
    def set_dataType(self, dataType):
        self.dataType = dataType
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['categorical', 'ordinal', 'continuous']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OPTYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DATATYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParameterField', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterField':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterField')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterField', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParameterField'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.optype), input_name='optype')), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataType), input_name='dataType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ParameterField', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ParameterField


class Apply(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, function=None, Extension=None, Constant=None, FieldRef=None, NormContinuous=None, NormDiscrete=None, Discretize=None, MapValues=None, Apply_member=None, Aggregate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.function = _cast(None, function)
        self.function_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Constant is None:
            self.Constant = []
        else:
            self.Constant = Constant
        self.Constant_nsprefix_ = None
        if FieldRef is None:
            self.FieldRef = []
        else:
            self.FieldRef = FieldRef
        self.FieldRef_nsprefix_ = None
        if NormContinuous is None:
            self.NormContinuous = []
        else:
            self.NormContinuous = NormContinuous
        self.NormContinuous_nsprefix_ = None
        if NormDiscrete is None:
            self.NormDiscrete = []
        else:
            self.NormDiscrete = NormDiscrete
        self.NormDiscrete_nsprefix_ = None
        if Discretize is None:
            self.Discretize = []
        else:
            self.Discretize = Discretize
        self.Discretize_nsprefix_ = None
        if MapValues is None:
            self.MapValues = []
        else:
            self.MapValues = MapValues
        self.MapValues_nsprefix_ = None
        if Apply_member is None:
            self.Apply = []
        else:
            self.Apply = Apply_member
        self.Apply_nsprefix_ = None
        if Aggregate is None:
            self.Aggregate = []
        else:
            self.Aggregate = Aggregate
        self.Aggregate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Apply)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Apply.subclass:
            return Apply.subclass(*args_, **kwargs_)
        else:
            return Apply(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Constant(self):
        return self.Constant
    def set_Constant(self, Constant):
        self.Constant = Constant
    def add_Constant(self, value):
        self.Constant.append(value)
    def insert_Constant_at(self, index, value):
        self.Constant.insert(index, value)
    def replace_Constant_at(self, index, value):
        self.Constant[index] = value
    def get_FieldRef(self):
        return self.FieldRef
    def set_FieldRef(self, FieldRef):
        self.FieldRef = FieldRef
    def add_FieldRef(self, value):
        self.FieldRef.append(value)
    def insert_FieldRef_at(self, index, value):
        self.FieldRef.insert(index, value)
    def replace_FieldRef_at(self, index, value):
        self.FieldRef[index] = value
    def get_NormContinuous(self):
        return self.NormContinuous
    def set_NormContinuous(self, NormContinuous):
        self.NormContinuous = NormContinuous
    def add_NormContinuous(self, value):
        self.NormContinuous.append(value)
    def insert_NormContinuous_at(self, index, value):
        self.NormContinuous.insert(index, value)
    def replace_NormContinuous_at(self, index, value):
        self.NormContinuous[index] = value
    def get_NormDiscrete(self):
        return self.NormDiscrete
    def set_NormDiscrete(self, NormDiscrete):
        self.NormDiscrete = NormDiscrete
    def add_NormDiscrete(self, value):
        self.NormDiscrete.append(value)
    def insert_NormDiscrete_at(self, index, value):
        self.NormDiscrete.insert(index, value)
    def replace_NormDiscrete_at(self, index, value):
        self.NormDiscrete[index] = value
    def get_Discretize(self):
        return self.Discretize
    def set_Discretize(self, Discretize):
        self.Discretize = Discretize
    def add_Discretize(self, value):
        self.Discretize.append(value)
    def insert_Discretize_at(self, index, value):
        self.Discretize.insert(index, value)
    def replace_Discretize_at(self, index, value):
        self.Discretize[index] = value
    def get_MapValues(self):
        return self.MapValues
    def set_MapValues(self, MapValues):
        self.MapValues = MapValues
    def add_MapValues(self, value):
        self.MapValues.append(value)
    def insert_MapValues_at(self, index, value):
        self.MapValues.insert(index, value)
    def replace_MapValues_at(self, index, value):
        self.MapValues[index] = value
    def get_Apply(self):
        return self.Apply
    def set_Apply(self, Apply):
        self.Apply = Apply
    def add_Apply(self, value):
        self.Apply.append(value)
    def insert_Apply_at(self, index, value):
        self.Apply.insert(index, value)
    def replace_Apply_at(self, index, value):
        self.Apply[index] = value
    def get_Aggregate(self):
        return self.Aggregate
    def set_Aggregate(self, Aggregate):
        self.Aggregate = Aggregate
    def add_Aggregate(self, value):
        self.Aggregate.append(value)
    def insert_Aggregate_at(self, index, value):
        self.Aggregate.insert(index, value)
    def replace_Aggregate_at(self, index, value):
        self.Aggregate[index] = value
    def get_function(self):
        return self.function
    def set_function(self, function):
        self.function = function
    def _hasContent(self):
        if (
            self.Extension or
            self.Constant or
            self.FieldRef or
            self.NormContinuous or
            self.NormDiscrete or
            self.Discretize or
            self.MapValues or
            self.Apply or
            self.Aggregate
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Apply', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Apply')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Apply':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Apply')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Apply', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Apply'):
        if self.function is not None and 'function' not in already_processed:
            already_processed.add('function')
            outfile.write(' function=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.function), input_name='function')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Apply', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Constant_ in self.Constant:
            namespaceprefix_ = self.Constant_nsprefix_ + ':' if (UseCapturedNS_ and self.Constant_nsprefix_) else ''
            Constant_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Constant', pretty_print=pretty_print)
        for FieldRef_ in self.FieldRef:
            namespaceprefix_ = self.FieldRef_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldRef_nsprefix_) else ''
            FieldRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldRef', pretty_print=pretty_print)
        for NormContinuous_ in self.NormContinuous:
            namespaceprefix_ = self.NormContinuous_nsprefix_ + ':' if (UseCapturedNS_ and self.NormContinuous_nsprefix_) else ''
            NormContinuous_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NormContinuous', pretty_print=pretty_print)
        for NormDiscrete_ in self.NormDiscrete:
            namespaceprefix_ = self.NormDiscrete_nsprefix_ + ':' if (UseCapturedNS_ and self.NormDiscrete_nsprefix_) else ''
            NormDiscrete_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NormDiscrete', pretty_print=pretty_print)
        for Discretize_ in self.Discretize:
            namespaceprefix_ = self.Discretize_nsprefix_ + ':' if (UseCapturedNS_ and self.Discretize_nsprefix_) else ''
            Discretize_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Discretize', pretty_print=pretty_print)
        for MapValues_ in self.MapValues:
            namespaceprefix_ = self.MapValues_nsprefix_ + ':' if (UseCapturedNS_ and self.MapValues_nsprefix_) else ''
            MapValues_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MapValues', pretty_print=pretty_print)
        for Apply_ in self.Apply:
            namespaceprefix_ = self.Apply_nsprefix_ + ':' if (UseCapturedNS_ and self.Apply_nsprefix_) else ''
            Apply_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Apply', pretty_print=pretty_print)
        for Aggregate_ in self.Aggregate:
            namespaceprefix_ = self.Aggregate_nsprefix_ + ':' if (UseCapturedNS_ and self.Aggregate_nsprefix_) else ''
            Aggregate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Aggregate', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('function', node)
        if value is not None and 'function' not in already_processed:
            already_processed.add('function')
            self.function = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Constant.append(obj_)
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldRef.append(obj_)
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'NormContinuous':
            obj_ = NormContinuous.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NormContinuous.append(obj_)
            obj_.original_tagname_ = 'NormContinuous'
        elif nodeName_ == 'NormDiscrete':
            obj_ = NormDiscrete.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NormDiscrete.append(obj_)
            obj_.original_tagname_ = 'NormDiscrete'
        elif nodeName_ == 'Discretize':
            obj_ = Discretize.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Discretize.append(obj_)
            obj_.original_tagname_ = 'Discretize'
        elif nodeName_ == 'MapValues':
            obj_ = MapValues.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MapValues.append(obj_)
            obj_.original_tagname_ = 'MapValues'
        elif nodeName_ == 'Apply':
            obj_ = Apply.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Apply.append(obj_)
            obj_.original_tagname_ = 'Apply'
        elif nodeName_ == 'Aggregate':
            obj_ = Aggregate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Aggregate.append(obj_)
            obj_.original_tagname_ = 'Aggregate'
# end class Apply


class Taxonomy(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, Extension=None, ChildParent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if ChildParent is None:
            self.ChildParent = []
        else:
            self.ChildParent = ChildParent
        self.ChildParent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Taxonomy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Taxonomy.subclass:
            return Taxonomy.subclass(*args_, **kwargs_)
        else:
            return Taxonomy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_ChildParent(self):
        return self.ChildParent
    def set_ChildParent(self, ChildParent):
        self.ChildParent = ChildParent
    def add_ChildParent(self, value):
        self.ChildParent.append(value)
    def insert_ChildParent_at(self, index, value):
        self.ChildParent.insert(index, value)
    def replace_ChildParent_at(self, index, value):
        self.ChildParent[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def _hasContent(self):
        if (
            self.Extension or
            self.ChildParent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Taxonomy', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Taxonomy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Taxonomy':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Taxonomy')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Taxonomy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Taxonomy'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Taxonomy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for ChildParent_ in self.ChildParent:
            namespaceprefix_ = self.ChildParent_nsprefix_ + ':' if (UseCapturedNS_ and self.ChildParent_nsprefix_) else ''
            ChildParent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ChildParent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ChildParent':
            obj_ = ChildParent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ChildParent.append(obj_)
            obj_.original_tagname_ = 'ChildParent'
# end class Taxonomy


class ChildParent(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, childField=None, parentField=None, parentLevelField=None, isRecursive='no', Extension=None, TableLocator=None, InlineTable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.childField = _cast(None, childField)
        self.childField_nsprefix_ = None
        self.parentField = _cast(None, parentField)
        self.parentField_nsprefix_ = None
        self.parentLevelField = _cast(None, parentLevelField)
        self.parentLevelField_nsprefix_ = None
        self.isRecursive = _cast(None, isRecursive)
        self.isRecursive_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.TableLocator = TableLocator
        self.TableLocator_nsprefix_ = None
        self.InlineTable = InlineTable
        self.InlineTable_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChildParent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChildParent.subclass:
            return ChildParent.subclass(*args_, **kwargs_)
        else:
            return ChildParent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_TableLocator(self):
        return self.TableLocator
    def set_TableLocator(self, TableLocator):
        self.TableLocator = TableLocator
    def get_InlineTable(self):
        return self.InlineTable
    def set_InlineTable(self, InlineTable):
        self.InlineTable = InlineTable
    def get_childField(self):
        return self.childField
    def set_childField(self, childField):
        self.childField = childField
    def get_parentField(self):
        return self.parentField
    def set_parentField(self, parentField):
        self.parentField = parentField
    def get_parentLevelField(self):
        return self.parentLevelField
    def set_parentLevelField(self, parentLevelField):
        self.parentLevelField = parentLevelField
    def get_isRecursive(self):
        return self.isRecursive
    def set_isRecursive(self, isRecursive):
        self.isRecursive = isRecursive
    def validate_isRecursiveType(self, value):
        # Validate type isRecursiveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['no', 'yes']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on isRecursiveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.TableLocator is not None or
            self.InlineTable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ChildParent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChildParent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChildParent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChildParent')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChildParent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChildParent'):
        if self.childField is not None and 'childField' not in already_processed:
            already_processed.add('childField')
            outfile.write(' childField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.childField), input_name='childField')), ))
        if self.parentField is not None and 'parentField' not in already_processed:
            already_processed.add('parentField')
            outfile.write(' parentField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parentField), input_name='parentField')), ))
        if self.parentLevelField is not None and 'parentLevelField' not in already_processed:
            already_processed.add('parentLevelField')
            outfile.write(' parentLevelField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parentLevelField), input_name='parentLevelField')), ))
        if self.isRecursive != "no" and 'isRecursive' not in already_processed:
            already_processed.add('isRecursive')
            outfile.write(' isRecursive=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.isRecursive), input_name='isRecursive')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ChildParent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.TableLocator is not None:
            namespaceprefix_ = self.TableLocator_nsprefix_ + ':' if (UseCapturedNS_ and self.TableLocator_nsprefix_) else ''
            self.TableLocator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TableLocator', pretty_print=pretty_print)
        if self.InlineTable is not None:
            namespaceprefix_ = self.InlineTable_nsprefix_ + ':' if (UseCapturedNS_ and self.InlineTable_nsprefix_) else ''
            self.InlineTable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InlineTable', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('childField', node)
        if value is not None and 'childField' not in already_processed:
            already_processed.add('childField')
            self.childField = value
        value = find_attr_value_('parentField', node)
        if value is not None and 'parentField' not in already_processed:
            already_processed.add('parentField')
            self.parentField = value
        value = find_attr_value_('parentLevelField', node)
        if value is not None and 'parentLevelField' not in already_processed:
            already_processed.add('parentLevelField')
            self.parentLevelField = value
        value = find_attr_value_('isRecursive', node)
        if value is not None and 'isRecursive' not in already_processed:
            already_processed.add('isRecursive')
            self.isRecursive = value
            self.validate_isRecursiveType(self.isRecursive)    # validate type isRecursiveType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TableLocator':
            obj_ = TableLocator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TableLocator = obj_
            obj_.original_tagname_ = 'TableLocator'
        elif nodeName_ == 'InlineTable':
            obj_ = InlineTable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InlineTable = obj_
            obj_.original_tagname_ = 'InlineTable'
# end class ChildParent


class TableLocator(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TableLocator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TableLocator.subclass:
            return TableLocator.subclass(*args_, **kwargs_)
        else:
            return TableLocator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TableLocator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TableLocator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TableLocator':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TableLocator')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TableLocator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TableLocator'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TableLocator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TableLocator


class InlineTable(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, row=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if row is None:
            self.row = []
        else:
            self.row = row
        self.row_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InlineTable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InlineTable.subclass:
            return InlineTable.subclass(*args_, **kwargs_)
        else:
            return InlineTable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_row(self):
        return self.row
    def set_row(self, row):
        self.row = row
    def add_row(self, value):
        self.row.append(value)
    def insert_row_at(self, index, value):
        self.row.insert(index, value)
    def replace_row_at(self, index, value):
        self.row[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.row
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='InlineTable', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InlineTable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InlineTable':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InlineTable')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InlineTable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InlineTable'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='InlineTable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for row_ in self.row:
            namespaceprefix_ = self.row_nsprefix_ + ':' if (UseCapturedNS_ and self.row_nsprefix_) else ''
            row_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='row', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'row':
            obj_ = row.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.row.append(obj_)
            obj_.original_tagname_ = 'row'
# end class InlineTable


class row(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, row)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if row.subclass:
            return row.subclass(*args_, **kwargs_)
        else:
            return row(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def _hasContent(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='row', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('row')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'row':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='row')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='row', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='row'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='row', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'row')
        self.anytypeobjs_.append(content_)
# end class row


class TransformationDictionary(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, DefineFunction=None, DerivedField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if DefineFunction is None:
            self.DefineFunction = []
        else:
            self.DefineFunction = DefineFunction
        self.DefineFunction_nsprefix_ = None
        if DerivedField is None:
            self.DerivedField = []
        else:
            self.DerivedField = DerivedField
        self.DerivedField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformationDictionary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformationDictionary.subclass:
            return TransformationDictionary.subclass(*args_, **kwargs_)
        else:
            return TransformationDictionary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_DefineFunction(self):
        return self.DefineFunction
    def set_DefineFunction(self, DefineFunction):
        self.DefineFunction = DefineFunction
    def add_DefineFunction(self, value):
        self.DefineFunction.append(value)
    def insert_DefineFunction_at(self, index, value):
        self.DefineFunction.insert(index, value)
    def replace_DefineFunction_at(self, index, value):
        self.DefineFunction[index] = value
    def get_DerivedField(self):
        return self.DerivedField
    def set_DerivedField(self, DerivedField):
        self.DerivedField = DerivedField
    def add_DerivedField(self, value):
        self.DerivedField.append(value)
    def insert_DerivedField_at(self, index, value):
        self.DerivedField.insert(index, value)
    def replace_DerivedField_at(self, index, value):
        self.DerivedField[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.DefineFunction or
            self.DerivedField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TransformationDictionary', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformationDictionary')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TransformationDictionary':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransformationDictionary')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransformationDictionary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TransformationDictionary'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TransformationDictionary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for DefineFunction_ in self.DefineFunction:
            namespaceprefix_ = self.DefineFunction_nsprefix_ + ':' if (UseCapturedNS_ and self.DefineFunction_nsprefix_) else ''
            DefineFunction_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DefineFunction', pretty_print=pretty_print)
        for DerivedField_ in self.DerivedField:
            namespaceprefix_ = self.DerivedField_nsprefix_ + ':' if (UseCapturedNS_ and self.DerivedField_nsprefix_) else ''
            DerivedField_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DerivedField', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DefineFunction':
            obj_ = DefineFunction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefineFunction.append(obj_)
            obj_.original_tagname_ = 'DefineFunction'
        elif nodeName_ == 'DerivedField':
            obj_ = DerivedField.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DerivedField.append(obj_)
            obj_.original_tagname_ = 'DerivedField'
# end class TransformationDictionary


class LocalTransformations(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, DerivedField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if DerivedField is None:
            self.DerivedField = []
        else:
            self.DerivedField = DerivedField
        self.DerivedField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocalTransformations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalTransformations.subclass:
            return LocalTransformations.subclass(*args_, **kwargs_)
        else:
            return LocalTransformations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_DerivedField(self):
        return self.DerivedField
    def set_DerivedField(self, DerivedField):
        self.DerivedField = DerivedField
    def add_DerivedField(self, value):
        self.DerivedField.append(value)
    def insert_DerivedField_at(self, index, value):
        self.DerivedField.insert(index, value)
    def replace_DerivedField_at(self, index, value):
        self.DerivedField[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.DerivedField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='LocalTransformations', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocalTransformations')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LocalTransformations':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocalTransformations')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LocalTransformations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LocalTransformations'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='LocalTransformations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for DerivedField_ in self.DerivedField:
            namespaceprefix_ = self.DerivedField_nsprefix_ + ':' if (UseCapturedNS_ and self.DerivedField_nsprefix_) else ''
            DerivedField_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DerivedField', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DerivedField':
            obj_ = DerivedField.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DerivedField.append(obj_)
            obj_.original_tagname_ = 'DerivedField'
# end class LocalTransformations


class DerivedField(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, optype=None, dataType=None, Extension=None, Constant=None, FieldRef=None, NormContinuous=None, NormDiscrete=None, Discretize=None, MapValues=None, Apply=None, Aggregate=None, Value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.optype = _cast(None, optype)
        self.optype_nsprefix_ = None
        self.dataType = _cast(None, dataType)
        self.dataType_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Constant = Constant
        self.Constant_nsprefix_ = None
        self.FieldRef = FieldRef
        self.FieldRef_nsprefix_ = None
        self.NormContinuous = NormContinuous
        self.NormContinuous_nsprefix_ = None
        self.NormDiscrete = NormDiscrete
        self.NormDiscrete_nsprefix_ = None
        self.Discretize = Discretize
        self.Discretize_nsprefix_ = None
        self.MapValues = MapValues
        self.MapValues_nsprefix_ = None
        self.Apply = Apply
        self.Apply_nsprefix_ = None
        self.Aggregate = Aggregate
        self.Aggregate_nsprefix_ = None
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.Value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DerivedField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DerivedField.subclass:
            return DerivedField.subclass(*args_, **kwargs_)
        else:
            return DerivedField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Constant(self):
        return self.Constant
    def set_Constant(self, Constant):
        self.Constant = Constant
    def get_FieldRef(self):
        return self.FieldRef
    def set_FieldRef(self, FieldRef):
        self.FieldRef = FieldRef
    def get_NormContinuous(self):
        return self.NormContinuous
    def set_NormContinuous(self, NormContinuous):
        self.NormContinuous = NormContinuous
    def get_NormDiscrete(self):
        return self.NormDiscrete
    def set_NormDiscrete(self, NormDiscrete):
        self.NormDiscrete = NormDiscrete
    def get_Discretize(self):
        return self.Discretize
    def set_Discretize(self, Discretize):
        self.Discretize = Discretize
    def get_MapValues(self):
        return self.MapValues
    def set_MapValues(self, MapValues):
        self.MapValues = MapValues
    def get_Apply(self):
        return self.Apply
    def set_Apply(self, Apply):
        self.Apply = Apply
    def get_Aggregate(self):
        return self.Aggregate
    def set_Aggregate(self, Aggregate):
        self.Aggregate = Aggregate
    def get_Value(self):
        return self.Value
    def set_Value(self, Value):
        self.Value = Value
    def add_Value(self, value):
        self.Value.append(value)
    def insert_Value_at(self, index, value):
        self.Value.insert(index, value)
    def replace_Value_at(self, index, value):
        self.Value[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_optype(self):
        return self.optype
    def set_optype(self, optype):
        self.optype = optype
    def get_dataType(self):
        return self.dataType
    def set_dataType(self, dataType):
        self.dataType = dataType
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['categorical', 'ordinal', 'continuous']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OPTYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DATATYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.Constant is not None or
            self.FieldRef is not None or
            self.NormContinuous is not None or
            self.NormDiscrete is not None or
            self.Discretize is not None or
            self.MapValues is not None or
            self.Apply is not None or
            self.Aggregate is not None or
            self.Value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DerivedField', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DerivedField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DerivedField':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DerivedField')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DerivedField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DerivedField'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.optype), input_name='optype')), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataType), input_name='dataType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DerivedField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Constant is not None:
            namespaceprefix_ = self.Constant_nsprefix_ + ':' if (UseCapturedNS_ and self.Constant_nsprefix_) else ''
            self.Constant.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Constant', pretty_print=pretty_print)
        if self.FieldRef is not None:
            namespaceprefix_ = self.FieldRef_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldRef_nsprefix_) else ''
            self.FieldRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldRef', pretty_print=pretty_print)
        if self.NormContinuous is not None:
            namespaceprefix_ = self.NormContinuous_nsprefix_ + ':' if (UseCapturedNS_ and self.NormContinuous_nsprefix_) else ''
            self.NormContinuous.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NormContinuous', pretty_print=pretty_print)
        if self.NormDiscrete is not None:
            namespaceprefix_ = self.NormDiscrete_nsprefix_ + ':' if (UseCapturedNS_ and self.NormDiscrete_nsprefix_) else ''
            self.NormDiscrete.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NormDiscrete', pretty_print=pretty_print)
        if self.Discretize is not None:
            namespaceprefix_ = self.Discretize_nsprefix_ + ':' if (UseCapturedNS_ and self.Discretize_nsprefix_) else ''
            self.Discretize.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Discretize', pretty_print=pretty_print)
        if self.MapValues is not None:
            namespaceprefix_ = self.MapValues_nsprefix_ + ':' if (UseCapturedNS_ and self.MapValues_nsprefix_) else ''
            self.MapValues.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MapValues', pretty_print=pretty_print)
        if self.Apply is not None:
            namespaceprefix_ = self.Apply_nsprefix_ + ':' if (UseCapturedNS_ and self.Apply_nsprefix_) else ''
            self.Apply.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Apply', pretty_print=pretty_print)
        if self.Aggregate is not None:
            namespaceprefix_ = self.Aggregate_nsprefix_ + ':' if (UseCapturedNS_ and self.Aggregate_nsprefix_) else ''
            self.Aggregate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Aggregate', pretty_print=pretty_print)
        for Value_ in self.Value:
            namespaceprefix_ = self.Value_nsprefix_ + ':' if (UseCapturedNS_ and self.Value_nsprefix_) else ''
            Value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Value', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Constant':
            obj_ = Constant.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Constant = obj_
            obj_.original_tagname_ = 'Constant'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldRef = obj_
            obj_.original_tagname_ = 'FieldRef'
        elif nodeName_ == 'NormContinuous':
            obj_ = NormContinuous.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NormContinuous = obj_
            obj_.original_tagname_ = 'NormContinuous'
        elif nodeName_ == 'NormDiscrete':
            obj_ = NormDiscrete.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NormDiscrete = obj_
            obj_.original_tagname_ = 'NormDiscrete'
        elif nodeName_ == 'Discretize':
            obj_ = Discretize.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Discretize = obj_
            obj_.original_tagname_ = 'Discretize'
        elif nodeName_ == 'MapValues':
            obj_ = MapValues.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MapValues = obj_
            obj_.original_tagname_ = 'MapValues'
        elif nodeName_ == 'Apply':
            obj_ = Apply.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Apply = obj_
            obj_.original_tagname_ = 'Apply'
        elif nodeName_ == 'Aggregate':
            obj_ = Aggregate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Aggregate = obj_
            obj_.original_tagname_ = 'Aggregate'
        elif nodeName_ == 'Value':
            obj_ = Value.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
# end class DerivedField


class Constant(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dataType=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dataType = _cast(None, dataType)
        self.dataType_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Constant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Constant.subclass:
            return Constant.subclass(*args_, **kwargs_)
        else:
            return Constant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dataType(self):
        return self.dataType
    def set_dataType(self, dataType):
        self.dataType = dataType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DATATYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Constant', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Constant')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Constant':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Constant')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Constant', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Constant'):
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataType), input_name='dataType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Constant', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Constant


class FieldRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, field=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FieldRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FieldRef.subclass:
            return FieldRef.subclass(*args_, **kwargs_)
        else:
            return FieldRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='FieldRef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FieldRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FieldRef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FieldRef')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FieldRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FieldRef'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='FieldRef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class FieldRef


class NormContinuous(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, mapMissingTo=None, field=None, outliers='asIs', Extension=None, LinearNorm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mapMissingTo = _cast(float, mapMissingTo)
        self.mapMissingTo_nsprefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        self.outliers = _cast(None, outliers)
        self.outliers_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if LinearNorm is None:
            self.LinearNorm = []
        else:
            self.LinearNorm = LinearNorm
        self.LinearNorm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NormContinuous)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NormContinuous.subclass:
            return NormContinuous.subclass(*args_, **kwargs_)
        else:
            return NormContinuous(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_LinearNorm(self):
        return self.LinearNorm
    def set_LinearNorm(self, LinearNorm):
        self.LinearNorm = LinearNorm
    def add_LinearNorm(self, value):
        self.LinearNorm.append(value)
    def insert_LinearNorm_at(self, index, value):
        self.LinearNorm.insert(index, value)
    def replace_LinearNorm_at(self, index, value):
        self.LinearNorm[index] = value
    def get_mapMissingTo(self):
        return self.mapMissingTo
    def set_mapMissingTo(self, mapMissingTo):
        self.mapMissingTo = mapMissingTo
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_outliers(self):
        return self.outliers
    def set_outliers(self, outliers):
        self.outliers = outliers
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_OUTLIER_TREATMENT_METHOD(self, value):
        # Validate type OUTLIER-TREATMENT-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['asIs', 'asMissingValues', 'asExtremeValues']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OUTLIER-TREATMENT-METHOD' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.LinearNorm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NormContinuous', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NormContinuous')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NormContinuous':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NormContinuous')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NormContinuous', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NormContinuous'):
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            outfile.write(' mapMissingTo="%s"' % self.gds_format_double(self.mapMissingTo, input_name='mapMissingTo'))
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.outliers != "asIs" and 'outliers' not in already_processed:
            already_processed.add('outliers')
            outfile.write(' outliers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.outliers), input_name='outliers')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NormContinuous', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for LinearNorm_ in self.LinearNorm:
            namespaceprefix_ = self.LinearNorm_nsprefix_ + ':' if (UseCapturedNS_ and self.LinearNorm_nsprefix_) else ''
            LinearNorm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LinearNorm', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mapMissingTo', node)
        if value is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            value = self.gds_parse_double(value, node, 'mapMissingTo')
            self.mapMissingTo = value
            self.validate_NUMBER(self.mapMissingTo)    # validate type NUMBER
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('outliers', node)
        if value is not None and 'outliers' not in already_processed:
            already_processed.add('outliers')
            self.outliers = value
            self.validate_OUTLIER_TREATMENT_METHOD(self.outliers)    # validate type OUTLIER-TREATMENT-METHOD
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'LinearNorm':
            obj_ = LinearNorm.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LinearNorm.append(obj_)
            obj_.original_tagname_ = 'LinearNorm'
# end class NormContinuous


class LinearNorm(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, orig=None, norm=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.orig = _cast(float, orig)
        self.orig_nsprefix_ = None
        self.norm = _cast(float, norm)
        self.norm_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinearNorm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinearNorm.subclass:
            return LinearNorm.subclass(*args_, **kwargs_)
        else:
            return LinearNorm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_norm(self):
        return self.norm
    def set_norm(self, norm):
        self.norm = norm
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='LinearNorm', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LinearNorm')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LinearNorm':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LinearNorm')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LinearNorm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LinearNorm'):
        if self.orig is not None and 'orig' not in already_processed:
            already_processed.add('orig')
            outfile.write(' orig="%s"' % self.gds_format_double(self.orig, input_name='orig'))
        if self.norm is not None and 'norm' not in already_processed:
            already_processed.add('norm')
            outfile.write(' norm="%s"' % self.gds_format_double(self.norm, input_name='norm'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='LinearNorm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('orig', node)
        if value is not None and 'orig' not in already_processed:
            already_processed.add('orig')
            value = self.gds_parse_double(value, node, 'orig')
            self.orig = value
            self.validate_NUMBER(self.orig)    # validate type NUMBER
        value = find_attr_value_('norm', node)
        if value is not None and 'norm' not in already_processed:
            already_processed.add('norm')
            value = self.gds_parse_double(value, node, 'norm')
            self.norm = value
            self.validate_NUMBER(self.norm)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class LinearNorm


class NormDiscrete(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, field=None, method='indicator', value=None, mapMissingTo=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        self.method = _cast(None, method)
        self.method_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.mapMissingTo = _cast(float, mapMissingTo)
        self.mapMissingTo_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NormDiscrete)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NormDiscrete.subclass:
            return NormDiscrete.subclass(*args_, **kwargs_)
        else:
            return NormDiscrete(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_method(self):
        return self.method
    def set_method(self, method):
        self.method = method
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_mapMissingTo(self):
        return self.mapMissingTo
    def set_mapMissingTo(self, mapMissingTo):
        self.mapMissingTo = mapMissingTo
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_methodType(self, value):
        # Validate type methodType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['indicator']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on methodType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NormDiscrete', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NormDiscrete')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NormDiscrete':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NormDiscrete')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NormDiscrete', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NormDiscrete'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.method != "indicator" and 'method' not in already_processed:
            already_processed.add('method')
            outfile.write(' method=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.method), input_name='method')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            outfile.write(' mapMissingTo="%s"' % self.gds_format_double(self.mapMissingTo, input_name='mapMissingTo'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NormDiscrete', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('method', node)
        if value is not None and 'method' not in already_processed:
            already_processed.add('method')
            self.method = value
            self.validate_methodType(self.method)    # validate type methodType
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('mapMissingTo', node)
        if value is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            value = self.gds_parse_double(value, node, 'mapMissingTo')
            self.mapMissingTo = value
            self.validate_NUMBER(self.mapMissingTo)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class NormDiscrete


class Discretize(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, field=None, mapMissingTo=None, defaultValue=None, dataType=None, Extension=None, DiscretizeBin=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        self.mapMissingTo = _cast(None, mapMissingTo)
        self.mapMissingTo_nsprefix_ = None
        self.defaultValue = _cast(None, defaultValue)
        self.defaultValue_nsprefix_ = None
        self.dataType = _cast(None, dataType)
        self.dataType_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if DiscretizeBin is None:
            self.DiscretizeBin = []
        else:
            self.DiscretizeBin = DiscretizeBin
        self.DiscretizeBin_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Discretize)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Discretize.subclass:
            return Discretize.subclass(*args_, **kwargs_)
        else:
            return Discretize(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_DiscretizeBin(self):
        return self.DiscretizeBin
    def set_DiscretizeBin(self, DiscretizeBin):
        self.DiscretizeBin = DiscretizeBin
    def add_DiscretizeBin(self, value):
        self.DiscretizeBin.append(value)
    def insert_DiscretizeBin_at(self, index, value):
        self.DiscretizeBin.insert(index, value)
    def replace_DiscretizeBin_at(self, index, value):
        self.DiscretizeBin[index] = value
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_mapMissingTo(self):
        return self.mapMissingTo
    def set_mapMissingTo(self, mapMissingTo):
        self.mapMissingTo = mapMissingTo
    def get_defaultValue(self):
        return self.defaultValue
    def set_defaultValue(self, defaultValue):
        self.defaultValue = defaultValue
    def get_dataType(self):
        return self.dataType
    def set_dataType(self, dataType):
        self.dataType = dataType
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DATATYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.DiscretizeBin
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Discretize', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Discretize')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Discretize':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Discretize')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Discretize', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Discretize'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            outfile.write(' mapMissingTo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mapMissingTo), input_name='mapMissingTo')), ))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            outfile.write(' defaultValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.defaultValue), input_name='defaultValue')), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataType), input_name='dataType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Discretize', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for DiscretizeBin_ in self.DiscretizeBin:
            namespaceprefix_ = self.DiscretizeBin_nsprefix_ + ':' if (UseCapturedNS_ and self.DiscretizeBin_nsprefix_) else ''
            DiscretizeBin_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DiscretizeBin', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('mapMissingTo', node)
        if value is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            self.mapMissingTo = value
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            self.defaultValue = value
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DiscretizeBin':
            obj_ = DiscretizeBin.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DiscretizeBin.append(obj_)
            obj_.original_tagname_ = 'DiscretizeBin'
# end class Discretize


class DiscretizeBin(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, binValue=None, Extension=None, Interval=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.binValue = _cast(None, binValue)
        self.binValue_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Interval = Interval
        self.Interval_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiscretizeBin)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiscretizeBin.subclass:
            return DiscretizeBin.subclass(*args_, **kwargs_)
        else:
            return DiscretizeBin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Interval(self):
        return self.Interval
    def set_Interval(self, Interval):
        self.Interval = Interval
    def get_binValue(self):
        return self.binValue
    def set_binValue(self, binValue):
        self.binValue = binValue
    def _hasContent(self):
        if (
            self.Extension or
            self.Interval is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DiscretizeBin', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DiscretizeBin')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DiscretizeBin':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DiscretizeBin')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DiscretizeBin', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DiscretizeBin'):
        if self.binValue is not None and 'binValue' not in already_processed:
            already_processed.add('binValue')
            outfile.write(' binValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.binValue), input_name='binValue')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DiscretizeBin', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Interval is not None:
            namespaceprefix_ = self.Interval_nsprefix_ + ':' if (UseCapturedNS_ and self.Interval_nsprefix_) else ''
            self.Interval.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Interval', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('binValue', node)
        if value is not None and 'binValue' not in already_processed:
            already_processed.add('binValue')
            self.binValue = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Interval':
            obj_ = Interval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Interval = obj_
            obj_.original_tagname_ = 'Interval'
# end class DiscretizeBin


class MapValues(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, mapMissingTo=None, defaultValue=None, outputColumn=None, dataType=None, Extension=None, FieldColumnPair=None, TableLocator=None, InlineTable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mapMissingTo = _cast(None, mapMissingTo)
        self.mapMissingTo_nsprefix_ = None
        self.defaultValue = _cast(None, defaultValue)
        self.defaultValue_nsprefix_ = None
        self.outputColumn = _cast(None, outputColumn)
        self.outputColumn_nsprefix_ = None
        self.dataType = _cast(None, dataType)
        self.dataType_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if FieldColumnPair is None:
            self.FieldColumnPair = []
        else:
            self.FieldColumnPair = FieldColumnPair
        self.FieldColumnPair_nsprefix_ = None
        self.TableLocator = TableLocator
        self.TableLocator_nsprefix_ = None
        self.InlineTable = InlineTable
        self.InlineTable_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MapValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MapValues.subclass:
            return MapValues.subclass(*args_, **kwargs_)
        else:
            return MapValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_FieldColumnPair(self):
        return self.FieldColumnPair
    def set_FieldColumnPair(self, FieldColumnPair):
        self.FieldColumnPair = FieldColumnPair
    def add_FieldColumnPair(self, value):
        self.FieldColumnPair.append(value)
    def insert_FieldColumnPair_at(self, index, value):
        self.FieldColumnPair.insert(index, value)
    def replace_FieldColumnPair_at(self, index, value):
        self.FieldColumnPair[index] = value
    def get_TableLocator(self):
        return self.TableLocator
    def set_TableLocator(self, TableLocator):
        self.TableLocator = TableLocator
    def get_InlineTable(self):
        return self.InlineTable
    def set_InlineTable(self, InlineTable):
        self.InlineTable = InlineTable
    def get_mapMissingTo(self):
        return self.mapMissingTo
    def set_mapMissingTo(self, mapMissingTo):
        self.mapMissingTo = mapMissingTo
    def get_defaultValue(self):
        return self.defaultValue
    def set_defaultValue(self, defaultValue):
        self.defaultValue = defaultValue
    def get_outputColumn(self):
        return self.outputColumn
    def set_outputColumn(self, outputColumn):
        self.outputColumn = outputColumn
    def get_dataType(self):
        return self.dataType
    def set_dataType(self, dataType):
        self.dataType = dataType
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DATATYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.FieldColumnPair or
            self.TableLocator is not None or
            self.InlineTable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='MapValues', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MapValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MapValues':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MapValues')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MapValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MapValues'):
        if self.mapMissingTo is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            outfile.write(' mapMissingTo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mapMissingTo), input_name='mapMissingTo')), ))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            outfile.write(' defaultValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.defaultValue), input_name='defaultValue')), ))
        if self.outputColumn is not None and 'outputColumn' not in already_processed:
            already_processed.add('outputColumn')
            outfile.write(' outputColumn=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.outputColumn), input_name='outputColumn')), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataType), input_name='dataType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='MapValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for FieldColumnPair_ in self.FieldColumnPair:
            namespaceprefix_ = self.FieldColumnPair_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldColumnPair_nsprefix_) else ''
            FieldColumnPair_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldColumnPair', pretty_print=pretty_print)
        if self.TableLocator is not None:
            namespaceprefix_ = self.TableLocator_nsprefix_ + ':' if (UseCapturedNS_ and self.TableLocator_nsprefix_) else ''
            self.TableLocator.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TableLocator', pretty_print=pretty_print)
        if self.InlineTable is not None:
            namespaceprefix_ = self.InlineTable_nsprefix_ + ':' if (UseCapturedNS_ and self.InlineTable_nsprefix_) else ''
            self.InlineTable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InlineTable', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mapMissingTo', node)
        if value is not None and 'mapMissingTo' not in already_processed:
            already_processed.add('mapMissingTo')
            self.mapMissingTo = value
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            self.defaultValue = value
        value = find_attr_value_('outputColumn', node)
        if value is not None and 'outputColumn' not in already_processed:
            already_processed.add('outputColumn')
            self.outputColumn = value
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldColumnPair':
            obj_ = FieldColumnPair.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldColumnPair.append(obj_)
            obj_.original_tagname_ = 'FieldColumnPair'
        elif nodeName_ == 'TableLocator':
            obj_ = TableLocator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TableLocator = obj_
            obj_.original_tagname_ = 'TableLocator'
        elif nodeName_ == 'InlineTable':
            obj_ = InlineTable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InlineTable = obj_
            obj_.original_tagname_ = 'InlineTable'
# end class MapValues


class FieldColumnPair(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, field=None, column=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        self.column = _cast(None, column)
        self.column_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FieldColumnPair)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FieldColumnPair.subclass:
            return FieldColumnPair.subclass(*args_, **kwargs_)
        else:
            return FieldColumnPair(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_column(self):
        return self.column
    def set_column(self, column):
        self.column = column
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='FieldColumnPair', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FieldColumnPair')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FieldColumnPair':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FieldColumnPair')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FieldColumnPair', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FieldColumnPair'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.column is not None and 'column' not in already_processed:
            already_processed.add('column')
            outfile.write(' column=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.column), input_name='column')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='FieldColumnPair', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('column', node)
        if value is not None and 'column' not in already_processed:
            already_processed.add('column')
            self.column = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class FieldColumnPair


class Aggregate(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, field=None, function=None, groupField=None, sqlWhere=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        self.function = _cast(None, function)
        self.function_nsprefix_ = None
        self.groupField = _cast(None, groupField)
        self.groupField_nsprefix_ = None
        self.sqlWhere = _cast(None, sqlWhere)
        self.sqlWhere_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Aggregate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Aggregate.subclass:
            return Aggregate.subclass(*args_, **kwargs_)
        else:
            return Aggregate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_function(self):
        return self.function
    def set_function(self, function):
        self.function = function
    def get_groupField(self):
        return self.groupField
    def set_groupField(self, groupField):
        self.groupField = groupField
    def get_sqlWhere(self):
        return self.sqlWhere
    def set_sqlWhere(self, sqlWhere):
        self.sqlWhere = sqlWhere
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_functionType(self, value):
        # Validate type functionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['count', 'sum', 'average', 'min', 'max', 'multiset']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on functionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Aggregate', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Aggregate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Aggregate':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Aggregate')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Aggregate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Aggregate'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.function is not None and 'function' not in already_processed:
            already_processed.add('function')
            outfile.write(' function=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.function), input_name='function')), ))
        if self.groupField is not None and 'groupField' not in already_processed:
            already_processed.add('groupField')
            outfile.write(' groupField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.groupField), input_name='groupField')), ))
        if self.sqlWhere is not None and 'sqlWhere' not in already_processed:
            already_processed.add('sqlWhere')
            outfile.write(' sqlWhere=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sqlWhere), input_name='sqlWhere')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Aggregate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('function', node)
        if value is not None and 'function' not in already_processed:
            already_processed.add('function')
            self.function = value
            self.validate_functionType(self.function)    # validate type functionType
        value = find_attr_value_('groupField', node)
        if value is not None and 'groupField' not in already_processed:
            already_processed.add('groupField')
            self.groupField = value
            self.validate_FIELD_NAME(self.groupField)    # validate type FIELD-NAME
        value = find_attr_value_('sqlWhere', node)
        if value is not None and 'sqlWhere' not in already_processed:
            already_processed.add('sqlWhere')
            self.sqlWhere = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Aggregate


class MiningSchema(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, MiningField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if MiningField is None:
            self.MiningField = []
        else:
            self.MiningField = MiningField
        self.MiningField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MiningSchema)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MiningSchema.subclass:
            return MiningSchema.subclass(*args_, **kwargs_)
        else:
            return MiningSchema(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_MiningField(self):
        return self.MiningField
    def set_MiningField(self, MiningField):
        self.MiningField = MiningField
    def add_MiningField(self, value):
        self.MiningField.append(value)
    def insert_MiningField_at(self, index, value):
        self.MiningField.insert(index, value)
    def replace_MiningField_at(self, index, value):
        self.MiningField[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.MiningField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='MiningSchema', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MiningSchema')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MiningSchema':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MiningSchema')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MiningSchema', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MiningSchema'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='MiningSchema', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for MiningField_ in self.MiningField:
            namespaceprefix_ = self.MiningField_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningField_nsprefix_) else ''
            MiningField_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningField', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'MiningField':
            obj_ = MiningField.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningField.append(obj_)
            obj_.original_tagname_ = 'MiningField'
# end class MiningSchema


class MiningField(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, usageType='active', optype=None, importance=None, outliers='asIs', lowValue=None, highValue=None, missingValueReplacement=None, missingValueTreatment=None, invalidValueTreatment='returnInvalid', Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.usageType = _cast(None, usageType)
        self.usageType_nsprefix_ = None
        self.optype = _cast(None, optype)
        self.optype_nsprefix_ = None
        self.importance = _cast(float, importance)
        self.importance_nsprefix_ = None
        self.outliers = _cast(None, outliers)
        self.outliers_nsprefix_ = None
        self.lowValue = _cast(float, lowValue)
        self.lowValue_nsprefix_ = None
        self.highValue = _cast(float, highValue)
        self.highValue_nsprefix_ = None
        self.missingValueReplacement = _cast(None, missingValueReplacement)
        self.missingValueReplacement_nsprefix_ = None
        self.missingValueTreatment = _cast(None, missingValueTreatment)
        self.missingValueTreatment_nsprefix_ = None
        self.invalidValueTreatment = _cast(None, invalidValueTreatment)
        self.invalidValueTreatment_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MiningField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MiningField.subclass:
            return MiningField.subclass(*args_, **kwargs_)
        else:
            return MiningField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_usageType(self):
        return self.usageType
    def set_usageType(self, usageType):
        self.usageType = usageType
    def get_optype(self):
        return self.optype
    def set_optype(self, optype):
        self.optype = optype
    def get_importance(self):
        return self.importance
    def set_importance(self, importance):
        self.importance = importance
    def get_outliers(self):
        return self.outliers
    def set_outliers(self, outliers):
        self.outliers = outliers
    def get_lowValue(self):
        return self.lowValue
    def set_lowValue(self, lowValue):
        self.lowValue = lowValue
    def get_highValue(self):
        return self.highValue
    def set_highValue(self, highValue):
        self.highValue = highValue
    def get_missingValueReplacement(self):
        return self.missingValueReplacement
    def set_missingValueReplacement(self, missingValueReplacement):
        self.missingValueReplacement = missingValueReplacement
    def get_missingValueTreatment(self):
        return self.missingValueTreatment
    def set_missingValueTreatment(self, missingValueTreatment):
        self.missingValueTreatment = missingValueTreatment
    def get_invalidValueTreatment(self):
        return self.invalidValueTreatment
    def set_invalidValueTreatment(self, invalidValueTreatment):
        self.invalidValueTreatment = invalidValueTreatment
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_FIELD_USAGE_TYPE(self, value):
        # Validate type FIELD-USAGE-TYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['active', 'predicted', 'supplementary', 'group', 'order', 'frequencyWeight', 'analysisWeight']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on FIELD-USAGE-TYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['categorical', 'ordinal', 'continuous']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OPTYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_OUTLIER_TREATMENT_METHOD(self, value):
        # Validate type OUTLIER-TREATMENT-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['asIs', 'asMissingValues', 'asExtremeValues']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OUTLIER-TREATMENT-METHOD' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_MISSING_VALUE_TREATMENT_METHOD(self, value):
        # Validate type MISSING-VALUE-TREATMENT-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['asIs', 'asMean', 'asMode', 'asMedian', 'asValue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MISSING-VALUE-TREATMENT-METHOD' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_INVALID_VALUE_TREATMENT_METHOD(self, value):
        # Validate type INVALID-VALUE-TREATMENT-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['returnInvalid', 'asIs', 'asMissing']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on INVALID-VALUE-TREATMENT-METHOD' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='MiningField', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MiningField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MiningField':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MiningField')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MiningField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MiningField'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.usageType != "active" and 'usageType' not in already_processed:
            already_processed.add('usageType')
            outfile.write(' usageType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usageType), input_name='usageType')), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.optype), input_name='optype')), ))
        if self.importance is not None and 'importance' not in already_processed:
            already_processed.add('importance')
            outfile.write(' importance="%s"' % self.gds_format_decimal(self.importance, input_name='importance'))
        if self.outliers != "asIs" and 'outliers' not in already_processed:
            already_processed.add('outliers')
            outfile.write(' outliers=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.outliers), input_name='outliers')), ))
        if self.lowValue is not None and 'lowValue' not in already_processed:
            already_processed.add('lowValue')
            outfile.write(' lowValue="%s"' % self.gds_format_double(self.lowValue, input_name='lowValue'))
        if self.highValue is not None and 'highValue' not in already_processed:
            already_processed.add('highValue')
            outfile.write(' highValue="%s"' % self.gds_format_double(self.highValue, input_name='highValue'))
        if self.missingValueReplacement is not None and 'missingValueReplacement' not in already_processed:
            already_processed.add('missingValueReplacement')
            outfile.write(' missingValueReplacement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.missingValueReplacement), input_name='missingValueReplacement')), ))
        if self.missingValueTreatment is not None and 'missingValueTreatment' not in already_processed:
            already_processed.add('missingValueTreatment')
            outfile.write(' missingValueTreatment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.missingValueTreatment), input_name='missingValueTreatment')), ))
        if self.invalidValueTreatment != "returnInvalid" and 'invalidValueTreatment' not in already_processed:
            already_processed.add('invalidValueTreatment')
            outfile.write(' invalidValueTreatment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.invalidValueTreatment), input_name='invalidValueTreatment')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='MiningField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('usageType', node)
        if value is not None and 'usageType' not in already_processed:
            already_processed.add('usageType')
            self.usageType = value
            self.validate_FIELD_USAGE_TYPE(self.usageType)    # validate type FIELD-USAGE-TYPE
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('importance', node)
        if value is not None and 'importance' not in already_processed:
            already_processed.add('importance')
            value = self.gds_parse_decimal(value, node, 'importance')
            self.importance = value
            self.validate_PROB_NUMBER(self.importance)    # validate type PROB-NUMBER
        value = find_attr_value_('outliers', node)
        if value is not None and 'outliers' not in already_processed:
            already_processed.add('outliers')
            self.outliers = value
            self.validate_OUTLIER_TREATMENT_METHOD(self.outliers)    # validate type OUTLIER-TREATMENT-METHOD
        value = find_attr_value_('lowValue', node)
        if value is not None and 'lowValue' not in already_processed:
            already_processed.add('lowValue')
            value = self.gds_parse_double(value, node, 'lowValue')
            self.lowValue = value
            self.validate_NUMBER(self.lowValue)    # validate type NUMBER
        value = find_attr_value_('highValue', node)
        if value is not None and 'highValue' not in already_processed:
            already_processed.add('highValue')
            value = self.gds_parse_double(value, node, 'highValue')
            self.highValue = value
            self.validate_NUMBER(self.highValue)    # validate type NUMBER
        value = find_attr_value_('missingValueReplacement', node)
        if value is not None and 'missingValueReplacement' not in already_processed:
            already_processed.add('missingValueReplacement')
            self.missingValueReplacement = value
        value = find_attr_value_('missingValueTreatment', node)
        if value is not None and 'missingValueTreatment' not in already_processed:
            already_processed.add('missingValueTreatment')
            self.missingValueTreatment = value
            self.validate_MISSING_VALUE_TREATMENT_METHOD(self.missingValueTreatment)    # validate type MISSING-VALUE-TREATMENT-METHOD
        value = find_attr_value_('invalidValueTreatment', node)
        if value is not None and 'invalidValueTreatment' not in already_processed:
            already_processed.add('invalidValueTreatment')
            self.invalidValueTreatment = value
            self.validate_INVALID_VALUE_TREATMENT_METHOD(self.invalidValueTreatment)    # validate type INVALID-VALUE-TREATMENT-METHOD
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class MiningField


class ModelStats(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, UnivariateStats=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if UnivariateStats is None:
            self.UnivariateStats = []
        else:
            self.UnivariateStats = UnivariateStats
        self.UnivariateStats_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModelStats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModelStats.subclass:
            return ModelStats.subclass(*args_, **kwargs_)
        else:
            return ModelStats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_UnivariateStats(self):
        return self.UnivariateStats
    def set_UnivariateStats(self, UnivariateStats):
        self.UnivariateStats = UnivariateStats
    def add_UnivariateStats(self, value):
        self.UnivariateStats.append(value)
    def insert_UnivariateStats_at(self, index, value):
        self.UnivariateStats.insert(index, value)
    def replace_UnivariateStats_at(self, index, value):
        self.UnivariateStats[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.UnivariateStats
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ModelStats', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ModelStats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ModelStats':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ModelStats')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ModelStats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ModelStats'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ModelStats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for UnivariateStats_ in self.UnivariateStats:
            namespaceprefix_ = self.UnivariateStats_nsprefix_ + ':' if (UseCapturedNS_ and self.UnivariateStats_nsprefix_) else ''
            UnivariateStats_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UnivariateStats', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'UnivariateStats':
            obj_ = UnivariateStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UnivariateStats.append(obj_)
            obj_.original_tagname_ = 'UnivariateStats'
# end class ModelStats


class UnivariateStats(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, field=None, weighted='0', Extension=None, Counts=None, NumericInfo=None, DiscrStats=None, ContStats=None, Anova=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        self.weighted = _cast(None, weighted)
        self.weighted_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Counts = Counts
        self.Counts_nsprefix_ = None
        self.NumericInfo = NumericInfo
        self.NumericInfo_nsprefix_ = None
        self.DiscrStats = DiscrStats
        self.DiscrStats_nsprefix_ = None
        self.ContStats = ContStats
        self.ContStats_nsprefix_ = None
        self.Anova = Anova
        self.Anova_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnivariateStats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnivariateStats.subclass:
            return UnivariateStats.subclass(*args_, **kwargs_)
        else:
            return UnivariateStats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Counts(self):
        return self.Counts
    def set_Counts(self, Counts):
        self.Counts = Counts
    def get_NumericInfo(self):
        return self.NumericInfo
    def set_NumericInfo(self, NumericInfo):
        self.NumericInfo = NumericInfo
    def get_DiscrStats(self):
        return self.DiscrStats
    def set_DiscrStats(self, DiscrStats):
        self.DiscrStats = DiscrStats
    def get_ContStats(self):
        return self.ContStats
    def set_ContStats(self, ContStats):
        self.ContStats = ContStats
    def get_Anova(self):
        return self.Anova
    def set_Anova(self, Anova):
        self.Anova = Anova
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_weighted(self):
        return self.weighted
    def set_weighted(self, weighted):
        self.weighted = weighted
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_weightedType(self, value):
        # Validate type weightedType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0', '1']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on weightedType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.Counts is not None or
            self.NumericInfo is not None or
            self.DiscrStats is not None or
            self.ContStats is not None or
            self.Anova is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='UnivariateStats', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnivariateStats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UnivariateStats':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnivariateStats')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnivariateStats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UnivariateStats'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.weighted != "0" and 'weighted' not in already_processed:
            already_processed.add('weighted')
            outfile.write(' weighted=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.weighted), input_name='weighted')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='UnivariateStats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Counts is not None:
            namespaceprefix_ = self.Counts_nsprefix_ + ':' if (UseCapturedNS_ and self.Counts_nsprefix_) else ''
            self.Counts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Counts', pretty_print=pretty_print)
        if self.NumericInfo is not None:
            namespaceprefix_ = self.NumericInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.NumericInfo_nsprefix_) else ''
            self.NumericInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NumericInfo', pretty_print=pretty_print)
        if self.DiscrStats is not None:
            namespaceprefix_ = self.DiscrStats_nsprefix_ + ':' if (UseCapturedNS_ and self.DiscrStats_nsprefix_) else ''
            self.DiscrStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DiscrStats', pretty_print=pretty_print)
        if self.ContStats is not None:
            namespaceprefix_ = self.ContStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ContStats_nsprefix_) else ''
            self.ContStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ContStats', pretty_print=pretty_print)
        if self.Anova is not None:
            namespaceprefix_ = self.Anova_nsprefix_ + ':' if (UseCapturedNS_ and self.Anova_nsprefix_) else ''
            self.Anova.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Anova', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('weighted', node)
        if value is not None and 'weighted' not in already_processed:
            already_processed.add('weighted')
            self.weighted = value
            self.validate_weightedType(self.weighted)    # validate type weightedType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Counts':
            obj_ = Counts.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Counts = obj_
            obj_.original_tagname_ = 'Counts'
        elif nodeName_ == 'NumericInfo':
            obj_ = NumericInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NumericInfo = obj_
            obj_.original_tagname_ = 'NumericInfo'
        elif nodeName_ == 'DiscrStats':
            obj_ = DiscrStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DiscrStats = obj_
            obj_.original_tagname_ = 'DiscrStats'
        elif nodeName_ == 'ContStats':
            obj_ = ContStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ContStats = obj_
            obj_.original_tagname_ = 'ContStats'
        elif nodeName_ == 'Anova':
            obj_ = Anova.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Anova = obj_
            obj_.original_tagname_ = 'Anova'
# end class UnivariateStats


class Counts(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, totalFreq=None, missingFreq=None, invalidFreq=None, cardinality=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.totalFreq = _cast(float, totalFreq)
        self.totalFreq_nsprefix_ = None
        self.missingFreq = _cast(float, missingFreq)
        self.missingFreq_nsprefix_ = None
        self.invalidFreq = _cast(float, invalidFreq)
        self.invalidFreq_nsprefix_ = None
        self.cardinality = _cast(int, cardinality)
        self.cardinality_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Counts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Counts.subclass:
            return Counts.subclass(*args_, **kwargs_)
        else:
            return Counts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_totalFreq(self):
        return self.totalFreq
    def set_totalFreq(self, totalFreq):
        self.totalFreq = totalFreq
    def get_missingFreq(self):
        return self.missingFreq
    def set_missingFreq(self, missingFreq):
        self.missingFreq = missingFreq
    def get_invalidFreq(self):
        return self.invalidFreq
    def set_invalidFreq(self, invalidFreq):
        self.invalidFreq = invalidFreq
    def get_cardinality(self):
        return self.cardinality
    def set_cardinality(self, cardinality):
        self.cardinality = cardinality
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Counts', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Counts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Counts':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Counts')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Counts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Counts'):
        if self.totalFreq is not None and 'totalFreq' not in already_processed:
            already_processed.add('totalFreq')
            outfile.write(' totalFreq="%s"' % self.gds_format_double(self.totalFreq, input_name='totalFreq'))
        if self.missingFreq is not None and 'missingFreq' not in already_processed:
            already_processed.add('missingFreq')
            outfile.write(' missingFreq="%s"' % self.gds_format_double(self.missingFreq, input_name='missingFreq'))
        if self.invalidFreq is not None and 'invalidFreq' not in already_processed:
            already_processed.add('invalidFreq')
            outfile.write(' invalidFreq="%s"' % self.gds_format_double(self.invalidFreq, input_name='invalidFreq'))
        if self.cardinality is not None and 'cardinality' not in already_processed:
            already_processed.add('cardinality')
            outfile.write(' cardinality="%s"' % self.gds_format_integer(self.cardinality, input_name='cardinality'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Counts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('totalFreq', node)
        if value is not None and 'totalFreq' not in already_processed:
            already_processed.add('totalFreq')
            value = self.gds_parse_double(value, node, 'totalFreq')
            self.totalFreq = value
            self.validate_NUMBER(self.totalFreq)    # validate type NUMBER
        value = find_attr_value_('missingFreq', node)
        if value is not None and 'missingFreq' not in already_processed:
            already_processed.add('missingFreq')
            value = self.gds_parse_double(value, node, 'missingFreq')
            self.missingFreq = value
            self.validate_NUMBER(self.missingFreq)    # validate type NUMBER
        value = find_attr_value_('invalidFreq', node)
        if value is not None and 'invalidFreq' not in already_processed:
            already_processed.add('invalidFreq')
            value = self.gds_parse_double(value, node, 'invalidFreq')
            self.invalidFreq = value
            self.validate_NUMBER(self.invalidFreq)    # validate type NUMBER
        value = find_attr_value_('cardinality', node)
        if value is not None and 'cardinality' not in already_processed:
            already_processed.add('cardinality')
            self.cardinality = self.gds_parse_integer(value, node, 'cardinality')
            if self.cardinality < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Counts


class NumericInfo(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, minimum=None, maximum=None, mean=None, standardDeviation=None, median=None, interQuartileRange=None, Extension=None, Quantile=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.minimum = _cast(float, minimum)
        self.minimum_nsprefix_ = None
        self.maximum = _cast(float, maximum)
        self.maximum_nsprefix_ = None
        self.mean = _cast(float, mean)
        self.mean_nsprefix_ = None
        self.standardDeviation = _cast(float, standardDeviation)
        self.standardDeviation_nsprefix_ = None
        self.median = _cast(float, median)
        self.median_nsprefix_ = None
        self.interQuartileRange = _cast(float, interQuartileRange)
        self.interQuartileRange_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Quantile is None:
            self.Quantile = []
        else:
            self.Quantile = Quantile
        self.Quantile_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumericInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumericInfo.subclass:
            return NumericInfo.subclass(*args_, **kwargs_)
        else:
            return NumericInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Quantile(self):
        return self.Quantile
    def set_Quantile(self, Quantile):
        self.Quantile = Quantile
    def add_Quantile(self, value):
        self.Quantile.append(value)
    def insert_Quantile_at(self, index, value):
        self.Quantile.insert(index, value)
    def replace_Quantile_at(self, index, value):
        self.Quantile[index] = value
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def get_mean(self):
        return self.mean
    def set_mean(self, mean):
        self.mean = mean
    def get_standardDeviation(self):
        return self.standardDeviation
    def set_standardDeviation(self, standardDeviation):
        self.standardDeviation = standardDeviation
    def get_median(self):
        return self.median
    def set_median(self, median):
        self.median = median
    def get_interQuartileRange(self):
        return self.interQuartileRange
    def set_interQuartileRange(self, interQuartileRange):
        self.interQuartileRange = interQuartileRange
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.Quantile
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NumericInfo', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumericInfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NumericInfo':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumericInfo')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NumericInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NumericInfo'):
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_double(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_double(self.maximum, input_name='maximum'))
        if self.mean is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            outfile.write(' mean="%s"' % self.gds_format_double(self.mean, input_name='mean'))
        if self.standardDeviation is not None and 'standardDeviation' not in already_processed:
            already_processed.add('standardDeviation')
            outfile.write(' standardDeviation="%s"' % self.gds_format_double(self.standardDeviation, input_name='standardDeviation'))
        if self.median is not None and 'median' not in already_processed:
            already_processed.add('median')
            outfile.write(' median="%s"' % self.gds_format_double(self.median, input_name='median'))
        if self.interQuartileRange is not None and 'interQuartileRange' not in already_processed:
            already_processed.add('interQuartileRange')
            outfile.write(' interQuartileRange="%s"' % self.gds_format_double(self.interQuartileRange, input_name='interQuartileRange'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NumericInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Quantile_ in self.Quantile:
            namespaceprefix_ = self.Quantile_nsprefix_ + ':' if (UseCapturedNS_ and self.Quantile_nsprefix_) else ''
            Quantile_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Quantile', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            value = self.gds_parse_double(value, node, 'minimum')
            self.minimum = value
            self.validate_NUMBER(self.minimum)    # validate type NUMBER
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            value = self.gds_parse_double(value, node, 'maximum')
            self.maximum = value
            self.validate_NUMBER(self.maximum)    # validate type NUMBER
        value = find_attr_value_('mean', node)
        if value is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            value = self.gds_parse_double(value, node, 'mean')
            self.mean = value
            self.validate_NUMBER(self.mean)    # validate type NUMBER
        value = find_attr_value_('standardDeviation', node)
        if value is not None and 'standardDeviation' not in already_processed:
            already_processed.add('standardDeviation')
            value = self.gds_parse_double(value, node, 'standardDeviation')
            self.standardDeviation = value
            self.validate_NUMBER(self.standardDeviation)    # validate type NUMBER
        value = find_attr_value_('median', node)
        if value is not None and 'median' not in already_processed:
            already_processed.add('median')
            value = self.gds_parse_double(value, node, 'median')
            self.median = value
            self.validate_NUMBER(self.median)    # validate type NUMBER
        value = find_attr_value_('interQuartileRange', node)
        if value is not None and 'interQuartileRange' not in already_processed:
            already_processed.add('interQuartileRange')
            value = self.gds_parse_double(value, node, 'interQuartileRange')
            self.interQuartileRange = value
            self.validate_NUMBER(self.interQuartileRange)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Quantile':
            obj_ = Quantile.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Quantile.append(obj_)
            obj_.original_tagname_ = 'Quantile'
# end class NumericInfo


class Quantile(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, quantileLimit=None, quantileValue=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.quantileLimit = _cast(float, quantileLimit)
        self.quantileLimit_nsprefix_ = None
        self.quantileValue = _cast(float, quantileValue)
        self.quantileValue_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Quantile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Quantile.subclass:
            return Quantile.subclass(*args_, **kwargs_)
        else:
            return Quantile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_quantileLimit(self):
        return self.quantileLimit
    def set_quantileLimit(self, quantileLimit):
        self.quantileLimit = quantileLimit
    def get_quantileValue(self):
        return self.quantileValue
    def set_quantileValue(self, quantileValue):
        self.quantileValue = quantileValue
    def validate_PERCENTAGE_NUMBER(self, value):
        # Validate type PERCENTAGE-NUMBER, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Quantile', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Quantile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Quantile':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Quantile')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Quantile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Quantile'):
        if self.quantileLimit is not None and 'quantileLimit' not in already_processed:
            already_processed.add('quantileLimit')
            outfile.write(' quantileLimit="%s"' % self.gds_format_decimal(self.quantileLimit, input_name='quantileLimit'))
        if self.quantileValue is not None and 'quantileValue' not in already_processed:
            already_processed.add('quantileValue')
            outfile.write(' quantileValue="%s"' % self.gds_format_double(self.quantileValue, input_name='quantileValue'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Quantile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quantileLimit', node)
        if value is not None and 'quantileLimit' not in already_processed:
            already_processed.add('quantileLimit')
            value = self.gds_parse_decimal(value, node, 'quantileLimit')
            self.quantileLimit = value
            self.validate_PERCENTAGE_NUMBER(self.quantileLimit)    # validate type PERCENTAGE-NUMBER
        value = find_attr_value_('quantileValue', node)
        if value is not None and 'quantileValue' not in already_processed:
            already_processed.add('quantileValue')
            value = self.gds_parse_double(value, node, 'quantileValue')
            self.quantileValue = value
            self.validate_NUMBER(self.quantileValue)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Quantile


class DiscrStats(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modalValue=None, Extension=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modalValue = _cast(None, modalValue)
        self.modalValue_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Array is None:
            self.Array = []
        else:
            self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiscrStats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiscrStats.subclass:
            return DiscrStats.subclass(*args_, **kwargs_)
        else:
            return DiscrStats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def add_Array(self, value):
        self.Array.append(value)
    def insert_Array_at(self, index, value):
        self.Array.insert(index, value)
    def replace_Array_at(self, index, value):
        self.Array[index] = value
    def get_modalValue(self):
        return self.modalValue
    def set_modalValue(self, modalValue):
        self.modalValue = modalValue
    def _hasContent(self):
        if (
            self.Extension or
            self.Array
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DiscrStats', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DiscrStats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DiscrStats':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DiscrStats')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DiscrStats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DiscrStats'):
        if self.modalValue is not None and 'modalValue' not in already_processed:
            already_processed.add('modalValue')
            outfile.write(' modalValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modalValue), input_name='modalValue')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DiscrStats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Array_ in self.Array:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            Array_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modalValue', node)
        if value is not None and 'modalValue' not in already_processed:
            already_processed.add('modalValue')
            self.modalValue = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array.append(obj_)
            obj_.original_tagname_ = 'Array'
# end class DiscrStats


class ContStats(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, totalValuesSum=None, totalSquaresSum=None, Extension=None, Interval=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.totalValuesSum = _cast(float, totalValuesSum)
        self.totalValuesSum_nsprefix_ = None
        self.totalSquaresSum = _cast(float, totalSquaresSum)
        self.totalSquaresSum_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
        self.Interval_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContStats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContStats.subclass:
            return ContStats.subclass(*args_, **kwargs_)
        else:
            return ContStats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Interval(self):
        return self.Interval
    def set_Interval(self, Interval):
        self.Interval = Interval
    def add_Interval(self, value):
        self.Interval.append(value)
    def insert_Interval_at(self, index, value):
        self.Interval.insert(index, value)
    def replace_Interval_at(self, index, value):
        self.Interval[index] = value
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def get_totalValuesSum(self):
        return self.totalValuesSum
    def set_totalValuesSum(self, totalValuesSum):
        self.totalValuesSum = totalValuesSum
    def get_totalSquaresSum(self):
        return self.totalSquaresSum
    def set_totalSquaresSum(self, totalSquaresSum):
        self.totalSquaresSum = totalSquaresSum
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.Interval or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ContStats', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContStats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ContStats':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContStats')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ContStats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContStats'):
        if self.totalValuesSum is not None and 'totalValuesSum' not in already_processed:
            already_processed.add('totalValuesSum')
            outfile.write(' totalValuesSum="%s"' % self.gds_format_double(self.totalValuesSum, input_name='totalValuesSum'))
        if self.totalSquaresSum is not None and 'totalSquaresSum' not in already_processed:
            already_processed.add('totalSquaresSum')
            outfile.write(' totalSquaresSum="%s"' % self.gds_format_double(self.totalSquaresSum, input_name='totalSquaresSum'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ContStats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Interval_ in self.Interval:
            namespaceprefix_ = self.Interval_nsprefix_ + ':' if (UseCapturedNS_ and self.Interval_nsprefix_) else ''
            Interval_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Interval', pretty_print=pretty_print)
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('totalValuesSum', node)
        if value is not None and 'totalValuesSum' not in already_processed:
            already_processed.add('totalValuesSum')
            value = self.gds_parse_double(value, node, 'totalValuesSum')
            self.totalValuesSum = value
            self.validate_NUMBER(self.totalValuesSum)    # validate type NUMBER
        value = find_attr_value_('totalSquaresSum', node)
        if value is not None and 'totalSquaresSum' not in already_processed:
            already_processed.add('totalSquaresSum')
            value = self.gds_parse_double(value, node, 'totalSquaresSum')
            self.totalSquaresSum = value
            self.validate_NUMBER(self.totalSquaresSum)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Interval':
            obj_ = Interval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Interval.append(obj_)
            obj_.original_tagname_ = 'Interval'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class ContStats


class Anova(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, target=None, Extension=None, AnovaRow=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.target = _cast(None, target)
        self.target_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if AnovaRow is None:
            self.AnovaRow = []
        else:
            self.AnovaRow = AnovaRow
        self.AnovaRow_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Anova)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Anova.subclass:
            return Anova.subclass(*args_, **kwargs_)
        else:
            return Anova(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_AnovaRow(self):
        return self.AnovaRow
    def set_AnovaRow(self, AnovaRow):
        self.AnovaRow = AnovaRow
    def add_AnovaRow(self, value):
        self.AnovaRow.append(value)
    def insert_AnovaRow_at(self, index, value):
        self.AnovaRow.insert(index, value)
    def replace_AnovaRow_at(self, index, value):
        self.AnovaRow[index] = value
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.AnovaRow
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Anova', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Anova')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Anova':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Anova')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Anova', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Anova'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target), input_name='target')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Anova', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for AnovaRow_ in self.AnovaRow:
            namespaceprefix_ = self.AnovaRow_nsprefix_ + ':' if (UseCapturedNS_ and self.AnovaRow_nsprefix_) else ''
            AnovaRow_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AnovaRow', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
            self.validate_FIELD_NAME(self.target)    # validate type FIELD-NAME
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'AnovaRow':
            obj_ = AnovaRow.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AnovaRow.append(obj_)
            obj_.original_tagname_ = 'AnovaRow'
# end class Anova


class AnovaRow(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, sumOfSquares=None, degreesOfFreedom=None, meanOfSquares=None, fValue=None, pValue=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.sumOfSquares = _cast(float, sumOfSquares)
        self.sumOfSquares_nsprefix_ = None
        self.degreesOfFreedom = _cast(float, degreesOfFreedom)
        self.degreesOfFreedom_nsprefix_ = None
        self.meanOfSquares = _cast(float, meanOfSquares)
        self.meanOfSquares_nsprefix_ = None
        self.fValue = _cast(float, fValue)
        self.fValue_nsprefix_ = None
        self.pValue = _cast(float, pValue)
        self.pValue_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AnovaRow)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AnovaRow.subclass:
            return AnovaRow.subclass(*args_, **kwargs_)
        else:
            return AnovaRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_sumOfSquares(self):
        return self.sumOfSquares
    def set_sumOfSquares(self, sumOfSquares):
        self.sumOfSquares = sumOfSquares
    def get_degreesOfFreedom(self):
        return self.degreesOfFreedom
    def set_degreesOfFreedom(self, degreesOfFreedom):
        self.degreesOfFreedom = degreesOfFreedom
    def get_meanOfSquares(self):
        return self.meanOfSquares
    def set_meanOfSquares(self, meanOfSquares):
        self.meanOfSquares = meanOfSquares
    def get_fValue(self):
        return self.fValue
    def set_fValue(self, fValue):
        self.fValue = fValue
    def get_pValue(self):
        return self.pValue
    def set_pValue(self, pValue):
        self.pValue = pValue
    def validate_typeType1(self, value):
        # Validate type typeType1, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Model', 'Error', 'Total']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType1' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='AnovaRow', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AnovaRow')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AnovaRow':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AnovaRow')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AnovaRow', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AnovaRow'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.sumOfSquares is not None and 'sumOfSquares' not in already_processed:
            already_processed.add('sumOfSquares')
            outfile.write(' sumOfSquares="%s"' % self.gds_format_double(self.sumOfSquares, input_name='sumOfSquares'))
        if self.degreesOfFreedom is not None and 'degreesOfFreedom' not in already_processed:
            already_processed.add('degreesOfFreedom')
            outfile.write(' degreesOfFreedom="%s"' % self.gds_format_double(self.degreesOfFreedom, input_name='degreesOfFreedom'))
        if self.meanOfSquares is not None and 'meanOfSquares' not in already_processed:
            already_processed.add('meanOfSquares')
            outfile.write(' meanOfSquares="%s"' % self.gds_format_double(self.meanOfSquares, input_name='meanOfSquares'))
        if self.fValue is not None and 'fValue' not in already_processed:
            already_processed.add('fValue')
            outfile.write(' fValue="%s"' % self.gds_format_double(self.fValue, input_name='fValue'))
        if self.pValue is not None and 'pValue' not in already_processed:
            already_processed.add('pValue')
            outfile.write(' pValue="%s"' % self.gds_format_decimal(self.pValue, input_name='pValue'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='AnovaRow', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType1(self.type_)    # validate type typeType1
        value = find_attr_value_('sumOfSquares', node)
        if value is not None and 'sumOfSquares' not in already_processed:
            already_processed.add('sumOfSquares')
            value = self.gds_parse_double(value, node, 'sumOfSquares')
            self.sumOfSquares = value
            self.validate_NUMBER(self.sumOfSquares)    # validate type NUMBER
        value = find_attr_value_('degreesOfFreedom', node)
        if value is not None and 'degreesOfFreedom' not in already_processed:
            already_processed.add('degreesOfFreedom')
            value = self.gds_parse_double(value, node, 'degreesOfFreedom')
            self.degreesOfFreedom = value
            self.validate_NUMBER(self.degreesOfFreedom)    # validate type NUMBER
        value = find_attr_value_('meanOfSquares', node)
        if value is not None and 'meanOfSquares' not in already_processed:
            already_processed.add('meanOfSquares')
            value = self.gds_parse_double(value, node, 'meanOfSquares')
            self.meanOfSquares = value
            self.validate_NUMBER(self.meanOfSquares)    # validate type NUMBER
        value = find_attr_value_('fValue', node)
        if value is not None and 'fValue' not in already_processed:
            already_processed.add('fValue')
            value = self.gds_parse_double(value, node, 'fValue')
            self.fValue = value
            self.validate_NUMBER(self.fValue)    # validate type NUMBER
        value = find_attr_value_('pValue', node)
        if value is not None and 'pValue' not in already_processed:
            already_processed.add('pValue')
            value = self.gds_parse_decimal(value, node, 'pValue')
            self.pValue = value
            self.validate_PROB_NUMBER(self.pValue)    # validate type PROB-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class AnovaRow


class Partition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, size=None, Extension=None, PartitionFieldStats=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.size = _cast(float, size)
        self.size_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if PartitionFieldStats is None:
            self.PartitionFieldStats = []
        else:
            self.PartitionFieldStats = PartitionFieldStats
        self.PartitionFieldStats_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Partition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Partition.subclass:
            return Partition.subclass(*args_, **kwargs_)
        else:
            return Partition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_PartitionFieldStats(self):
        return self.PartitionFieldStats
    def set_PartitionFieldStats(self, PartitionFieldStats):
        self.PartitionFieldStats = PartitionFieldStats
    def add_PartitionFieldStats(self, value):
        self.PartitionFieldStats.append(value)
    def insert_PartitionFieldStats_at(self, index, value):
        self.PartitionFieldStats.insert(index, value)
    def replace_PartitionFieldStats_at(self, index, value):
        self.PartitionFieldStats[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.PartitionFieldStats
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Partition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Partition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Partition':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Partition')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Partition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Partition'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_double(self.size, input_name='size'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Partition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for PartitionFieldStats_ in self.PartitionFieldStats:
            namespaceprefix_ = self.PartitionFieldStats_nsprefix_ + ':' if (UseCapturedNS_ and self.PartitionFieldStats_nsprefix_) else ''
            PartitionFieldStats_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PartitionFieldStats', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            value = self.gds_parse_double(value, node, 'size')
            self.size = value
            self.validate_NUMBER(self.size)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'PartitionFieldStats':
            obj_ = PartitionFieldStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PartitionFieldStats.append(obj_)
            obj_.original_tagname_ = 'PartitionFieldStats'
# end class Partition


class PartitionFieldStats(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, field=None, weighted='0', Extension=None, Counts=None, NumericInfo=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        self.weighted = _cast(None, weighted)
        self.weighted_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Counts = Counts
        self.Counts_nsprefix_ = None
        self.NumericInfo = NumericInfo
        self.NumericInfo_nsprefix_ = None
        if Array is None:
            self.Array = []
        else:
            self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartitionFieldStats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartitionFieldStats.subclass:
            return PartitionFieldStats.subclass(*args_, **kwargs_)
        else:
            return PartitionFieldStats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Counts(self):
        return self.Counts
    def set_Counts(self, Counts):
        self.Counts = Counts
    def get_NumericInfo(self):
        return self.NumericInfo
    def set_NumericInfo(self, NumericInfo):
        self.NumericInfo = NumericInfo
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def add_Array(self, value):
        self.Array.append(value)
    def insert_Array_at(self, index, value):
        self.Array.insert(index, value)
    def replace_Array_at(self, index, value):
        self.Array[index] = value
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_weighted(self):
        return self.weighted
    def set_weighted(self, weighted):
        self.weighted = weighted
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_weightedType2(self, value):
        # Validate type weightedType2, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['0', '1']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on weightedType2' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.Counts is not None or
            self.NumericInfo is not None or
            self.Array
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PartitionFieldStats', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PartitionFieldStats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PartitionFieldStats':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PartitionFieldStats')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PartitionFieldStats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PartitionFieldStats'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.weighted != "0" and 'weighted' not in already_processed:
            already_processed.add('weighted')
            outfile.write(' weighted=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.weighted), input_name='weighted')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PartitionFieldStats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Counts is not None:
            namespaceprefix_ = self.Counts_nsprefix_ + ':' if (UseCapturedNS_ and self.Counts_nsprefix_) else ''
            self.Counts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Counts', pretty_print=pretty_print)
        if self.NumericInfo is not None:
            namespaceprefix_ = self.NumericInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.NumericInfo_nsprefix_) else ''
            self.NumericInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NumericInfo', pretty_print=pretty_print)
        for Array_ in self.Array:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            Array_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('weighted', node)
        if value is not None and 'weighted' not in already_processed:
            already_processed.add('weighted')
            self.weighted = value
            self.validate_weightedType2(self.weighted)    # validate type weightedType2
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Counts':
            obj_ = Counts.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Counts = obj_
            obj_.original_tagname_ = 'Counts'
        elif nodeName_ == 'NumericInfo':
            obj_ = NumericInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NumericInfo = obj_
            obj_.original_tagname_ = 'NumericInfo'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array.append(obj_)
            obj_.original_tagname_ = 'Array'
# end class PartitionFieldStats


class Output(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, OutputField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if OutputField is None:
            self.OutputField = []
        else:
            self.OutputField = OutputField
        self.OutputField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Output)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Output.subclass:
            return Output.subclass(*args_, **kwargs_)
        else:
            return Output(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_OutputField(self):
        return self.OutputField
    def set_OutputField(self, OutputField):
        self.OutputField = OutputField
    def add_OutputField(self, value):
        self.OutputField.append(value)
    def insert_OutputField_at(self, index, value):
        self.OutputField.insert(index, value)
    def replace_OutputField_at(self, index, value):
        self.OutputField[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.OutputField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Output', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Output')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Output':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Output')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Output', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Output'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Output', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for OutputField_ in self.OutputField:
            namespaceprefix_ = self.OutputField_nsprefix_ + ':' if (UseCapturedNS_ and self.OutputField_nsprefix_) else ''
            OutputField_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OutputField', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'OutputField':
            obj_ = OutputField.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OutputField.append(obj_)
            obj_.original_tagname_ = 'OutputField'
# end class Output


class OutputField(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, optype=None, dataType=None, targetField=None, feature=None, value=None, ruleFeature='consequent', algorithm='exclusiveRecommendation', rank='1', rankBasis='confidence', rankOrder='descending', isMultiValued='0', Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.optype = _cast(None, optype)
        self.optype_nsprefix_ = None
        self.dataType = _cast(None, dataType)
        self.dataType_nsprefix_ = None
        self.targetField = _cast(None, targetField)
        self.targetField_nsprefix_ = None
        self.feature = _cast(None, feature)
        self.feature_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.ruleFeature = _cast(None, ruleFeature)
        self.ruleFeature_nsprefix_ = None
        self.algorithm = _cast(None, algorithm)
        self.algorithm_nsprefix_ = None
        self.rank = _cast(int, rank)
        self.rank_nsprefix_ = None
        self.rankBasis = _cast(None, rankBasis)
        self.rankBasis_nsprefix_ = None
        self.rankOrder = _cast(None, rankOrder)
        self.rankOrder_nsprefix_ = None
        self.isMultiValued = _cast(None, isMultiValued)
        self.isMultiValued_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutputField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutputField.subclass:
            return OutputField.subclass(*args_, **kwargs_)
        else:
            return OutputField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_optype(self):
        return self.optype
    def set_optype(self, optype):
        self.optype = optype
    def get_dataType(self):
        return self.dataType
    def set_dataType(self, dataType):
        self.dataType = dataType
    def get_targetField(self):
        return self.targetField
    def set_targetField(self, targetField):
        self.targetField = targetField
    def get_feature(self):
        return self.feature
    def set_feature(self, feature):
        self.feature = feature
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_ruleFeature(self):
        return self.ruleFeature
    def set_ruleFeature(self, ruleFeature):
        self.ruleFeature = ruleFeature
    def get_algorithm(self):
        return self.algorithm
    def set_algorithm(self, algorithm):
        self.algorithm = algorithm
    def get_rank(self):
        return self.rank
    def set_rank(self, rank):
        self.rank = rank
    def get_rankBasis(self):
        return self.rankBasis
    def set_rankBasis(self, rankBasis):
        self.rankBasis = rankBasis
    def get_rankOrder(self):
        return self.rankOrder
    def set_rankOrder(self, rankOrder):
        self.rankOrder = rankOrder
    def get_isMultiValued(self):
        return self.isMultiValued
    def set_isMultiValued(self, isMultiValued):
        self.isMultiValued = isMultiValued
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['categorical', 'ordinal', 'continuous']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OPTYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DATATYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_RESULT_FEATURE(self, value):
        # Validate type RESULT-FEATURE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['predictedValue', 'predictedDisplayValue', 'probability', 'residual', 'standardError', 'clusterId', 'clusterAffinity', 'entityId', 'entityAffinity', 'warning', 'ruleValue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RESULT-FEATURE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_RULE_FEATURE(self, value):
        # Validate type RULE-FEATURE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['antecedent', 'consequent', 'rule', 'ruleId', 'confidence', 'support', 'lift']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RULE-FEATURE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_algorithmType(self, value):
        # Validate type algorithmType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['recommendation', 'exclusiveRecommendation', 'ruleAssociation']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on algorithmType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_rankBasisType(self, value):
        # Validate type rankBasisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['confidence', 'support', 'lift']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on rankBasisType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_rankOrderType(self, value):
        # Validate type rankOrderType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['descending', 'ascending']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on rankOrderType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='OutputField', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OutputField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OutputField':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OutputField')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OutputField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OutputField'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.optype), input_name='optype')), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataType), input_name='dataType')), ))
        if self.targetField is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            outfile.write(' targetField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetField), input_name='targetField')), ))
        if self.feature is not None and 'feature' not in already_processed:
            already_processed.add('feature')
            outfile.write(' feature=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.feature), input_name='feature')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.ruleFeature != "consequent" and 'ruleFeature' not in already_processed:
            already_processed.add('ruleFeature')
            outfile.write(' ruleFeature=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ruleFeature), input_name='ruleFeature')), ))
        if self.algorithm != "exclusiveRecommendation" and 'algorithm' not in already_processed:
            already_processed.add('algorithm')
            outfile.write(' algorithm=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithm), input_name='algorithm')), ))
        if self.rank != 1 and 'rank' not in already_processed:
            already_processed.add('rank')
            outfile.write(' rank="%s"' % self.gds_format_integer(self.rank, input_name='rank'))
        if self.rankBasis != "confidence" and 'rankBasis' not in already_processed:
            already_processed.add('rankBasis')
            outfile.write(' rankBasis=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rankBasis), input_name='rankBasis')), ))
        if self.rankOrder != "descending" and 'rankOrder' not in already_processed:
            already_processed.add('rankOrder')
            outfile.write(' rankOrder=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rankOrder), input_name='rankOrder')), ))
        if self.isMultiValued != "0" and 'isMultiValued' not in already_processed:
            already_processed.add('isMultiValued')
            outfile.write(' isMultiValued=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.isMultiValued), input_name='isMultiValued')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='OutputField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
        value = find_attr_value_('targetField', node)
        if value is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            self.targetField = value
            self.validate_FIELD_NAME(self.targetField)    # validate type FIELD-NAME
        value = find_attr_value_('feature', node)
        if value is not None and 'feature' not in already_processed:
            already_processed.add('feature')
            self.feature = value
            self.validate_RESULT_FEATURE(self.feature)    # validate type RESULT-FEATURE
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('ruleFeature', node)
        if value is not None and 'ruleFeature' not in already_processed:
            already_processed.add('ruleFeature')
            self.ruleFeature = value
            self.validate_RULE_FEATURE(self.ruleFeature)    # validate type RULE-FEATURE
        value = find_attr_value_('algorithm', node)
        if value is not None and 'algorithm' not in already_processed:
            already_processed.add('algorithm')
            self.algorithm = value
            self.validate_algorithmType(self.algorithm)    # validate type algorithmType
        value = find_attr_value_('rank', node)
        if value is not None and 'rank' not in already_processed:
            already_processed.add('rank')
            self.rank = self.gds_parse_integer(value, node, 'rank')
            self.validate_INT_NUMBER(self.rank)    # validate type INT-NUMBER
        value = find_attr_value_('rankBasis', node)
        if value is not None and 'rankBasis' not in already_processed:
            already_processed.add('rankBasis')
            self.rankBasis = value
            self.validate_rankBasisType(self.rankBasis)    # validate type rankBasisType
        value = find_attr_value_('rankOrder', node)
        if value is not None and 'rankOrder' not in already_processed:
            already_processed.add('rankOrder')
            self.rankOrder = value
            self.validate_rankOrderType(self.rankOrder)    # validate type rankOrderType
        value = find_attr_value_('isMultiValued', node)
        if value is not None and 'isMultiValued' not in already_processed:
            already_processed.add('isMultiValued')
            self.isMultiValued = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class OutputField


class Targets(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Target=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Target is None:
            self.Target = []
        else:
            self.Target = Target
        self.Target_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Targets)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Targets.subclass:
            return Targets.subclass(*args_, **kwargs_)
        else:
            return Targets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Target(self):
        return self.Target
    def set_Target(self, Target):
        self.Target = Target
    def add_Target(self, value):
        self.Target.append(value)
    def insert_Target_at(self, index, value):
        self.Target.insert(index, value)
    def replace_Target_at(self, index, value):
        self.Target[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.Target
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Targets', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Targets')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Targets':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Targets')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Targets', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Targets'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Targets', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Target_ in self.Target:
            namespaceprefix_ = self.Target_nsprefix_ + ':' if (UseCapturedNS_ and self.Target_nsprefix_) else ''
            Target_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Target', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Target':
            obj_ = Target.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Target.append(obj_)
            obj_.original_tagname_ = 'Target'
# end class Targets


class Target(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, field=None, optype=None, castInteger=None, min=None, max=None, rescaleConstant=0, rescaleFactor=1, Extension=None, TargetValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        self.optype = _cast(None, optype)
        self.optype_nsprefix_ = None
        self.castInteger = _cast(None, castInteger)
        self.castInteger_nsprefix_ = None
        self.min = _cast(float, min)
        self.min_nsprefix_ = None
        self.max = _cast(float, max)
        self.max_nsprefix_ = None
        self.rescaleConstant = _cast(float, rescaleConstant)
        self.rescaleConstant_nsprefix_ = None
        self.rescaleFactor = _cast(float, rescaleFactor)
        self.rescaleFactor_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if TargetValue is None:
            self.TargetValue = []
        else:
            self.TargetValue = TargetValue
        self.TargetValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Target)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Target.subclass:
            return Target.subclass(*args_, **kwargs_)
        else:
            return Target(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_TargetValue(self):
        return self.TargetValue
    def set_TargetValue(self, TargetValue):
        self.TargetValue = TargetValue
    def add_TargetValue(self, value):
        self.TargetValue.append(value)
    def insert_TargetValue_at(self, index, value):
        self.TargetValue.insert(index, value)
    def replace_TargetValue_at(self, index, value):
        self.TargetValue[index] = value
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_optype(self):
        return self.optype
    def set_optype(self, optype):
        self.optype = optype
    def get_castInteger(self):
        return self.castInteger
    def set_castInteger(self, castInteger):
        self.castInteger = castInteger
    def get_min(self):
        return self.min
    def set_min(self, min):
        self.min = min
    def get_max(self):
        return self.max
    def set_max(self, max):
        self.max = max
    def get_rescaleConstant(self):
        return self.rescaleConstant
    def set_rescaleConstant(self, rescaleConstant):
        self.rescaleConstant = rescaleConstant
    def get_rescaleFactor(self):
        return self.rescaleFactor
    def set_rescaleFactor(self, rescaleFactor):
        self.rescaleFactor = rescaleFactor
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['categorical', 'ordinal', 'continuous']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OPTYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_castIntegerType(self, value):
        # Validate type castIntegerType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['round', 'ceiling', 'floor']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on castIntegerType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.TargetValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Target', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Target')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Target':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Target')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Target', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Target'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.optype), input_name='optype')), ))
        if self.castInteger is not None and 'castInteger' not in already_processed:
            already_processed.add('castInteger')
            outfile.write(' castInteger=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.castInteger), input_name='castInteger')), ))
        if self.min is not None and 'min' not in already_processed:
            already_processed.add('min')
            outfile.write(' min="%s"' % self.gds_format_double(self.min, input_name='min'))
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max="%s"' % self.gds_format_double(self.max, input_name='max'))
        if self.rescaleConstant != 0 and 'rescaleConstant' not in already_processed:
            already_processed.add('rescaleConstant')
            outfile.write(' rescaleConstant="%s"' % self.gds_format_double(self.rescaleConstant, input_name='rescaleConstant'))
        if self.rescaleFactor != 1 and 'rescaleFactor' not in already_processed:
            already_processed.add('rescaleFactor')
            outfile.write(' rescaleFactor="%s"' % self.gds_format_double(self.rescaleFactor, input_name='rescaleFactor'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Target', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for TargetValue_ in self.TargetValue:
            namespaceprefix_ = self.TargetValue_nsprefix_ + ':' if (UseCapturedNS_ and self.TargetValue_nsprefix_) else ''
            TargetValue_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TargetValue', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('castInteger', node)
        if value is not None and 'castInteger' not in already_processed:
            already_processed.add('castInteger')
            self.castInteger = value
            self.validate_castIntegerType(self.castInteger)    # validate type castIntegerType
        value = find_attr_value_('min', node)
        if value is not None and 'min' not in already_processed:
            already_processed.add('min')
            value = self.gds_parse_double(value, node, 'min')
            self.min = value
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            value = self.gds_parse_double(value, node, 'max')
            self.max = value
        value = find_attr_value_('rescaleConstant', node)
        if value is not None and 'rescaleConstant' not in already_processed:
            already_processed.add('rescaleConstant')
            value = self.gds_parse_double(value, node, 'rescaleConstant')
            self.rescaleConstant = value
        value = find_attr_value_('rescaleFactor', node)
        if value is not None and 'rescaleFactor' not in already_processed:
            already_processed.add('rescaleFactor')
            value = self.gds_parse_double(value, node, 'rescaleFactor')
            self.rescaleFactor = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TargetValue':
            obj_ = TargetValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TargetValue.append(obj_)
            obj_.original_tagname_ = 'TargetValue'
# end class Target


class TargetValue(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value=None, displayValue=None, priorProbability=None, defaultValue=None, Extension=None, Partition=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.displayValue = _cast(None, displayValue)
        self.displayValue_nsprefix_ = None
        self.priorProbability = _cast(float, priorProbability)
        self.priorProbability_nsprefix_ = None
        self.defaultValue = _cast(float, defaultValue)
        self.defaultValue_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Partition = Partition
        self.Partition_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetValue.subclass:
            return TargetValue.subclass(*args_, **kwargs_)
        else:
            return TargetValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Partition(self):
        return self.Partition
    def set_Partition(self, Partition):
        self.Partition = Partition
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_displayValue(self):
        return self.displayValue
    def set_displayValue(self, displayValue):
        self.displayValue = displayValue
    def get_priorProbability(self):
        return self.priorProbability
    def set_priorProbability(self, priorProbability):
        self.priorProbability = priorProbability
    def get_defaultValue(self):
        return self.defaultValue
    def set_defaultValue(self, defaultValue):
        self.defaultValue = defaultValue
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.Partition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TargetValue', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TargetValue':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TargetValue')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TargetValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TargetValue'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.displayValue is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            outfile.write(' displayValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayValue), input_name='displayValue')), ))
        if self.priorProbability is not None and 'priorProbability' not in already_processed:
            already_processed.add('priorProbability')
            outfile.write(' priorProbability="%s"' % self.gds_format_decimal(self.priorProbability, input_name='priorProbability'))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            outfile.write(' defaultValue="%s"' % self.gds_format_double(self.defaultValue, input_name='defaultValue'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TargetValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Partition is not None:
            namespaceprefix_ = self.Partition_nsprefix_ + ':' if (UseCapturedNS_ and self.Partition_nsprefix_) else ''
            self.Partition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Partition', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('displayValue', node)
        if value is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            self.displayValue = value
        value = find_attr_value_('priorProbability', node)
        if value is not None and 'priorProbability' not in already_processed:
            already_processed.add('priorProbability')
            value = self.gds_parse_decimal(value, node, 'priorProbability')
            self.priorProbability = value
            self.validate_PROB_NUMBER(self.priorProbability)    # validate type PROB-NUMBER
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.add('defaultValue')
            value = self.gds_parse_double(value, node, 'defaultValue')
            self.defaultValue = value
            self.validate_NUMBER(self.defaultValue)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Partition':
            obj_ = Partition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Partition = obj_
            obj_.original_tagname_ = 'Partition'
# end class TargetValue


class NeuralNetwork(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, activationFunction=None, normalizationMethod='none', threshold='0', width=None, altitude='1.0', numberOfLayers=None, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, NeuralInputs=None, NeuralLayer=None, NeuralOutputs=None, ModelVerification=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.activationFunction = _cast(None, activationFunction)
        self.activationFunction_nsprefix_ = None
        self.normalizationMethod = _cast(None, normalizationMethod)
        self.normalizationMethod_nsprefix_ = None
        self.threshold = _cast(float, threshold)
        self.threshold_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.altitude = _cast(float, altitude)
        self.altitude_nsprefix_ = None
        self.numberOfLayers = _cast(int, numberOfLayers)
        self.numberOfLayers_nsprefix_ = None
        self.MiningSchema = MiningSchema
        self.MiningSchema_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.ModelExplanation = ModelExplanation
        self.ModelExplanation_nsprefix_ = None
        self.Targets = Targets
        self.Targets_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        self.NeuralInputs = NeuralInputs
        self.NeuralInputs_nsprefix_ = None
        if NeuralLayer is None:
            self.NeuralLayer = []
        else:
            self.NeuralLayer = NeuralLayer
        self.NeuralLayer_nsprefix_ = None
        self.NeuralOutputs = NeuralOutputs
        self.NeuralOutputs_nsprefix_ = None
        self.ModelVerification = ModelVerification
        self.ModelVerification_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeuralNetwork)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuralNetwork.subclass:
            return NeuralNetwork.subclass(*args_, **kwargs_)
        else:
            return NeuralNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MiningSchema(self):
        return self.MiningSchema
    def set_MiningSchema(self, MiningSchema):
        self.MiningSchema = MiningSchema
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_ModelExplanation(self):
        return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation):
        self.ModelExplanation = ModelExplanation
    def get_Targets(self):
        return self.Targets
    def set_Targets(self, Targets):
        self.Targets = Targets
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_NeuralInputs(self):
        return self.NeuralInputs
    def set_NeuralInputs(self, NeuralInputs):
        self.NeuralInputs = NeuralInputs
    def get_NeuralLayer(self):
        return self.NeuralLayer
    def set_NeuralLayer(self, NeuralLayer):
        self.NeuralLayer = NeuralLayer
    def add_NeuralLayer(self, value):
        self.NeuralLayer.append(value)
    def insert_NeuralLayer_at(self, index, value):
        self.NeuralLayer.insert(index, value)
    def replace_NeuralLayer_at(self, index, value):
        self.NeuralLayer[index] = value
    def get_NeuralOutputs(self):
        return self.NeuralOutputs
    def set_NeuralOutputs(self, NeuralOutputs):
        self.NeuralOutputs = NeuralOutputs
    def get_ModelVerification(self):
        return self.ModelVerification
    def set_ModelVerification(self, ModelVerification):
        self.ModelVerification = ModelVerification
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def get_activationFunction(self):
        return self.activationFunction
    def set_activationFunction(self, activationFunction):
        self.activationFunction = activationFunction
    def get_normalizationMethod(self):
        return self.normalizationMethod
    def set_normalizationMethod(self, normalizationMethod):
        self.normalizationMethod = normalizationMethod
    def get_threshold(self):
        return self.threshold
    def set_threshold(self, threshold):
        self.threshold = threshold
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_altitude(self):
        return self.altitude
    def set_altitude(self, altitude):
        self.altitude = altitude
    def get_numberOfLayers(self):
        return self.numberOfLayers
    def set_numberOfLayers(self, numberOfLayers):
        self.numberOfLayers = numberOfLayers
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ACTIVATION_FUNCTION(self, value):
        # Validate type ACTIVATION-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['threshold', 'logistic', 'tanh', 'identity', 'exponential', 'reciprocal', 'square', 'Gauss', 'sine', 'cosine', 'Elliott', 'arctan', 'radialBasis']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ACTIVATION-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NN_NORMALIZATION_METHOD(self, value):
        # Validate type NN-NORMALIZATION-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'simplemax', 'softmax']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NN-NORMALIZATION-METHOD' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.NeuralInputs is not None or
            self.NeuralLayer or
            self.NeuralOutputs is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NeuralNetwork', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeuralNetwork')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NeuralNetwork':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NeuralNetwork')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NeuralNetwork', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NeuralNetwork'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.activationFunction is not None and 'activationFunction' not in already_processed:
            already_processed.add('activationFunction')
            outfile.write(' activationFunction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.activationFunction), input_name='activationFunction')), ))
        if self.normalizationMethod != "none" and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            outfile.write(' normalizationMethod=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.normalizationMethod), input_name='normalizationMethod')), ))
        if self.threshold != 0 and 'threshold' not in already_processed:
            already_processed.add('threshold')
            outfile.write(' threshold="%s"' % self.gds_format_double(self.threshold, input_name='threshold'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.altitude != 1.0 and 'altitude' not in already_processed:
            already_processed.add('altitude')
            outfile.write(' altitude="%s"' % self.gds_format_double(self.altitude, input_name='altitude'))
        if self.numberOfLayers is not None and 'numberOfLayers' not in already_processed:
            already_processed.add('numberOfLayers')
            outfile.write(' numberOfLayers="%s"' % self.gds_format_integer(self.numberOfLayers, input_name='numberOfLayers'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NeuralNetwork', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            namespaceprefix_ = self.MiningSchema_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningSchema_nsprefix_) else ''
            self.MiningSchema.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            namespaceprefix_ = self.ModelExplanation_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelExplanation_nsprefix_) else ''
            self.ModelExplanation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            namespaceprefix_ = self.Targets_nsprefix_ + ':' if (UseCapturedNS_ and self.Targets_nsprefix_) else ''
            self.Targets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        if self.NeuralInputs is not None:
            namespaceprefix_ = self.NeuralInputs_nsprefix_ + ':' if (UseCapturedNS_ and self.NeuralInputs_nsprefix_) else ''
            self.NeuralInputs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NeuralInputs', pretty_print=pretty_print)
        for NeuralLayer_ in self.NeuralLayer:
            namespaceprefix_ = self.NeuralLayer_nsprefix_ + ':' if (UseCapturedNS_ and self.NeuralLayer_nsprefix_) else ''
            NeuralLayer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NeuralLayer', pretty_print=pretty_print)
        if self.NeuralOutputs is not None:
            namespaceprefix_ = self.NeuralOutputs_nsprefix_ + ':' if (UseCapturedNS_ and self.NeuralOutputs_nsprefix_) else ''
            self.NeuralOutputs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NeuralOutputs', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            namespaceprefix_ = self.ModelVerification_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelVerification_nsprefix_) else ''
            self.ModelVerification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('activationFunction', node)
        if value is not None and 'activationFunction' not in already_processed:
            already_processed.add('activationFunction')
            self.activationFunction = value
            self.validate_ACTIVATION_FUNCTION(self.activationFunction)    # validate type ACTIVATION-FUNCTION
        value = find_attr_value_('normalizationMethod', node)
        if value is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            self.normalizationMethod = value
            self.validate_NN_NORMALIZATION_METHOD(self.normalizationMethod)    # validate type NN-NORMALIZATION-METHOD
        value = find_attr_value_('threshold', node)
        if value is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            value = self.gds_parse_double(value, node, 'threshold')
            self.threshold = value
            self.validate_REAL_NUMBER(self.threshold)    # validate type REAL-NUMBER
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
            self.validate_REAL_NUMBER(self.width)    # validate type REAL-NUMBER
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            value = self.gds_parse_double(value, node, 'altitude')
            self.altitude = value
            self.validate_REAL_NUMBER(self.altitude)    # validate type REAL-NUMBER
        value = find_attr_value_('numberOfLayers', node)
        if value is not None and 'numberOfLayers' not in already_processed:
            already_processed.add('numberOfLayers')
            self.numberOfLayers = self.gds_parse_integer(value, node, 'numberOfLayers')
            if self.numberOfLayers < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'NeuralInputs':
            obj_ = NeuralInputs.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NeuralInputs = obj_
            obj_.original_tagname_ = 'NeuralInputs'
        elif nodeName_ == 'NeuralLayer':
            obj_ = NeuralLayer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NeuralLayer.append(obj_)
            obj_.original_tagname_ = 'NeuralLayer'
        elif nodeName_ == 'NeuralOutputs':
            obj_ = NeuralOutputs.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NeuralOutputs = obj_
            obj_.original_tagname_ = 'NeuralOutputs'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class NeuralNetwork


class NeuralInputs(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, numberOfInputs=None, Extension=None, NeuralInput=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numberOfInputs = _cast(int, numberOfInputs)
        self.numberOfInputs_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if NeuralInput is None:
            self.NeuralInput = []
        else:
            self.NeuralInput = NeuralInput
        self.NeuralInput_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeuralInputs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuralInputs.subclass:
            return NeuralInputs.subclass(*args_, **kwargs_)
        else:
            return NeuralInputs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_NeuralInput(self):
        return self.NeuralInput
    def set_NeuralInput(self, NeuralInput):
        self.NeuralInput = NeuralInput
    def add_NeuralInput(self, value):
        self.NeuralInput.append(value)
    def insert_NeuralInput_at(self, index, value):
        self.NeuralInput.insert(index, value)
    def replace_NeuralInput_at(self, index, value):
        self.NeuralInput[index] = value
    def get_numberOfInputs(self):
        return self.numberOfInputs
    def set_numberOfInputs(self, numberOfInputs):
        self.numberOfInputs = numberOfInputs
    def _hasContent(self):
        if (
            self.Extension or
            self.NeuralInput
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NeuralInputs', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeuralInputs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NeuralInputs':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NeuralInputs')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NeuralInputs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NeuralInputs'):
        if self.numberOfInputs is not None and 'numberOfInputs' not in already_processed:
            already_processed.add('numberOfInputs')
            outfile.write(' numberOfInputs="%s"' % self.gds_format_integer(self.numberOfInputs, input_name='numberOfInputs'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NeuralInputs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for NeuralInput_ in self.NeuralInput:
            namespaceprefix_ = self.NeuralInput_nsprefix_ + ':' if (UseCapturedNS_ and self.NeuralInput_nsprefix_) else ''
            NeuralInput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NeuralInput', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfInputs', node)
        if value is not None and 'numberOfInputs' not in already_processed:
            already_processed.add('numberOfInputs')
            self.numberOfInputs = self.gds_parse_integer(value, node, 'numberOfInputs')
            if self.numberOfInputs < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'NeuralInput':
            obj_ = NeuralInput.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NeuralInput.append(obj_)
            obj_.original_tagname_ = 'NeuralInput'
# end class NeuralInputs


class NeuralLayer(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, numberOfNeurons=None, activationFunction=None, threshold=None, width=None, altitude=None, normalizationMethod=None, Extension=None, Neuron=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numberOfNeurons = _cast(int, numberOfNeurons)
        self.numberOfNeurons_nsprefix_ = None
        self.activationFunction = _cast(None, activationFunction)
        self.activationFunction_nsprefix_ = None
        self.threshold = _cast(float, threshold)
        self.threshold_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.altitude = _cast(float, altitude)
        self.altitude_nsprefix_ = None
        self.normalizationMethod = _cast(None, normalizationMethod)
        self.normalizationMethod_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Neuron is None:
            self.Neuron = []
        else:
            self.Neuron = Neuron
        self.Neuron_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeuralLayer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuralLayer.subclass:
            return NeuralLayer.subclass(*args_, **kwargs_)
        else:
            return NeuralLayer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Neuron(self):
        return self.Neuron
    def set_Neuron(self, Neuron):
        self.Neuron = Neuron
    def add_Neuron(self, value):
        self.Neuron.append(value)
    def insert_Neuron_at(self, index, value):
        self.Neuron.insert(index, value)
    def replace_Neuron_at(self, index, value):
        self.Neuron[index] = value
    def get_numberOfNeurons(self):
        return self.numberOfNeurons
    def set_numberOfNeurons(self, numberOfNeurons):
        self.numberOfNeurons = numberOfNeurons
    def get_activationFunction(self):
        return self.activationFunction
    def set_activationFunction(self, activationFunction):
        self.activationFunction = activationFunction
    def get_threshold(self):
        return self.threshold
    def set_threshold(self, threshold):
        self.threshold = threshold
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_altitude(self):
        return self.altitude
    def set_altitude(self, altitude):
        self.altitude = altitude
    def get_normalizationMethod(self):
        return self.normalizationMethod
    def set_normalizationMethod(self, normalizationMethod):
        self.normalizationMethod = normalizationMethod
    def validate_ACTIVATION_FUNCTION(self, value):
        # Validate type ACTIVATION-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['threshold', 'logistic', 'tanh', 'identity', 'exponential', 'reciprocal', 'square', 'Gauss', 'sine', 'cosine', 'Elliott', 'arctan', 'radialBasis']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ACTIVATION-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_NN_NORMALIZATION_METHOD(self, value):
        # Validate type NN-NORMALIZATION-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'simplemax', 'softmax']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NN-NORMALIZATION-METHOD' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.Neuron
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NeuralLayer', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeuralLayer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NeuralLayer':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NeuralLayer')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NeuralLayer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NeuralLayer'):
        if self.numberOfNeurons is not None and 'numberOfNeurons' not in already_processed:
            already_processed.add('numberOfNeurons')
            outfile.write(' numberOfNeurons="%s"' % self.gds_format_integer(self.numberOfNeurons, input_name='numberOfNeurons'))
        if self.activationFunction is not None and 'activationFunction' not in already_processed:
            already_processed.add('activationFunction')
            outfile.write(' activationFunction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.activationFunction), input_name='activationFunction')), ))
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            outfile.write(' threshold="%s"' % self.gds_format_double(self.threshold, input_name='threshold'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            outfile.write(' altitude="%s"' % self.gds_format_double(self.altitude, input_name='altitude'))
        if self.normalizationMethod is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            outfile.write(' normalizationMethod=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.normalizationMethod), input_name='normalizationMethod')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NeuralLayer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Neuron_ in self.Neuron:
            namespaceprefix_ = self.Neuron_nsprefix_ + ':' if (UseCapturedNS_ and self.Neuron_nsprefix_) else ''
            Neuron_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Neuron', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfNeurons', node)
        if value is not None and 'numberOfNeurons' not in already_processed:
            already_processed.add('numberOfNeurons')
            self.numberOfNeurons = self.gds_parse_integer(value, node, 'numberOfNeurons')
            if self.numberOfNeurons < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('activationFunction', node)
        if value is not None and 'activationFunction' not in already_processed:
            already_processed.add('activationFunction')
            self.activationFunction = value
            self.validate_ACTIVATION_FUNCTION(self.activationFunction)    # validate type ACTIVATION-FUNCTION
        value = find_attr_value_('threshold', node)
        if value is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            value = self.gds_parse_double(value, node, 'threshold')
            self.threshold = value
            self.validate_REAL_NUMBER(self.threshold)    # validate type REAL-NUMBER
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
            self.validate_REAL_NUMBER(self.width)    # validate type REAL-NUMBER
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            value = self.gds_parse_double(value, node, 'altitude')
            self.altitude = value
            self.validate_REAL_NUMBER(self.altitude)    # validate type REAL-NUMBER
        value = find_attr_value_('normalizationMethod', node)
        if value is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            self.normalizationMethod = value
            self.validate_NN_NORMALIZATION_METHOD(self.normalizationMethod)    # validate type NN-NORMALIZATION-METHOD
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Neuron':
            obj_ = Neuron.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Neuron.append(obj_)
            obj_.original_tagname_ = 'Neuron'
# end class NeuralLayer


class NeuralOutputs(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, numberOfOutputs=None, Extension=None, NeuralOutput=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numberOfOutputs = _cast(int, numberOfOutputs)
        self.numberOfOutputs_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if NeuralOutput is None:
            self.NeuralOutput = []
        else:
            self.NeuralOutput = NeuralOutput
        self.NeuralOutput_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeuralOutputs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuralOutputs.subclass:
            return NeuralOutputs.subclass(*args_, **kwargs_)
        else:
            return NeuralOutputs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_NeuralOutput(self):
        return self.NeuralOutput
    def set_NeuralOutput(self, NeuralOutput):
        self.NeuralOutput = NeuralOutput
    def add_NeuralOutput(self, value):
        self.NeuralOutput.append(value)
    def insert_NeuralOutput_at(self, index, value):
        self.NeuralOutput.insert(index, value)
    def replace_NeuralOutput_at(self, index, value):
        self.NeuralOutput[index] = value
    def get_numberOfOutputs(self):
        return self.numberOfOutputs
    def set_numberOfOutputs(self, numberOfOutputs):
        self.numberOfOutputs = numberOfOutputs
    def _hasContent(self):
        if (
            self.Extension or
            self.NeuralOutput
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NeuralOutputs', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeuralOutputs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NeuralOutputs':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NeuralOutputs')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NeuralOutputs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NeuralOutputs'):
        if self.numberOfOutputs is not None and 'numberOfOutputs' not in already_processed:
            already_processed.add('numberOfOutputs')
            outfile.write(' numberOfOutputs="%s"' % self.gds_format_integer(self.numberOfOutputs, input_name='numberOfOutputs'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NeuralOutputs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for NeuralOutput_ in self.NeuralOutput:
            namespaceprefix_ = self.NeuralOutput_nsprefix_ + ':' if (UseCapturedNS_ and self.NeuralOutput_nsprefix_) else ''
            NeuralOutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NeuralOutput', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfOutputs', node)
        if value is not None and 'numberOfOutputs' not in already_processed:
            already_processed.add('numberOfOutputs')
            self.numberOfOutputs = self.gds_parse_integer(value, node, 'numberOfOutputs')
            if self.numberOfOutputs < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'NeuralOutput':
            obj_ = NeuralOutput.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NeuralOutput.append(obj_)
            obj_.original_tagname_ = 'NeuralOutput'
# end class NeuralOutputs


class NeuralInput(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, Extension=None, DerivedField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.DerivedField = DerivedField
        self.DerivedField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeuralInput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuralInput.subclass:
            return NeuralInput.subclass(*args_, **kwargs_)
        else:
            return NeuralInput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_DerivedField(self):
        return self.DerivedField
    def set_DerivedField(self, DerivedField):
        self.DerivedField = DerivedField
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_NN_NEURON_ID(self, value):
        # Validate type NN-NEURON-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.DerivedField is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NeuralInput', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeuralInput')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NeuralInput':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NeuralInput')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NeuralInput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NeuralInput'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NeuralInput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.DerivedField is not None:
            namespaceprefix_ = self.DerivedField_nsprefix_ + ':' if (UseCapturedNS_ and self.DerivedField_nsprefix_) else ''
            self.DerivedField.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DerivedField', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_NN_NEURON_ID(self.id)    # validate type NN-NEURON-ID
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DerivedField':
            obj_ = DerivedField.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DerivedField = obj_
            obj_.original_tagname_ = 'DerivedField'
# end class NeuralInput


class Neuron(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, bias=None, width=None, altitude=None, Extension=None, Con=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.bias = _cast(float, bias)
        self.bias_nsprefix_ = None
        self.width = _cast(float, width)
        self.width_nsprefix_ = None
        self.altitude = _cast(float, altitude)
        self.altitude_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Con is None:
            self.Con = []
        else:
            self.Con = Con
        self.Con_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Neuron)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Neuron.subclass:
            return Neuron.subclass(*args_, **kwargs_)
        else:
            return Neuron(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Con(self):
        return self.Con
    def set_Con(self, Con):
        self.Con = Con
    def add_Con(self, value):
        self.Con.append(value)
    def insert_Con_at(self, index, value):
        self.Con.insert(index, value)
    def replace_Con_at(self, index, value):
        self.Con[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_bias(self):
        return self.bias
    def set_bias(self, bias):
        self.bias = bias
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_altitude(self):
        return self.altitude
    def set_altitude(self, altitude):
        self.altitude = altitude
    def validate_NN_NEURON_ID(self, value):
        # Validate type NN-NEURON-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.Con
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Neuron', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Neuron')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Neuron':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Neuron')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Neuron', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Neuron'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.bias is not None and 'bias' not in already_processed:
            already_processed.add('bias')
            outfile.write(' bias="%s"' % self.gds_format_double(self.bias, input_name='bias'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_double(self.width, input_name='width'))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            outfile.write(' altitude="%s"' % self.gds_format_double(self.altitude, input_name='altitude'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Neuron', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Con_ in self.Con:
            namespaceprefix_ = self.Con_nsprefix_ + ':' if (UseCapturedNS_ and self.Con_nsprefix_) else ''
            Con_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Con', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_NN_NEURON_ID(self.id)    # validate type NN-NEURON-ID
        value = find_attr_value_('bias', node)
        if value is not None and 'bias' not in already_processed:
            already_processed.add('bias')
            value = self.gds_parse_double(value, node, 'bias')
            self.bias = value
            self.validate_REAL_NUMBER(self.bias)    # validate type REAL-NUMBER
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            value = self.gds_parse_double(value, node, 'width')
            self.width = value
            self.validate_REAL_NUMBER(self.width)    # validate type REAL-NUMBER
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            value = self.gds_parse_double(value, node, 'altitude')
            self.altitude = value
            self.validate_REAL_NUMBER(self.altitude)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Con':
            obj_ = Con.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Con.append(obj_)
            obj_.original_tagname_ = 'Con'
# end class Neuron


class Con(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, from_=None, weight=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.from_ = _cast(None, from_)
        self.from__nsprefix_ = None
        self.weight = _cast(float, weight)
        self.weight_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Con)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Con.subclass:
            return Con.subclass(*args_, **kwargs_)
        else:
            return Con(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_from(self):
        return self.from_
    def set_from(self, from_):
        self.from_ = from_
    def get_weight(self):
        return self.weight
    def set_weight(self, weight):
        self.weight = weight
    def validate_NN_NEURON_IDREF(self, value):
        # Validate type NN-NEURON-IDREF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Con', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Con')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Con':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Con')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Con', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Con'):
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.from_), input_name='from')), ))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight="%s"' % self.gds_format_double(self.weight, input_name='weight'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Con', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = value
            self.validate_NN_NEURON_IDREF(self.from_)    # validate type NN-NEURON-IDREF
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            value = self.gds_parse_double(value, node, 'weight')
            self.weight = value
            self.validate_REAL_NUMBER(self.weight)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Con


class NeuralOutput(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, outputNeuron=None, Extension=None, DerivedField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.outputNeuron = _cast(None, outputNeuron)
        self.outputNeuron_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.DerivedField = DerivedField
        self.DerivedField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeuralOutput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeuralOutput.subclass:
            return NeuralOutput.subclass(*args_, **kwargs_)
        else:
            return NeuralOutput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_DerivedField(self):
        return self.DerivedField
    def set_DerivedField(self, DerivedField):
        self.DerivedField = DerivedField
    def get_outputNeuron(self):
        return self.outputNeuron
    def set_outputNeuron(self, outputNeuron):
        self.outputNeuron = outputNeuron
    def validate_NN_NEURON_IDREF(self, value):
        # Validate type NN-NEURON-IDREF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.DerivedField is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NeuralOutput', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeuralOutput')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NeuralOutput':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NeuralOutput')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NeuralOutput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NeuralOutput'):
        if self.outputNeuron is not None and 'outputNeuron' not in already_processed:
            already_processed.add('outputNeuron')
            outfile.write(' outputNeuron=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.outputNeuron), input_name='outputNeuron')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NeuralOutput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.DerivedField is not None:
            namespaceprefix_ = self.DerivedField_nsprefix_ + ':' if (UseCapturedNS_ and self.DerivedField_nsprefix_) else ''
            self.DerivedField.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DerivedField', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('outputNeuron', node)
        if value is not None and 'outputNeuron' not in already_processed:
            already_processed.add('outputNeuron')
            self.outputNeuron = value
            self.validate_NN_NEURON_IDREF(self.outputNeuron)    # validate type NN-NEURON-IDREF
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DerivedField':
            obj_ = DerivedField.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DerivedField = obj_
            obj_.original_tagname_ = 'DerivedField'
# end class NeuralOutput


class ClusteringModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, modelClass=None, numberOfClusters=None, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, LocalTransformations=None, ComparisonMeasure=None, ClusteringField=None, MissingValueWeights=None, Cluster=None, ModelVerification=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.modelClass = _cast(None, modelClass)
        self.modelClass_nsprefix_ = None
        self.numberOfClusters = _cast(int, numberOfClusters)
        self.numberOfClusters_nsprefix_ = None
        self.MiningSchema = MiningSchema
        self.MiningSchema_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.ModelExplanation = ModelExplanation
        self.ModelExplanation_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        self.ComparisonMeasure = ComparisonMeasure
        self.ComparisonMeasure_nsprefix_ = None
        if ClusteringField is None:
            self.ClusteringField = []
        else:
            self.ClusteringField = ClusteringField
        self.ClusteringField_nsprefix_ = None
        self.MissingValueWeights = MissingValueWeights
        self.MissingValueWeights_nsprefix_ = None
        if Cluster is None:
            self.Cluster = []
        else:
            self.Cluster = Cluster
        self.Cluster_nsprefix_ = None
        self.ModelVerification = ModelVerification
        self.ModelVerification_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClusteringModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClusteringModel.subclass:
            return ClusteringModel.subclass(*args_, **kwargs_)
        else:
            return ClusteringModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MiningSchema(self):
        return self.MiningSchema
    def set_MiningSchema(self, MiningSchema):
        self.MiningSchema = MiningSchema
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_ModelExplanation(self):
        return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation):
        self.ModelExplanation = ModelExplanation
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_ComparisonMeasure(self):
        return self.ComparisonMeasure
    def set_ComparisonMeasure(self, ComparisonMeasure):
        self.ComparisonMeasure = ComparisonMeasure
    def get_ClusteringField(self):
        return self.ClusteringField
    def set_ClusteringField(self, ClusteringField):
        self.ClusteringField = ClusteringField
    def add_ClusteringField(self, value):
        self.ClusteringField.append(value)
    def insert_ClusteringField_at(self, index, value):
        self.ClusteringField.insert(index, value)
    def replace_ClusteringField_at(self, index, value):
        self.ClusteringField[index] = value
    def get_MissingValueWeights(self):
        return self.MissingValueWeights
    def set_MissingValueWeights(self, MissingValueWeights):
        self.MissingValueWeights = MissingValueWeights
    def get_Cluster(self):
        return self.Cluster
    def set_Cluster(self, Cluster):
        self.Cluster = Cluster
    def add_Cluster(self, value):
        self.Cluster.append(value)
    def insert_Cluster_at(self, index, value):
        self.Cluster.insert(index, value)
    def replace_Cluster_at(self, index, value):
        self.Cluster[index] = value
    def get_ModelVerification(self):
        return self.ModelVerification
    def set_ModelVerification(self, ModelVerification):
        self.ModelVerification = ModelVerification
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def get_modelClass(self):
        return self.modelClass
    def set_modelClass(self, modelClass):
        self.modelClass = modelClass
    def get_numberOfClusters(self):
        return self.numberOfClusters
    def set_numberOfClusters(self, numberOfClusters):
        self.numberOfClusters = numberOfClusters
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_modelClassType(self, value):
        # Validate type modelClassType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['centerBased', 'distributionBased']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on modelClassType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.LocalTransformations is not None or
            self.ComparisonMeasure is not None or
            self.ClusteringField or
            self.MissingValueWeights is not None or
            self.Cluster or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ClusteringModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClusteringModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ClusteringModel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClusteringModel')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClusteringModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClusteringModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.modelClass is not None and 'modelClass' not in already_processed:
            already_processed.add('modelClass')
            outfile.write(' modelClass=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelClass), input_name='modelClass')), ))
        if self.numberOfClusters is not None and 'numberOfClusters' not in already_processed:
            already_processed.add('numberOfClusters')
            outfile.write(' numberOfClusters="%s"' % self.gds_format_integer(self.numberOfClusters, input_name='numberOfClusters'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ClusteringModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            namespaceprefix_ = self.MiningSchema_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningSchema_nsprefix_) else ''
            self.MiningSchema.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            namespaceprefix_ = self.ModelExplanation_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelExplanation_nsprefix_) else ''
            self.ModelExplanation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelExplanation', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        if self.ComparisonMeasure is not None:
            namespaceprefix_ = self.ComparisonMeasure_nsprefix_ + ':' if (UseCapturedNS_ and self.ComparisonMeasure_nsprefix_) else ''
            self.ComparisonMeasure.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ComparisonMeasure', pretty_print=pretty_print)
        for ClusteringField_ in self.ClusteringField:
            namespaceprefix_ = self.ClusteringField_nsprefix_ + ':' if (UseCapturedNS_ and self.ClusteringField_nsprefix_) else ''
            ClusteringField_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClusteringField', pretty_print=pretty_print)
        if self.MissingValueWeights is not None:
            namespaceprefix_ = self.MissingValueWeights_nsprefix_ + ':' if (UseCapturedNS_ and self.MissingValueWeights_nsprefix_) else ''
            self.MissingValueWeights.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MissingValueWeights', pretty_print=pretty_print)
        for Cluster_ in self.Cluster:
            namespaceprefix_ = self.Cluster_nsprefix_ + ':' if (UseCapturedNS_ and self.Cluster_nsprefix_) else ''
            Cluster_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Cluster', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            namespaceprefix_ = self.ModelVerification_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelVerification_nsprefix_) else ''
            self.ModelVerification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('modelClass', node)
        if value is not None and 'modelClass' not in already_processed:
            already_processed.add('modelClass')
            self.modelClass = value
            self.validate_modelClassType(self.modelClass)    # validate type modelClassType
        value = find_attr_value_('numberOfClusters', node)
        if value is not None and 'numberOfClusters' not in already_processed:
            already_processed.add('numberOfClusters')
            self.numberOfClusters = self.gds_parse_integer(value, node, 'numberOfClusters')
            self.validate_INT_NUMBER(self.numberOfClusters)    # validate type INT-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'ComparisonMeasure':
            obj_ = ComparisonMeasure.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ComparisonMeasure = obj_
            obj_.original_tagname_ = 'ComparisonMeasure'
        elif nodeName_ == 'ClusteringField':
            obj_ = ClusteringField.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClusteringField.append(obj_)
            obj_.original_tagname_ = 'ClusteringField'
        elif nodeName_ == 'MissingValueWeights':
            obj_ = MissingValueWeights.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MissingValueWeights = obj_
            obj_.original_tagname_ = 'MissingValueWeights'
        elif nodeName_ == 'Cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Cluster.append(obj_)
            obj_.original_tagname_ = 'Cluster'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class ClusteringModel


class MissingValueWeights(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MissingValueWeights)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MissingValueWeights.subclass:
            return MissingValueWeights.subclass(*args_, **kwargs_)
        else:
            return MissingValueWeights(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def _hasContent(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='MissingValueWeights', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MissingValueWeights')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MissingValueWeights':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MissingValueWeights')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MissingValueWeights', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MissingValueWeights'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='MissingValueWeights', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class MissingValueWeights


class Cluster(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, size=None, Extension=None, KohonenMap=None, Array=None, Partition=None, Covariances=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.size = _cast(int, size)
        self.size_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.KohonenMap = KohonenMap
        self.KohonenMap_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
        self.Partition = Partition
        self.Partition_nsprefix_ = None
        self.Covariances = Covariances
        self.Covariances_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cluster)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cluster.subclass:
            return Cluster.subclass(*args_, **kwargs_)
        else:
            return Cluster(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_KohonenMap(self):
        return self.KohonenMap
    def set_KohonenMap(self, KohonenMap):
        self.KohonenMap = KohonenMap
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def get_Partition(self):
        return self.Partition
    def set_Partition(self, Partition):
        self.Partition = Partition
    def get_Covariances(self):
        return self.Covariances
    def set_Covariances(self, Covariances):
        self.Covariances = Covariances
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def _hasContent(self):
        if (
            self.Extension or
            self.KohonenMap is not None or
            self.Array is not None or
            self.Partition is not None or
            self.Covariances is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Cluster', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Cluster')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Cluster':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Cluster')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Cluster', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Cluster'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Cluster', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.KohonenMap is not None:
            namespaceprefix_ = self.KohonenMap_nsprefix_ + ':' if (UseCapturedNS_ and self.KohonenMap_nsprefix_) else ''
            self.KohonenMap.export(outfile, level, namespaceprefix_, namespacedef_='', name_='KohonenMap', pretty_print=pretty_print)
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
        if self.Partition is not None:
            namespaceprefix_ = self.Partition_nsprefix_ + ':' if (UseCapturedNS_ and self.Partition_nsprefix_) else ''
            self.Partition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Partition', pretty_print=pretty_print)
        if self.Covariances is not None:
            namespaceprefix_ = self.Covariances_nsprefix_ + ':' if (UseCapturedNS_ and self.Covariances_nsprefix_) else ''
            self.Covariances.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Covariances', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = self.gds_parse_integer(value, node, 'size')
            if self.size < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'KohonenMap':
            obj_ = KohonenMap.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.KohonenMap = obj_
            obj_.original_tagname_ = 'KohonenMap'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
        elif nodeName_ == 'Partition':
            obj_ = Partition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Partition = obj_
            obj_.original_tagname_ = 'Partition'
        elif nodeName_ == 'Covariances':
            obj_ = Covariances.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Covariances = obj_
            obj_.original_tagname_ = 'Covariances'
# end class Cluster


class KohonenMap(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, coord1=None, coord2=None, coord3=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.coord1 = _cast(float, coord1)
        self.coord1_nsprefix_ = None
        self.coord2 = _cast(float, coord2)
        self.coord2_nsprefix_ = None
        self.coord3 = _cast(float, coord3)
        self.coord3_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KohonenMap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KohonenMap.subclass:
            return KohonenMap.subclass(*args_, **kwargs_)
        else:
            return KohonenMap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_coord1(self):
        return self.coord1
    def set_coord1(self, coord1):
        self.coord1 = coord1
    def get_coord2(self):
        return self.coord2
    def set_coord2(self, coord2):
        self.coord2 = coord2
    def get_coord3(self):
        return self.coord3
    def set_coord3(self, coord3):
        self.coord3 = coord3
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='KohonenMap', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KohonenMap')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'KohonenMap':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KohonenMap')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='KohonenMap', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='KohonenMap'):
        if self.coord1 is not None and 'coord1' not in already_processed:
            already_processed.add('coord1')
            outfile.write(' coord1="%s"' % self.gds_format_float(self.coord1, input_name='coord1'))
        if self.coord2 is not None and 'coord2' not in already_processed:
            already_processed.add('coord2')
            outfile.write(' coord2="%s"' % self.gds_format_float(self.coord2, input_name='coord2'))
        if self.coord3 is not None and 'coord3' not in already_processed:
            already_processed.add('coord3')
            outfile.write(' coord3="%s"' % self.gds_format_float(self.coord3, input_name='coord3'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='KohonenMap', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coord1', node)
        if value is not None and 'coord1' not in already_processed:
            already_processed.add('coord1')
            value = self.gds_parse_float(value, node, 'coord1')
            self.coord1 = value
        value = find_attr_value_('coord2', node)
        if value is not None and 'coord2' not in already_processed:
            already_processed.add('coord2')
            value = self.gds_parse_float(value, node, 'coord2')
            self.coord2 = value
        value = find_attr_value_('coord3', node)
        if value is not None and 'coord3' not in already_processed:
            already_processed.add('coord3')
            value = self.gds_parse_float(value, node, 'coord3')
            self.coord3 = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class KohonenMap


class Covariances(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Matrix = Matrix
        self.Matrix_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Covariances)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Covariances.subclass:
            return Covariances.subclass(*args_, **kwargs_)
        else:
            return Covariances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Matrix(self):
        return self.Matrix
    def set_Matrix(self, Matrix):
        self.Matrix = Matrix
    def _hasContent(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Covariances', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Covariances')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Covariances':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Covariances')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Covariances', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Covariances'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Covariances', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            namespaceprefix_ = self.Matrix_nsprefix_ + ':' if (UseCapturedNS_ and self.Matrix_nsprefix_) else ''
            self.Matrix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Matrix', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class Covariances


class ClusteringField(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, field=None, isCenterField='true', fieldWeight='1', similarityScale=None, compareFunction=None, Extension=None, Comparisons=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        self.isCenterField = _cast(None, isCenterField)
        self.isCenterField_nsprefix_ = None
        self.fieldWeight = _cast(float, fieldWeight)
        self.fieldWeight_nsprefix_ = None
        self.similarityScale = _cast(float, similarityScale)
        self.similarityScale_nsprefix_ = None
        self.compareFunction = _cast(None, compareFunction)
        self.compareFunction_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Comparisons = Comparisons
        self.Comparisons_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClusteringField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClusteringField.subclass:
            return ClusteringField.subclass(*args_, **kwargs_)
        else:
            return ClusteringField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Comparisons(self):
        return self.Comparisons
    def set_Comparisons(self, Comparisons):
        self.Comparisons = Comparisons
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_isCenterField(self):
        return self.isCenterField
    def set_isCenterField(self, isCenterField):
        self.isCenterField = isCenterField
    def get_fieldWeight(self):
        return self.fieldWeight
    def set_fieldWeight(self, fieldWeight):
        self.fieldWeight = fieldWeight
    def get_similarityScale(self):
        return self.similarityScale
    def set_similarityScale(self, similarityScale):
        self.similarityScale = similarityScale
    def get_compareFunction(self):
        return self.compareFunction
    def set_compareFunction(self, compareFunction):
        self.compareFunction = compareFunction
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_isCenterFieldType(self, value):
        # Validate type isCenterFieldType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['true', 'false']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on isCenterFieldType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_COMPARE_FUNCTION(self, value):
        # Validate type COMPARE-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['absDiff', 'gaussSim', 'delta', 'equal', 'table']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on COMPARE-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.Comparisons is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ClusteringField', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClusteringField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ClusteringField':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClusteringField')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClusteringField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClusteringField'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.isCenterField != "true" and 'isCenterField' not in already_processed:
            already_processed.add('isCenterField')
            outfile.write(' isCenterField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.isCenterField), input_name='isCenterField')), ))
        if self.fieldWeight != 1 and 'fieldWeight' not in already_processed:
            already_processed.add('fieldWeight')
            outfile.write(' fieldWeight="%s"' % self.gds_format_double(self.fieldWeight, input_name='fieldWeight'))
        if self.similarityScale is not None and 'similarityScale' not in already_processed:
            already_processed.add('similarityScale')
            outfile.write(' similarityScale="%s"' % self.gds_format_double(self.similarityScale, input_name='similarityScale'))
        if self.compareFunction is not None and 'compareFunction' not in already_processed:
            already_processed.add('compareFunction')
            outfile.write(' compareFunction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.compareFunction), input_name='compareFunction')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ClusteringField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Comparisons is not None:
            namespaceprefix_ = self.Comparisons_nsprefix_ + ':' if (UseCapturedNS_ and self.Comparisons_nsprefix_) else ''
            self.Comparisons.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Comparisons', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('isCenterField', node)
        if value is not None and 'isCenterField' not in already_processed:
            already_processed.add('isCenterField')
            self.isCenterField = value
            self.validate_isCenterFieldType(self.isCenterField)    # validate type isCenterFieldType
        value = find_attr_value_('fieldWeight', node)
        if value is not None and 'fieldWeight' not in already_processed:
            already_processed.add('fieldWeight')
            value = self.gds_parse_double(value, node, 'fieldWeight')
            self.fieldWeight = value
            self.validate_REAL_NUMBER(self.fieldWeight)    # validate type REAL-NUMBER
        value = find_attr_value_('similarityScale', node)
        if value is not None and 'similarityScale' not in already_processed:
            already_processed.add('similarityScale')
            value = self.gds_parse_double(value, node, 'similarityScale')
            self.similarityScale = value
            self.validate_REAL_NUMBER(self.similarityScale)    # validate type REAL-NUMBER
        value = find_attr_value_('compareFunction', node)
        if value is not None and 'compareFunction' not in already_processed:
            already_processed.add('compareFunction')
            self.compareFunction = value
            self.validate_COMPARE_FUNCTION(self.compareFunction)    # validate type COMPARE-FUNCTION
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Comparisons':
            obj_ = Comparisons.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Comparisons = obj_
            obj_.original_tagname_ = 'Comparisons'
# end class ClusteringField


class Comparisons(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Matrix = Matrix
        self.Matrix_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Comparisons)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Comparisons.subclass:
            return Comparisons.subclass(*args_, **kwargs_)
        else:
            return Comparisons(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Matrix(self):
        return self.Matrix
    def set_Matrix(self, Matrix):
        self.Matrix = Matrix
    def _hasContent(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Comparisons', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Comparisons')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Comparisons':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Comparisons')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Comparisons', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Comparisons'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Comparisons', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            namespaceprefix_ = self.Matrix_nsprefix_ + ':' if (UseCapturedNS_ and self.Matrix_nsprefix_) else ''
            self.Matrix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Matrix', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class Comparisons


class ComparisonMeasure(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, kind=None, compareFunction='absDiff', minimum=None, maximum=None, Extension=None, euclidean=None, squaredEuclidean=None, chebychev=None, cityBlock=None, minkowski=None, simpleMatching=None, jaccard=None, tanimoto=None, binarySimilarity=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.kind = _cast(None, kind)
        self.kind_nsprefix_ = None
        self.compareFunction = _cast(None, compareFunction)
        self.compareFunction_nsprefix_ = None
        self.minimum = _cast(float, minimum)
        self.minimum_nsprefix_ = None
        self.maximum = _cast(float, maximum)
        self.maximum_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.euclidean = euclidean
        self.euclidean_nsprefix_ = None
        self.squaredEuclidean = squaredEuclidean
        self.squaredEuclidean_nsprefix_ = None
        self.chebychev = chebychev
        self.chebychev_nsprefix_ = None
        self.cityBlock = cityBlock
        self.cityBlock_nsprefix_ = None
        self.minkowski = minkowski
        self.minkowski_nsprefix_ = None
        self.simpleMatching = simpleMatching
        self.simpleMatching_nsprefix_ = None
        self.jaccard = jaccard
        self.jaccard_nsprefix_ = None
        self.tanimoto = tanimoto
        self.tanimoto_nsprefix_ = None
        self.binarySimilarity = binarySimilarity
        self.binarySimilarity_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComparisonMeasure)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComparisonMeasure.subclass:
            return ComparisonMeasure.subclass(*args_, **kwargs_)
        else:
            return ComparisonMeasure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_euclidean(self):
        return self.euclidean
    def set_euclidean(self, euclidean):
        self.euclidean = euclidean
    def get_squaredEuclidean(self):
        return self.squaredEuclidean
    def set_squaredEuclidean(self, squaredEuclidean):
        self.squaredEuclidean = squaredEuclidean
    def get_chebychev(self):
        return self.chebychev
    def set_chebychev(self, chebychev):
        self.chebychev = chebychev
    def get_cityBlock(self):
        return self.cityBlock
    def set_cityBlock(self, cityBlock):
        self.cityBlock = cityBlock
    def get_minkowski(self):
        return self.minkowski
    def set_minkowski(self, minkowski):
        self.minkowski = minkowski
    def get_simpleMatching(self):
        return self.simpleMatching
    def set_simpleMatching(self, simpleMatching):
        self.simpleMatching = simpleMatching
    def get_jaccard(self):
        return self.jaccard
    def set_jaccard(self, jaccard):
        self.jaccard = jaccard
    def get_tanimoto(self):
        return self.tanimoto
    def set_tanimoto(self, tanimoto):
        self.tanimoto = tanimoto
    def get_binarySimilarity(self):
        return self.binarySimilarity
    def set_binarySimilarity(self, binarySimilarity):
        self.binarySimilarity = binarySimilarity
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def get_compareFunction(self):
        return self.compareFunction
    def set_compareFunction(self, compareFunction):
        self.compareFunction = compareFunction
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def validate_kindType3(self, value):
        # Validate type kindType3, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['distance', 'similarity']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on kindType3' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_COMPARE_FUNCTION(self, value):
        # Validate type COMPARE-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['absDiff', 'gaussSim', 'delta', 'equal', 'table']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on COMPARE-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.euclidean is not None or
            self.squaredEuclidean is not None or
            self.chebychev is not None or
            self.cityBlock is not None or
            self.minkowski is not None or
            self.simpleMatching is not None or
            self.jaccard is not None or
            self.tanimoto is not None or
            self.binarySimilarity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ComparisonMeasure', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ComparisonMeasure')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ComparisonMeasure':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ComparisonMeasure')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ComparisonMeasure', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ComparisonMeasure'):
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kind), input_name='kind')), ))
        if self.compareFunction != "absDiff" and 'compareFunction' not in already_processed:
            already_processed.add('compareFunction')
            outfile.write(' compareFunction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.compareFunction), input_name='compareFunction')), ))
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_double(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_double(self.maximum, input_name='maximum'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ComparisonMeasure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.euclidean is not None:
            namespaceprefix_ = self.euclidean_nsprefix_ + ':' if (UseCapturedNS_ and self.euclidean_nsprefix_) else ''
            self.euclidean.export(outfile, level, namespaceprefix_, namespacedef_='', name_='euclidean', pretty_print=pretty_print)
        if self.squaredEuclidean is not None:
            namespaceprefix_ = self.squaredEuclidean_nsprefix_ + ':' if (UseCapturedNS_ and self.squaredEuclidean_nsprefix_) else ''
            self.squaredEuclidean.export(outfile, level, namespaceprefix_, namespacedef_='', name_='squaredEuclidean', pretty_print=pretty_print)
        if self.chebychev is not None:
            namespaceprefix_ = self.chebychev_nsprefix_ + ':' if (UseCapturedNS_ and self.chebychev_nsprefix_) else ''
            self.chebychev.export(outfile, level, namespaceprefix_, namespacedef_='', name_='chebychev', pretty_print=pretty_print)
        if self.cityBlock is not None:
            namespaceprefix_ = self.cityBlock_nsprefix_ + ':' if (UseCapturedNS_ and self.cityBlock_nsprefix_) else ''
            self.cityBlock.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cityBlock', pretty_print=pretty_print)
        if self.minkowski is not None:
            namespaceprefix_ = self.minkowski_nsprefix_ + ':' if (UseCapturedNS_ and self.minkowski_nsprefix_) else ''
            self.minkowski.export(outfile, level, namespaceprefix_, namespacedef_='', name_='minkowski', pretty_print=pretty_print)
        if self.simpleMatching is not None:
            namespaceprefix_ = self.simpleMatching_nsprefix_ + ':' if (UseCapturedNS_ and self.simpleMatching_nsprefix_) else ''
            self.simpleMatching.export(outfile, level, namespaceprefix_, namespacedef_='', name_='simpleMatching', pretty_print=pretty_print)
        if self.jaccard is not None:
            namespaceprefix_ = self.jaccard_nsprefix_ + ':' if (UseCapturedNS_ and self.jaccard_nsprefix_) else ''
            self.jaccard.export(outfile, level, namespaceprefix_, namespacedef_='', name_='jaccard', pretty_print=pretty_print)
        if self.tanimoto is not None:
            namespaceprefix_ = self.tanimoto_nsprefix_ + ':' if (UseCapturedNS_ and self.tanimoto_nsprefix_) else ''
            self.tanimoto.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tanimoto', pretty_print=pretty_print)
        if self.binarySimilarity is not None:
            namespaceprefix_ = self.binarySimilarity_nsprefix_ + ':' if (UseCapturedNS_ and self.binarySimilarity_nsprefix_) else ''
            self.binarySimilarity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='binarySimilarity', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
            self.validate_kindType3(self.kind)    # validate type kindType3
        value = find_attr_value_('compareFunction', node)
        if value is not None and 'compareFunction' not in already_processed:
            already_processed.add('compareFunction')
            self.compareFunction = value
            self.validate_COMPARE_FUNCTION(self.compareFunction)    # validate type COMPARE-FUNCTION
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            value = self.gds_parse_double(value, node, 'minimum')
            self.minimum = value
            self.validate_NUMBER(self.minimum)    # validate type NUMBER
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            value = self.gds_parse_double(value, node, 'maximum')
            self.maximum = value
            self.validate_NUMBER(self.maximum)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'euclidean':
            obj_ = euclidean.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.euclidean = obj_
            obj_.original_tagname_ = 'euclidean'
        elif nodeName_ == 'squaredEuclidean':
            obj_ = squaredEuclidean.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.squaredEuclidean = obj_
            obj_.original_tagname_ = 'squaredEuclidean'
        elif nodeName_ == 'chebychev':
            obj_ = chebychev.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.chebychev = obj_
            obj_.original_tagname_ = 'chebychev'
        elif nodeName_ == 'cityBlock':
            obj_ = cityBlock.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cityBlock = obj_
            obj_.original_tagname_ = 'cityBlock'
        elif nodeName_ == 'minkowski':
            obj_ = minkowski.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.minkowski = obj_
            obj_.original_tagname_ = 'minkowski'
        elif nodeName_ == 'simpleMatching':
            obj_ = simpleMatching.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.simpleMatching = obj_
            obj_.original_tagname_ = 'simpleMatching'
        elif nodeName_ == 'jaccard':
            obj_ = jaccard.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.jaccard = obj_
            obj_.original_tagname_ = 'jaccard'
        elif nodeName_ == 'tanimoto':
            obj_ = tanimoto.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tanimoto = obj_
            obj_.original_tagname_ = 'tanimoto'
        elif nodeName_ == 'binarySimilarity':
            obj_ = binarySimilarity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.binarySimilarity = obj_
            obj_.original_tagname_ = 'binarySimilarity'
# end class ComparisonMeasure


class euclidean(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, euclidean)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if euclidean.subclass:
            return euclidean.subclass(*args_, **kwargs_)
        else:
            return euclidean(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='euclidean', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('euclidean')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'euclidean':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='euclidean')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='euclidean', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='euclidean'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='euclidean', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class euclidean


class squaredEuclidean(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, squaredEuclidean)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if squaredEuclidean.subclass:
            return squaredEuclidean.subclass(*args_, **kwargs_)
        else:
            return squaredEuclidean(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='squaredEuclidean', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('squaredEuclidean')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'squaredEuclidean':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='squaredEuclidean')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='squaredEuclidean', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='squaredEuclidean'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='squaredEuclidean', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class squaredEuclidean


class cityBlock(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cityBlock)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cityBlock.subclass:
            return cityBlock.subclass(*args_, **kwargs_)
        else:
            return cityBlock(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='cityBlock', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cityBlock')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cityBlock':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cityBlock')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cityBlock', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cityBlock'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='cityBlock', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class cityBlock


class chebychev(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, chebychev)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if chebychev.subclass:
            return chebychev.subclass(*args_, **kwargs_)
        else:
            return chebychev(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='chebychev', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('chebychev')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'chebychev':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='chebychev')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='chebychev', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='chebychev'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='chebychev', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class chebychev


class minkowski(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, p_parameter=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.p_parameter = _cast(float, p_parameter)
        self.p_parameter_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, minkowski)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if minkowski.subclass:
            return minkowski.subclass(*args_, **kwargs_)
        else:
            return minkowski(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_p_parameter(self):
        return self.p_parameter
    def set_p_parameter(self, p_parameter):
        self.p_parameter = p_parameter
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='minkowski', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('minkowski')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'minkowski':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='minkowski')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='minkowski', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='minkowski'):
        if self.p_parameter is not None and 'p_parameter' not in already_processed:
            already_processed.add('p_parameter')
            outfile.write(' p-parameter="%s"' % self.gds_format_double(self.p_parameter, input_name='p-parameter'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='minkowski', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('p-parameter', node)
        if value is not None and 'p-parameter' not in already_processed:
            already_processed.add('p-parameter')
            value = self.gds_parse_double(value, node, 'p-parameter')
            self.p_parameter = value
            self.validate_NUMBER(self.p_parameter)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class minkowski


class simpleMatching(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, simpleMatching)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if simpleMatching.subclass:
            return simpleMatching.subclass(*args_, **kwargs_)
        else:
            return simpleMatching(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='simpleMatching', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('simpleMatching')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'simpleMatching':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='simpleMatching')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='simpleMatching', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='simpleMatching'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='simpleMatching', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class simpleMatching


class jaccard(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, jaccard)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if jaccard.subclass:
            return jaccard.subclass(*args_, **kwargs_)
        else:
            return jaccard(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='jaccard', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('jaccard')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'jaccard':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='jaccard')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='jaccard', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='jaccard'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='jaccard', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class jaccard


class tanimoto(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tanimoto)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tanimoto.subclass:
            return tanimoto.subclass(*args_, **kwargs_)
        else:
            return tanimoto(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='tanimoto', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tanimoto')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tanimoto':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tanimoto')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tanimoto', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tanimoto'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='tanimoto', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class tanimoto


class binarySimilarity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, c00_parameter=None, c01_parameter=None, c10_parameter=None, c11_parameter=None, d00_parameter=None, d01_parameter=None, d10_parameter=None, d11_parameter=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.c00_parameter = _cast(float, c00_parameter)
        self.c00_parameter_nsprefix_ = None
        self.c01_parameter = _cast(float, c01_parameter)
        self.c01_parameter_nsprefix_ = None
        self.c10_parameter = _cast(float, c10_parameter)
        self.c10_parameter_nsprefix_ = None
        self.c11_parameter = _cast(float, c11_parameter)
        self.c11_parameter_nsprefix_ = None
        self.d00_parameter = _cast(float, d00_parameter)
        self.d00_parameter_nsprefix_ = None
        self.d01_parameter = _cast(float, d01_parameter)
        self.d01_parameter_nsprefix_ = None
        self.d10_parameter = _cast(float, d10_parameter)
        self.d10_parameter_nsprefix_ = None
        self.d11_parameter = _cast(float, d11_parameter)
        self.d11_parameter_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, binarySimilarity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if binarySimilarity.subclass:
            return binarySimilarity.subclass(*args_, **kwargs_)
        else:
            return binarySimilarity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_c00_parameter(self):
        return self.c00_parameter
    def set_c00_parameter(self, c00_parameter):
        self.c00_parameter = c00_parameter
    def get_c01_parameter(self):
        return self.c01_parameter
    def set_c01_parameter(self, c01_parameter):
        self.c01_parameter = c01_parameter
    def get_c10_parameter(self):
        return self.c10_parameter
    def set_c10_parameter(self, c10_parameter):
        self.c10_parameter = c10_parameter
    def get_c11_parameter(self):
        return self.c11_parameter
    def set_c11_parameter(self, c11_parameter):
        self.c11_parameter = c11_parameter
    def get_d00_parameter(self):
        return self.d00_parameter
    def set_d00_parameter(self, d00_parameter):
        self.d00_parameter = d00_parameter
    def get_d01_parameter(self):
        return self.d01_parameter
    def set_d01_parameter(self, d01_parameter):
        self.d01_parameter = d01_parameter
    def get_d10_parameter(self):
        return self.d10_parameter
    def set_d10_parameter(self, d10_parameter):
        self.d10_parameter = d10_parameter
    def get_d11_parameter(self):
        return self.d11_parameter
    def set_d11_parameter(self, d11_parameter):
        self.d11_parameter = d11_parameter
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='binarySimilarity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('binarySimilarity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'binarySimilarity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='binarySimilarity')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='binarySimilarity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='binarySimilarity'):
        if self.c00_parameter is not None and 'c00_parameter' not in already_processed:
            already_processed.add('c00_parameter')
            outfile.write(' c00-parameter="%s"' % self.gds_format_double(self.c00_parameter, input_name='c00-parameter'))
        if self.c01_parameter is not None and 'c01_parameter' not in already_processed:
            already_processed.add('c01_parameter')
            outfile.write(' c01-parameter="%s"' % self.gds_format_double(self.c01_parameter, input_name='c01-parameter'))
        if self.c10_parameter is not None and 'c10_parameter' not in already_processed:
            already_processed.add('c10_parameter')
            outfile.write(' c10-parameter="%s"' % self.gds_format_double(self.c10_parameter, input_name='c10-parameter'))
        if self.c11_parameter is not None and 'c11_parameter' not in already_processed:
            already_processed.add('c11_parameter')
            outfile.write(' c11-parameter="%s"' % self.gds_format_double(self.c11_parameter, input_name='c11-parameter'))
        if self.d00_parameter is not None and 'd00_parameter' not in already_processed:
            already_processed.add('d00_parameter')
            outfile.write(' d00-parameter="%s"' % self.gds_format_double(self.d00_parameter, input_name='d00-parameter'))
        if self.d01_parameter is not None and 'd01_parameter' not in already_processed:
            already_processed.add('d01_parameter')
            outfile.write(' d01-parameter="%s"' % self.gds_format_double(self.d01_parameter, input_name='d01-parameter'))
        if self.d10_parameter is not None and 'd10_parameter' not in already_processed:
            already_processed.add('d10_parameter')
            outfile.write(' d10-parameter="%s"' % self.gds_format_double(self.d10_parameter, input_name='d10-parameter'))
        if self.d11_parameter is not None and 'd11_parameter' not in already_processed:
            already_processed.add('d11_parameter')
            outfile.write(' d11-parameter="%s"' % self.gds_format_double(self.d11_parameter, input_name='d11-parameter'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='binarySimilarity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('c00-parameter', node)
        if value is not None and 'c00-parameter' not in already_processed:
            already_processed.add('c00-parameter')
            value = self.gds_parse_double(value, node, 'c00-parameter')
            self.c00_parameter = value
            self.validate_NUMBER(self.c00_parameter)    # validate type NUMBER
        value = find_attr_value_('c01-parameter', node)
        if value is not None and 'c01-parameter' not in already_processed:
            already_processed.add('c01-parameter')
            value = self.gds_parse_double(value, node, 'c01-parameter')
            self.c01_parameter = value
            self.validate_NUMBER(self.c01_parameter)    # validate type NUMBER
        value = find_attr_value_('c10-parameter', node)
        if value is not None and 'c10-parameter' not in already_processed:
            already_processed.add('c10-parameter')
            value = self.gds_parse_double(value, node, 'c10-parameter')
            self.c10_parameter = value
            self.validate_NUMBER(self.c10_parameter)    # validate type NUMBER
        value = find_attr_value_('c11-parameter', node)
        if value is not None and 'c11-parameter' not in already_processed:
            already_processed.add('c11-parameter')
            value = self.gds_parse_double(value, node, 'c11-parameter')
            self.c11_parameter = value
            self.validate_NUMBER(self.c11_parameter)    # validate type NUMBER
        value = find_attr_value_('d00-parameter', node)
        if value is not None and 'd00-parameter' not in already_processed:
            already_processed.add('d00-parameter')
            value = self.gds_parse_double(value, node, 'd00-parameter')
            self.d00_parameter = value
            self.validate_NUMBER(self.d00_parameter)    # validate type NUMBER
        value = find_attr_value_('d01-parameter', node)
        if value is not None and 'd01-parameter' not in already_processed:
            already_processed.add('d01-parameter')
            value = self.gds_parse_double(value, node, 'd01-parameter')
            self.d01_parameter = value
            self.validate_NUMBER(self.d01_parameter)    # validate type NUMBER
        value = find_attr_value_('d10-parameter', node)
        if value is not None and 'd10-parameter' not in already_processed:
            already_processed.add('d10-parameter')
            value = self.gds_parse_double(value, node, 'd10-parameter')
            self.d10_parameter = value
            self.validate_NUMBER(self.d10_parameter)    # validate type NUMBER
        value = find_attr_value_('d11-parameter', node)
        if value is not None and 'd11-parameter' not in already_processed:
            already_processed.add('d11-parameter')
            value = self.gds_parse_double(value, node, 'd11-parameter')
            self.d11_parameter = value
            self.validate_NUMBER(self.d11_parameter)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class binarySimilarity


class AssociationModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, numberOfTransactions=None, maxNumberOfItemsPerTA=None, avgNumberOfItemsPerTA=None, minimumSupport=None, minimumConfidence=None, lengthLimit=None, numberOfItems=None, numberOfItemsets=None, numberOfRules=None, MiningSchema=None, Output=None, ModelStats=None, LocalTransformations=None, Item=None, Itemset=None, AssociationRule=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.numberOfTransactions = _cast(int, numberOfTransactions)
        self.numberOfTransactions_nsprefix_ = None
        self.maxNumberOfItemsPerTA = _cast(int, maxNumberOfItemsPerTA)
        self.maxNumberOfItemsPerTA_nsprefix_ = None
        self.avgNumberOfItemsPerTA = _cast(float, avgNumberOfItemsPerTA)
        self.avgNumberOfItemsPerTA_nsprefix_ = None
        self.minimumSupport = _cast(float, minimumSupport)
        self.minimumSupport_nsprefix_ = None
        self.minimumConfidence = _cast(float, minimumConfidence)
        self.minimumConfidence_nsprefix_ = None
        self.lengthLimit = _cast(int, lengthLimit)
        self.lengthLimit_nsprefix_ = None
        self.numberOfItems = _cast(int, numberOfItems)
        self.numberOfItems_nsprefix_ = None
        self.numberOfItemsets = _cast(int, numberOfItemsets)
        self.numberOfItemsets_nsprefix_ = None
        self.numberOfRules = _cast(int, numberOfRules)
        self.numberOfRules_nsprefix_ = None
        self.MiningSchema = MiningSchema
        self.MiningSchema_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        if Item is None:
            self.Item = []
        else:
            self.Item = Item
        self.Item_nsprefix_ = None
        if Itemset is None:
            self.Itemset = []
        else:
            self.Itemset = Itemset
        self.Itemset_nsprefix_ = None
        if AssociationRule is None:
            self.AssociationRule = []
        else:
            self.AssociationRule = AssociationRule
        self.AssociationRule_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssociationModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssociationModel.subclass:
            return AssociationModel.subclass(*args_, **kwargs_)
        else:
            return AssociationModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MiningSchema(self):
        return self.MiningSchema
    def set_MiningSchema(self, MiningSchema):
        self.MiningSchema = MiningSchema
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_Item(self):
        return self.Item
    def set_Item(self, Item):
        self.Item = Item
    def add_Item(self, value):
        self.Item.append(value)
    def insert_Item_at(self, index, value):
        self.Item.insert(index, value)
    def replace_Item_at(self, index, value):
        self.Item[index] = value
    def get_Itemset(self):
        return self.Itemset
    def set_Itemset(self, Itemset):
        self.Itemset = Itemset
    def add_Itemset(self, value):
        self.Itemset.append(value)
    def insert_Itemset_at(self, index, value):
        self.Itemset.insert(index, value)
    def replace_Itemset_at(self, index, value):
        self.Itemset[index] = value
    def get_AssociationRule(self):
        return self.AssociationRule
    def set_AssociationRule(self, AssociationRule):
        self.AssociationRule = AssociationRule
    def add_AssociationRule(self, value):
        self.AssociationRule.append(value)
    def insert_AssociationRule_at(self, index, value):
        self.AssociationRule.insert(index, value)
    def replace_AssociationRule_at(self, index, value):
        self.AssociationRule[index] = value
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def get_numberOfTransactions(self):
        return self.numberOfTransactions
    def set_numberOfTransactions(self, numberOfTransactions):
        self.numberOfTransactions = numberOfTransactions
    def get_maxNumberOfItemsPerTA(self):
        return self.maxNumberOfItemsPerTA
    def set_maxNumberOfItemsPerTA(self, maxNumberOfItemsPerTA):
        self.maxNumberOfItemsPerTA = maxNumberOfItemsPerTA
    def get_avgNumberOfItemsPerTA(self):
        return self.avgNumberOfItemsPerTA
    def set_avgNumberOfItemsPerTA(self, avgNumberOfItemsPerTA):
        self.avgNumberOfItemsPerTA = avgNumberOfItemsPerTA
    def get_minimumSupport(self):
        return self.minimumSupport
    def set_minimumSupport(self, minimumSupport):
        self.minimumSupport = minimumSupport
    def get_minimumConfidence(self):
        return self.minimumConfidence
    def set_minimumConfidence(self, minimumConfidence):
        self.minimumConfidence = minimumConfidence
    def get_lengthLimit(self):
        return self.lengthLimit
    def set_lengthLimit(self, lengthLimit):
        self.lengthLimit = lengthLimit
    def get_numberOfItems(self):
        return self.numberOfItems
    def set_numberOfItems(self, numberOfItems):
        self.numberOfItems = numberOfItems
    def get_numberOfItemsets(self):
        return self.numberOfItemsets
    def set_numberOfItemsets(self, numberOfItemsets):
        self.numberOfItemsets = numberOfItemsets
    def get_numberOfRules(self):
        return self.numberOfRules
    def set_numberOfRules(self, numberOfRules):
        self.numberOfRules = numberOfRules
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.LocalTransformations is not None or
            self.Item or
            self.Itemset or
            self.AssociationRule or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='AssociationModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssociationModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AssociationModel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssociationModel')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssociationModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssociationModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.numberOfTransactions is not None and 'numberOfTransactions' not in already_processed:
            already_processed.add('numberOfTransactions')
            outfile.write(' numberOfTransactions="%s"' % self.gds_format_integer(self.numberOfTransactions, input_name='numberOfTransactions'))
        if self.maxNumberOfItemsPerTA is not None and 'maxNumberOfItemsPerTA' not in already_processed:
            already_processed.add('maxNumberOfItemsPerTA')
            outfile.write(' maxNumberOfItemsPerTA="%s"' % self.gds_format_integer(self.maxNumberOfItemsPerTA, input_name='maxNumberOfItemsPerTA'))
        if self.avgNumberOfItemsPerTA is not None and 'avgNumberOfItemsPerTA' not in already_processed:
            already_processed.add('avgNumberOfItemsPerTA')
            outfile.write(' avgNumberOfItemsPerTA="%s"' % self.gds_format_double(self.avgNumberOfItemsPerTA, input_name='avgNumberOfItemsPerTA'))
        if self.minimumSupport is not None and 'minimumSupport' not in already_processed:
            already_processed.add('minimumSupport')
            outfile.write(' minimumSupport="%s"' % self.gds_format_decimal(self.minimumSupport, input_name='minimumSupport'))
        if self.minimumConfidence is not None and 'minimumConfidence' not in already_processed:
            already_processed.add('minimumConfidence')
            outfile.write(' minimumConfidence="%s"' % self.gds_format_decimal(self.minimumConfidence, input_name='minimumConfidence'))
        if self.lengthLimit is not None and 'lengthLimit' not in already_processed:
            already_processed.add('lengthLimit')
            outfile.write(' lengthLimit="%s"' % self.gds_format_integer(self.lengthLimit, input_name='lengthLimit'))
        if self.numberOfItems is not None and 'numberOfItems' not in already_processed:
            already_processed.add('numberOfItems')
            outfile.write(' numberOfItems="%s"' % self.gds_format_integer(self.numberOfItems, input_name='numberOfItems'))
        if self.numberOfItemsets is not None and 'numberOfItemsets' not in already_processed:
            already_processed.add('numberOfItemsets')
            outfile.write(' numberOfItemsets="%s"' % self.gds_format_integer(self.numberOfItemsets, input_name='numberOfItemsets'))
        if self.numberOfRules is not None and 'numberOfRules' not in already_processed:
            already_processed.add('numberOfRules')
            outfile.write(' numberOfRules="%s"' % self.gds_format_integer(self.numberOfRules, input_name='numberOfRules'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='AssociationModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            namespaceprefix_ = self.MiningSchema_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningSchema_nsprefix_) else ''
            self.MiningSchema.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        for Item_ in self.Item:
            namespaceprefix_ = self.Item_nsprefix_ + ':' if (UseCapturedNS_ and self.Item_nsprefix_) else ''
            Item_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Item', pretty_print=pretty_print)
        for Itemset_ in self.Itemset:
            namespaceprefix_ = self.Itemset_nsprefix_ + ':' if (UseCapturedNS_ and self.Itemset_nsprefix_) else ''
            Itemset_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Itemset', pretty_print=pretty_print)
        for AssociationRule_ in self.AssociationRule:
            namespaceprefix_ = self.AssociationRule_nsprefix_ + ':' if (UseCapturedNS_ and self.AssociationRule_nsprefix_) else ''
            AssociationRule_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssociationRule', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('numberOfTransactions', node)
        if value is not None and 'numberOfTransactions' not in already_processed:
            already_processed.add('numberOfTransactions')
            self.numberOfTransactions = self.gds_parse_integer(value, node, 'numberOfTransactions')
            self.validate_INT_NUMBER(self.numberOfTransactions)    # validate type INT-NUMBER
        value = find_attr_value_('maxNumberOfItemsPerTA', node)
        if value is not None and 'maxNumberOfItemsPerTA' not in already_processed:
            already_processed.add('maxNumberOfItemsPerTA')
            self.maxNumberOfItemsPerTA = self.gds_parse_integer(value, node, 'maxNumberOfItemsPerTA')
            self.validate_INT_NUMBER(self.maxNumberOfItemsPerTA)    # validate type INT-NUMBER
        value = find_attr_value_('avgNumberOfItemsPerTA', node)
        if value is not None and 'avgNumberOfItemsPerTA' not in already_processed:
            already_processed.add('avgNumberOfItemsPerTA')
            value = self.gds_parse_double(value, node, 'avgNumberOfItemsPerTA')
            self.avgNumberOfItemsPerTA = value
            self.validate_REAL_NUMBER(self.avgNumberOfItemsPerTA)    # validate type REAL-NUMBER
        value = find_attr_value_('minimumSupport', node)
        if value is not None and 'minimumSupport' not in already_processed:
            already_processed.add('minimumSupport')
            value = self.gds_parse_decimal(value, node, 'minimumSupport')
            self.minimumSupport = value
            self.validate_PROB_NUMBER(self.minimumSupport)    # validate type PROB-NUMBER
        value = find_attr_value_('minimumConfidence', node)
        if value is not None and 'minimumConfidence' not in already_processed:
            already_processed.add('minimumConfidence')
            value = self.gds_parse_decimal(value, node, 'minimumConfidence')
            self.minimumConfidence = value
            self.validate_PROB_NUMBER(self.minimumConfidence)    # validate type PROB-NUMBER
        value = find_attr_value_('lengthLimit', node)
        if value is not None and 'lengthLimit' not in already_processed:
            already_processed.add('lengthLimit')
            self.lengthLimit = self.gds_parse_integer(value, node, 'lengthLimit')
            self.validate_INT_NUMBER(self.lengthLimit)    # validate type INT-NUMBER
        value = find_attr_value_('numberOfItems', node)
        if value is not None and 'numberOfItems' not in already_processed:
            already_processed.add('numberOfItems')
            self.numberOfItems = self.gds_parse_integer(value, node, 'numberOfItems')
            self.validate_INT_NUMBER(self.numberOfItems)    # validate type INT-NUMBER
        value = find_attr_value_('numberOfItemsets', node)
        if value is not None and 'numberOfItemsets' not in already_processed:
            already_processed.add('numberOfItemsets')
            self.numberOfItemsets = self.gds_parse_integer(value, node, 'numberOfItemsets')
            self.validate_INT_NUMBER(self.numberOfItemsets)    # validate type INT-NUMBER
        value = find_attr_value_('numberOfRules', node)
        if value is not None and 'numberOfRules' not in already_processed:
            already_processed.add('numberOfRules')
            self.numberOfRules = self.gds_parse_integer(value, node, 'numberOfRules')
            self.validate_INT_NUMBER(self.numberOfRules)    # validate type INT-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'Item':
            obj_ = Item.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Item.append(obj_)
            obj_.original_tagname_ = 'Item'
        elif nodeName_ == 'Itemset':
            obj_ = Itemset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Itemset.append(obj_)
            obj_.original_tagname_ = 'Itemset'
        elif nodeName_ == 'AssociationRule':
            obj_ = AssociationRule.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssociationRule.append(obj_)
            obj_.original_tagname_ = 'AssociationRule'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class AssociationModel


class Item(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, value=None, mappedValue=None, weight=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.mappedValue = _cast(None, mappedValue)
        self.mappedValue_nsprefix_ = None
        self.weight = _cast(float, weight)
        self.weight_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Item)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Item.subclass:
            return Item.subclass(*args_, **kwargs_)
        else:
            return Item(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_mappedValue(self):
        return self.mappedValue
    def set_mappedValue(self, mappedValue):
        self.mappedValue = mappedValue
    def get_weight(self):
        return self.weight
    def set_weight(self, weight):
        self.weight = weight
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Item', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Item')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Item':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Item')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Item', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Item'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.mappedValue is not None and 'mappedValue' not in already_processed:
            already_processed.add('mappedValue')
            outfile.write(' mappedValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mappedValue), input_name='mappedValue')), ))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight="%s"' % self.gds_format_double(self.weight, input_name='weight'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Item', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('mappedValue', node)
        if value is not None and 'mappedValue' not in already_processed:
            already_processed.add('mappedValue')
            self.mappedValue = value
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            value = self.gds_parse_double(value, node, 'weight')
            self.weight = value
            self.validate_REAL_NUMBER(self.weight)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Item


class Itemset(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, support=None, numberOfItems=None, Extension=None, ItemRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.support = _cast(float, support)
        self.support_nsprefix_ = None
        self.numberOfItems = _cast(int, numberOfItems)
        self.numberOfItems_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if ItemRef is None:
            self.ItemRef = []
        else:
            self.ItemRef = ItemRef
        self.ItemRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Itemset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Itemset.subclass:
            return Itemset.subclass(*args_, **kwargs_)
        else:
            return Itemset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_ItemRef(self):
        return self.ItemRef
    def set_ItemRef(self, ItemRef):
        self.ItemRef = ItemRef
    def add_ItemRef(self, value):
        self.ItemRef.append(value)
    def insert_ItemRef_at(self, index, value):
        self.ItemRef.insert(index, value)
    def replace_ItemRef_at(self, index, value):
        self.ItemRef[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_support(self):
        return self.support
    def set_support(self, support):
        self.support = support
    def get_numberOfItems(self):
        return self.numberOfItems
    def set_numberOfItems(self, numberOfItems):
        self.numberOfItems = numberOfItems
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.ItemRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Itemset', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Itemset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Itemset':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Itemset')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Itemset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Itemset'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.support is not None and 'support' not in already_processed:
            already_processed.add('support')
            outfile.write(' support="%s"' % self.gds_format_decimal(self.support, input_name='support'))
        if self.numberOfItems is not None and 'numberOfItems' not in already_processed:
            already_processed.add('numberOfItems')
            outfile.write(' numberOfItems="%s"' % self.gds_format_integer(self.numberOfItems, input_name='numberOfItems'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Itemset', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for ItemRef_ in self.ItemRef:
            namespaceprefix_ = self.ItemRef_nsprefix_ + ':' if (UseCapturedNS_ and self.ItemRef_nsprefix_) else ''
            ItemRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ItemRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('support', node)
        if value is not None and 'support' not in already_processed:
            already_processed.add('support')
            value = self.gds_parse_decimal(value, node, 'support')
            self.support = value
            self.validate_PROB_NUMBER(self.support)    # validate type PROB-NUMBER
        value = find_attr_value_('numberOfItems', node)
        if value is not None and 'numberOfItems' not in already_processed:
            already_processed.add('numberOfItems')
            self.numberOfItems = self.gds_parse_integer(value, node, 'numberOfItems')
            if self.numberOfItems < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ItemRef':
            obj_ = ItemRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ItemRef.append(obj_)
            obj_.original_tagname_ = 'ItemRef'
# end class Itemset


class ItemRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, itemRef=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.itemRef = _cast(None, itemRef)
        self.itemRef_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ItemRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ItemRef.subclass:
            return ItemRef.subclass(*args_, **kwargs_)
        else:
            return ItemRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_itemRef(self):
        return self.itemRef
    def set_itemRef(self, itemRef):
        self.itemRef = itemRef
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ItemRef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ItemRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ItemRef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ItemRef')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ItemRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ItemRef'):
        if self.itemRef is not None and 'itemRef' not in already_processed:
            already_processed.add('itemRef')
            outfile.write(' itemRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.itemRef), input_name='itemRef')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ItemRef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('itemRef', node)
        if value is not None and 'itemRef' not in already_processed:
            already_processed.add('itemRef')
            self.itemRef = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class ItemRef


class AssociationRule(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, antecedent=None, consequent=None, support=None, confidence=None, lift=None, id=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.antecedent = _cast(None, antecedent)
        self.antecedent_nsprefix_ = None
        self.consequent = _cast(None, consequent)
        self.consequent_nsprefix_ = None
        self.support = _cast(float, support)
        self.support_nsprefix_ = None
        self.confidence = _cast(float, confidence)
        self.confidence_nsprefix_ = None
        self.lift = _cast(float, lift)
        self.lift_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssociationRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssociationRule.subclass:
            return AssociationRule.subclass(*args_, **kwargs_)
        else:
            return AssociationRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_antecedent(self):
        return self.antecedent
    def set_antecedent(self, antecedent):
        self.antecedent = antecedent
    def get_consequent(self):
        return self.consequent
    def set_consequent(self, consequent):
        self.consequent = consequent
    def get_support(self):
        return self.support
    def set_support(self, support):
        self.support = support
    def get_confidence(self):
        return self.confidence
    def set_confidence(self, confidence):
        self.confidence = confidence
    def get_lift(self):
        return self.lift
    def set_lift(self, lift):
        self.lift = lift
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='AssociationRule', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssociationRule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AssociationRule':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssociationRule')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssociationRule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssociationRule'):
        if self.antecedent is not None and 'antecedent' not in already_processed:
            already_processed.add('antecedent')
            outfile.write(' antecedent=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.antecedent), input_name='antecedent')), ))
        if self.consequent is not None and 'consequent' not in already_processed:
            already_processed.add('consequent')
            outfile.write(' consequent=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.consequent), input_name='consequent')), ))
        if self.support is not None and 'support' not in already_processed:
            already_processed.add('support')
            outfile.write(' support="%s"' % self.gds_format_decimal(self.support, input_name='support'))
        if self.confidence is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            outfile.write(' confidence="%s"' % self.gds_format_decimal(self.confidence, input_name='confidence'))
        if self.lift is not None and 'lift' not in already_processed:
            already_processed.add('lift')
            outfile.write(' lift="%s"' % self.gds_format_float(self.lift, input_name='lift'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='AssociationRule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('antecedent', node)
        if value is not None and 'antecedent' not in already_processed:
            already_processed.add('antecedent')
            self.antecedent = value
        value = find_attr_value_('consequent', node)
        if value is not None and 'consequent' not in already_processed:
            already_processed.add('consequent')
            self.consequent = value
        value = find_attr_value_('support', node)
        if value is not None and 'support' not in already_processed:
            already_processed.add('support')
            value = self.gds_parse_decimal(value, node, 'support')
            self.support = value
            self.validate_PROB_NUMBER(self.support)    # validate type PROB-NUMBER
        value = find_attr_value_('confidence', node)
        if value is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            value = self.gds_parse_decimal(value, node, 'confidence')
            self.confidence = value
            self.validate_PROB_NUMBER(self.confidence)    # validate type PROB-NUMBER
        value = find_attr_value_('lift', node)
        if value is not None and 'lift' not in already_processed:
            already_processed.add('lift')
            value = self.gds_parse_float(value, node, 'lift')
            self.lift = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class AssociationRule


class TreeModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, missingValueStrategy='none', missingValuePenalty='1.0', noTrueChildStrategy='returnNullPrediction', splitCharacteristic='multiSplit', MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, Node=None, ModelVerification=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.missingValueStrategy = _cast(None, missingValueStrategy)
        self.missingValueStrategy_nsprefix_ = None
        self.missingValuePenalty = _cast(float, missingValuePenalty)
        self.missingValuePenalty_nsprefix_ = None
        self.noTrueChildStrategy = _cast(None, noTrueChildStrategy)
        self.noTrueChildStrategy_nsprefix_ = None
        self.splitCharacteristic = _cast(None, splitCharacteristic)
        self.splitCharacteristic_nsprefix_ = None
        self.MiningSchema = MiningSchema
        self.MiningSchema_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.ModelExplanation = ModelExplanation
        self.ModelExplanation_nsprefix_ = None
        self.Targets = Targets
        self.Targets_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        self.Node = Node
        self.Node_nsprefix_ = None
        self.ModelVerification = ModelVerification
        self.ModelVerification_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TreeModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TreeModel.subclass:
            return TreeModel.subclass(*args_, **kwargs_)
        else:
            return TreeModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MiningSchema(self):
        return self.MiningSchema
    def set_MiningSchema(self, MiningSchema):
        self.MiningSchema = MiningSchema
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_ModelExplanation(self):
        return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation):
        self.ModelExplanation = ModelExplanation
    def get_Targets(self):
        return self.Targets
    def set_Targets(self, Targets):
        self.Targets = Targets
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_Node(self):
        return self.Node
    def set_Node(self, Node):
        self.Node = Node
    def get_ModelVerification(self):
        return self.ModelVerification
    def set_ModelVerification(self, ModelVerification):
        self.ModelVerification = ModelVerification
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def get_missingValueStrategy(self):
        return self.missingValueStrategy
    def set_missingValueStrategy(self, missingValueStrategy):
        self.missingValueStrategy = missingValueStrategy
    def get_missingValuePenalty(self):
        return self.missingValuePenalty
    def set_missingValuePenalty(self, missingValuePenalty):
        self.missingValuePenalty = missingValuePenalty
    def get_noTrueChildStrategy(self):
        return self.noTrueChildStrategy
    def set_noTrueChildStrategy(self, noTrueChildStrategy):
        self.noTrueChildStrategy = noTrueChildStrategy
    def get_splitCharacteristic(self):
        return self.splitCharacteristic
    def set_splitCharacteristic(self, splitCharacteristic):
        self.splitCharacteristic = splitCharacteristic
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_MISSING_VALUE_STRATEGY(self, value):
        # Validate type MISSING-VALUE-STRATEGY, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['lastPrediction', 'nullPrediction', 'defaultChild', 'weightedConfidence', 'aggregateNodes', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MISSING-VALUE-STRATEGY' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_NO_TRUE_CHILD_STRATEGY(self, value):
        # Validate type NO-TRUE-CHILD-STRATEGY, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['returnNullPrediction', 'returnLastPrediction']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NO-TRUE-CHILD-STRATEGY' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_splitCharacteristicType(self, value):
        # Validate type splitCharacteristicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['binarySplit', 'multiSplit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on splitCharacteristicType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.Node is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TreeModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TreeModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TreeModel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TreeModel')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TreeModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TreeModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.missingValueStrategy != "none" and 'missingValueStrategy' not in already_processed:
            already_processed.add('missingValueStrategy')
            outfile.write(' missingValueStrategy=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.missingValueStrategy), input_name='missingValueStrategy')), ))
        if self.missingValuePenalty != 1.0 and 'missingValuePenalty' not in already_processed:
            already_processed.add('missingValuePenalty')
            outfile.write(' missingValuePenalty="%s"' % self.gds_format_decimal(self.missingValuePenalty, input_name='missingValuePenalty'))
        if self.noTrueChildStrategy != "returnNullPrediction" and 'noTrueChildStrategy' not in already_processed:
            already_processed.add('noTrueChildStrategy')
            outfile.write(' noTrueChildStrategy=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.noTrueChildStrategy), input_name='noTrueChildStrategy')), ))
        if self.splitCharacteristic != "multiSplit" and 'splitCharacteristic' not in already_processed:
            already_processed.add('splitCharacteristic')
            outfile.write(' splitCharacteristic=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.splitCharacteristic), input_name='splitCharacteristic')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TreeModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            namespaceprefix_ = self.MiningSchema_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningSchema_nsprefix_) else ''
            self.MiningSchema.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            namespaceprefix_ = self.ModelExplanation_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelExplanation_nsprefix_) else ''
            self.ModelExplanation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            namespaceprefix_ = self.Targets_nsprefix_ + ':' if (UseCapturedNS_ and self.Targets_nsprefix_) else ''
            self.Targets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        if self.Node is not None:
            namespaceprefix_ = self.Node_nsprefix_ + ':' if (UseCapturedNS_ and self.Node_nsprefix_) else ''
            self.Node.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Node', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            namespaceprefix_ = self.ModelVerification_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelVerification_nsprefix_) else ''
            self.ModelVerification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('missingValueStrategy', node)
        if value is not None and 'missingValueStrategy' not in already_processed:
            already_processed.add('missingValueStrategy')
            self.missingValueStrategy = value
            self.validate_MISSING_VALUE_STRATEGY(self.missingValueStrategy)    # validate type MISSING-VALUE-STRATEGY
        value = find_attr_value_('missingValuePenalty', node)
        if value is not None and 'missingValuePenalty' not in already_processed:
            already_processed.add('missingValuePenalty')
            value = self.gds_parse_decimal(value, node, 'missingValuePenalty')
            self.missingValuePenalty = value
            self.validate_PROB_NUMBER(self.missingValuePenalty)    # validate type PROB-NUMBER
        value = find_attr_value_('noTrueChildStrategy', node)
        if value is not None and 'noTrueChildStrategy' not in already_processed:
            already_processed.add('noTrueChildStrategy')
            self.noTrueChildStrategy = value
            self.validate_NO_TRUE_CHILD_STRATEGY(self.noTrueChildStrategy)    # validate type NO-TRUE-CHILD-STRATEGY
        value = find_attr_value_('splitCharacteristic', node)
        if value is not None and 'splitCharacteristic' not in already_processed:
            already_processed.add('splitCharacteristic')
            self.splitCharacteristic = value
            self.validate_splitCharacteristicType(self.splitCharacteristic)    # validate type splitCharacteristicType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'Node':
            obj_ = Node.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Node = obj_
            obj_.original_tagname_ = 'Node'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TreeModel


class Node(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, score=None, recordCount=None, defaultChild=None, SimplePredicate=None, CompoundPredicate=None, SimpleSetPredicate=None, True_=None, False_=None, Partition=None, ScoreDistribution=None, Node_member=None, Extension=None, Regression=None, DecisionTree=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.score = _cast(None, score)
        self.score_nsprefix_ = None
        self.recordCount = _cast(float, recordCount)
        self.recordCount_nsprefix_ = None
        self.defaultChild = _cast(None, defaultChild)
        self.defaultChild_nsprefix_ = None
        self.SimplePredicate = SimplePredicate
        self.SimplePredicate_nsprefix_ = None
        self.CompoundPredicate = CompoundPredicate
        self.CompoundPredicate_nsprefix_ = None
        self.SimpleSetPredicate = SimpleSetPredicate
        self.SimpleSetPredicate_nsprefix_ = None
        self.True_ = True_
        self.True__nsprefix_ = None
        self.False_ = False_
        self.False__nsprefix_ = None
        self.Partition = Partition
        self.Partition_nsprefix_ = None
        if ScoreDistribution is None:
            self.ScoreDistribution = []
        else:
            self.ScoreDistribution = ScoreDistribution
        self.ScoreDistribution_nsprefix_ = None
        if Node_member is None:
            self.Node = []
        else:
            self.Node = Node_member
        self.Node_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Regression = Regression
        self.Regression_nsprefix_ = None
        self.DecisionTree = DecisionTree
        self.DecisionTree_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Node)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Node.subclass:
            return Node.subclass(*args_, **kwargs_)
        else:
            return Node(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SimplePredicate(self):
        return self.SimplePredicate
    def set_SimplePredicate(self, SimplePredicate):
        self.SimplePredicate = SimplePredicate
    def get_CompoundPredicate(self):
        return self.CompoundPredicate
    def set_CompoundPredicate(self, CompoundPredicate):
        self.CompoundPredicate = CompoundPredicate
    def get_SimpleSetPredicate(self):
        return self.SimpleSetPredicate
    def set_SimpleSetPredicate(self, SimpleSetPredicate):
        self.SimpleSetPredicate = SimpleSetPredicate
    def get_True(self):
        return self.True_
    def set_True(self, True_):
        self.True_ = True_
    def get_False(self):
        return self.False_
    def set_False(self, False_):
        self.False_ = False_
    def get_Partition(self):
        return self.Partition
    def set_Partition(self, Partition):
        self.Partition = Partition
    def get_ScoreDistribution(self):
        return self.ScoreDistribution
    def set_ScoreDistribution(self, ScoreDistribution):
        self.ScoreDistribution = ScoreDistribution
    def add_ScoreDistribution(self, value):
        self.ScoreDistribution.append(value)
    def insert_ScoreDistribution_at(self, index, value):
        self.ScoreDistribution.insert(index, value)
    def replace_ScoreDistribution_at(self, index, value):
        self.ScoreDistribution[index] = value
    def get_Node(self):
        return self.Node
    def set_Node(self, Node):
        self.Node = Node
    def add_Node(self, value):
        self.Node.append(value)
    def insert_Node_at(self, index, value):
        self.Node.insert(index, value)
    def replace_Node_at(self, index, value):
        self.Node[index] = value
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Regression(self):
        return self.Regression
    def set_Regression(self, Regression):
        self.Regression = Regression
    def get_DecisionTree(self):
        return self.DecisionTree
    def set_DecisionTree(self, DecisionTree):
        self.DecisionTree = DecisionTree
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_score(self):
        return self.score
    def set_score(self, score):
        self.score = score
    def get_recordCount(self):
        return self.recordCount
    def set_recordCount(self, recordCount):
        self.recordCount = recordCount
    def get_defaultChild(self):
        return self.defaultChild
    def set_defaultChild(self, defaultChild):
        self.defaultChild = defaultChild
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.SimplePredicate is not None or
            self.CompoundPredicate is not None or
            self.SimpleSetPredicate is not None or
            self.True_ is not None or
            self.False_ is not None or
            self.Partition is not None or
            self.ScoreDistribution or
            self.Node or
            self.Extension or
            self.Regression is not None or
            self.DecisionTree is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Node', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Node')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Node':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Node')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Node', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Node'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.score is not None and 'score' not in already_processed:
            already_processed.add('score')
            outfile.write(' score=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.score), input_name='score')), ))
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            outfile.write(' recordCount="%s"' % self.gds_format_double(self.recordCount, input_name='recordCount'))
        if self.defaultChild is not None and 'defaultChild' not in already_processed:
            already_processed.add('defaultChild')
            outfile.write(' defaultChild=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.defaultChild), input_name='defaultChild')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Node', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SimplePredicate is not None:
            namespaceprefix_ = self.SimplePredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.SimplePredicate_nsprefix_) else ''
            self.SimplePredicate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SimplePredicate', pretty_print=pretty_print)
        if self.CompoundPredicate is not None:
            namespaceprefix_ = self.CompoundPredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.CompoundPredicate_nsprefix_) else ''
            self.CompoundPredicate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CompoundPredicate', pretty_print=pretty_print)
        if self.SimpleSetPredicate is not None:
            namespaceprefix_ = self.SimpleSetPredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.SimpleSetPredicate_nsprefix_) else ''
            self.SimpleSetPredicate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SimpleSetPredicate', pretty_print=pretty_print)
        if self.True_ is not None:
            namespaceprefix_ = self.True__nsprefix_ + ':' if (UseCapturedNS_ and self.True__nsprefix_) else ''
            self.True_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='True', pretty_print=pretty_print)
        if self.False_ is not None:
            namespaceprefix_ = self.False__nsprefix_ + ':' if (UseCapturedNS_ and self.False__nsprefix_) else ''
            self.False_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='False', pretty_print=pretty_print)
        if self.Partition is not None:
            namespaceprefix_ = self.Partition_nsprefix_ + ':' if (UseCapturedNS_ and self.Partition_nsprefix_) else ''
            self.Partition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Partition', pretty_print=pretty_print)
        for ScoreDistribution_ in self.ScoreDistribution:
            namespaceprefix_ = self.ScoreDistribution_nsprefix_ + ':' if (UseCapturedNS_ and self.ScoreDistribution_nsprefix_) else ''
            ScoreDistribution_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ScoreDistribution', pretty_print=pretty_print)
        for Node_ in self.Node:
            namespaceprefix_ = self.Node_nsprefix_ + ':' if (UseCapturedNS_ and self.Node_nsprefix_) else ''
            Node_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Node', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Regression is not None:
            namespaceprefix_ = self.Regression_nsprefix_ + ':' if (UseCapturedNS_ and self.Regression_nsprefix_) else ''
            self.Regression.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Regression', pretty_print=pretty_print)
        if self.DecisionTree is not None:
            namespaceprefix_ = self.DecisionTree_nsprefix_ + ':' if (UseCapturedNS_ and self.DecisionTree_nsprefix_) else ''
            self.DecisionTree.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DecisionTree', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('score', node)
        if value is not None and 'score' not in already_processed:
            already_processed.add('score')
            self.score = value
        value = find_attr_value_('recordCount', node)
        if value is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            value = self.gds_parse_double(value, node, 'recordCount')
            self.recordCount = value
            self.validate_NUMBER(self.recordCount)    # validate type NUMBER
        value = find_attr_value_('defaultChild', node)
        if value is not None and 'defaultChild' not in already_processed:
            already_processed.add('defaultChild')
            self.defaultChild = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SimplePredicate':
            obj_ = SimplePredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SimplePredicate = obj_
            obj_.original_tagname_ = 'SimplePredicate'
        elif nodeName_ == 'CompoundPredicate':
            obj_ = CompoundPredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CompoundPredicate = obj_
            obj_.original_tagname_ = 'CompoundPredicate'
        elif nodeName_ == 'SimpleSetPredicate':
            obj_ = SimpleSetPredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SimpleSetPredicate = obj_
            obj_.original_tagname_ = 'SimpleSetPredicate'
        elif nodeName_ == 'True':
            obj_ = True_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.True_ = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            obj_ = False_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.False_ = obj_
            obj_.original_tagname_ = 'False'
        elif nodeName_ == 'Partition':
            obj_ = Partition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Partition = obj_
            obj_.original_tagname_ = 'Partition'
        elif nodeName_ == 'ScoreDistribution':
            obj_ = ScoreDistribution.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ScoreDistribution.append(obj_)
            obj_.original_tagname_ = 'ScoreDistribution'
        elif nodeName_ == 'Node':
            obj_ = Node.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Node.append(obj_)
            obj_.original_tagname_ = 'Node'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Regression':
            obj_ = Regression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Regression = obj_
            obj_.original_tagname_ = 'Regression'
        elif nodeName_ == 'DecisionTree':
            obj_ = DecisionTree.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DecisionTree = obj_
            obj_.original_tagname_ = 'DecisionTree'
# end class Node


class SimplePredicate(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, field=None, operator=None, value=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimplePredicate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimplePredicate.subclass:
            return SimplePredicate.subclass(*args_, **kwargs_)
        else:
            return SimplePredicate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_operatorType(self, value):
        # Validate type operatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['equal', 'notEqual', 'lessThan', 'lessOrEqual', 'greaterThan', 'greaterOrEqual', 'isMissing', 'isNotMissing']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on operatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SimplePredicate', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SimplePredicate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SimplePredicate':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SimplePredicate')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SimplePredicate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SimplePredicate'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.operator), input_name='operator')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SimplePredicate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
            self.validate_operatorType(self.operator)    # validate type operatorType
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SimplePredicate


class CompoundPredicate(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, booleanOperator=None, Extension=None, SimplePredicate=None, CompoundPredicate_member=None, SimpleSetPredicate=None, True_=None, False_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.booleanOperator = _cast(None, booleanOperator)
        self.booleanOperator_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if SimplePredicate is None:
            self.SimplePredicate = []
        else:
            self.SimplePredicate = SimplePredicate
        self.SimplePredicate_nsprefix_ = None
        if CompoundPredicate_member is None:
            self.CompoundPredicate = []
        else:
            self.CompoundPredicate = CompoundPredicate_member
        self.CompoundPredicate_nsprefix_ = None
        if SimpleSetPredicate is None:
            self.SimpleSetPredicate = []
        else:
            self.SimpleSetPredicate = SimpleSetPredicate
        self.SimpleSetPredicate_nsprefix_ = None
        if True_ is None:
            self.True_ = []
        else:
            self.True_ = True_
        self.True__nsprefix_ = None
        if False_ is None:
            self.False_ = []
        else:
            self.False_ = False_
        self.False__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompoundPredicate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompoundPredicate.subclass:
            return CompoundPredicate.subclass(*args_, **kwargs_)
        else:
            return CompoundPredicate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_SimplePredicate(self):
        return self.SimplePredicate
    def set_SimplePredicate(self, SimplePredicate):
        self.SimplePredicate = SimplePredicate
    def add_SimplePredicate(self, value):
        self.SimplePredicate.append(value)
    def insert_SimplePredicate_at(self, index, value):
        self.SimplePredicate.insert(index, value)
    def replace_SimplePredicate_at(self, index, value):
        self.SimplePredicate[index] = value
    def get_CompoundPredicate(self):
        return self.CompoundPredicate
    def set_CompoundPredicate(self, CompoundPredicate):
        self.CompoundPredicate = CompoundPredicate
    def add_CompoundPredicate(self, value):
        self.CompoundPredicate.append(value)
    def insert_CompoundPredicate_at(self, index, value):
        self.CompoundPredicate.insert(index, value)
    def replace_CompoundPredicate_at(self, index, value):
        self.CompoundPredicate[index] = value
    def get_SimpleSetPredicate(self):
        return self.SimpleSetPredicate
    def set_SimpleSetPredicate(self, SimpleSetPredicate):
        self.SimpleSetPredicate = SimpleSetPredicate
    def add_SimpleSetPredicate(self, value):
        self.SimpleSetPredicate.append(value)
    def insert_SimpleSetPredicate_at(self, index, value):
        self.SimpleSetPredicate.insert(index, value)
    def replace_SimpleSetPredicate_at(self, index, value):
        self.SimpleSetPredicate[index] = value
    def get_True(self):
        return self.True_
    def set_True(self, True_):
        self.True_ = True_
    def add_True(self, value):
        self.True_.append(value)
    def insert_True_at(self, index, value):
        self.True_.insert(index, value)
    def replace_True_at(self, index, value):
        self.True_[index] = value
    def get_False(self):
        return self.False_
    def set_False(self, False_):
        self.False_ = False_
    def add_False(self, value):
        self.False_.append(value)
    def insert_False_at(self, index, value):
        self.False_.insert(index, value)
    def replace_False_at(self, index, value):
        self.False_[index] = value
    def get_booleanOperator(self):
        return self.booleanOperator
    def set_booleanOperator(self, booleanOperator):
        self.booleanOperator = booleanOperator
    def validate_booleanOperatorType(self, value):
        # Validate type booleanOperatorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['or', 'and', 'xor', 'surrogate']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on booleanOperatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.SimplePredicate or
            self.CompoundPredicate or
            self.SimpleSetPredicate or
            self.True_ or
            self.False_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CompoundPredicate', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompoundPredicate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CompoundPredicate':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompoundPredicate')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CompoundPredicate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CompoundPredicate'):
        if self.booleanOperator is not None and 'booleanOperator' not in already_processed:
            already_processed.add('booleanOperator')
            outfile.write(' booleanOperator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.booleanOperator), input_name='booleanOperator')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CompoundPredicate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for SimplePredicate_ in self.SimplePredicate:
            namespaceprefix_ = self.SimplePredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.SimplePredicate_nsprefix_) else ''
            SimplePredicate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SimplePredicate', pretty_print=pretty_print)
        for CompoundPredicate_ in self.CompoundPredicate:
            namespaceprefix_ = self.CompoundPredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.CompoundPredicate_nsprefix_) else ''
            CompoundPredicate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CompoundPredicate', pretty_print=pretty_print)
        for SimpleSetPredicate_ in self.SimpleSetPredicate:
            namespaceprefix_ = self.SimpleSetPredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.SimpleSetPredicate_nsprefix_) else ''
            SimpleSetPredicate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SimpleSetPredicate', pretty_print=pretty_print)
        for True_ in self.True_:
            namespaceprefix_ = self.True__nsprefix_ + ':' if (UseCapturedNS_ and self.True__nsprefix_) else ''
            True_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='True', pretty_print=pretty_print)
        for False_ in self.False_:
            namespaceprefix_ = self.False__nsprefix_ + ':' if (UseCapturedNS_ and self.False__nsprefix_) else ''
            False_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='False', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('booleanOperator', node)
        if value is not None and 'booleanOperator' not in already_processed:
            already_processed.add('booleanOperator')
            self.booleanOperator = value
            self.validate_booleanOperatorType(self.booleanOperator)    # validate type booleanOperatorType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SimplePredicate':
            obj_ = SimplePredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SimplePredicate.append(obj_)
            obj_.original_tagname_ = 'SimplePredicate'
        elif nodeName_ == 'CompoundPredicate':
            obj_ = CompoundPredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CompoundPredicate.append(obj_)
            obj_.original_tagname_ = 'CompoundPredicate'
        elif nodeName_ == 'SimpleSetPredicate':
            obj_ = SimpleSetPredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SimpleSetPredicate.append(obj_)
            obj_.original_tagname_ = 'SimpleSetPredicate'
        elif nodeName_ == 'True':
            obj_ = True_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.True_.append(obj_)
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            obj_ = False_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.False_.append(obj_)
            obj_.original_tagname_ = 'False'
# end class CompoundPredicate


class SimpleSetPredicate(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, field=None, booleanOperator=None, Extension=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        self.booleanOperator = _cast(None, booleanOperator)
        self.booleanOperator_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleSetPredicate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleSetPredicate.subclass:
            return SimpleSetPredicate.subclass(*args_, **kwargs_)
        else:
            return SimpleSetPredicate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_booleanOperator(self):
        return self.booleanOperator
    def set_booleanOperator(self, booleanOperator):
        self.booleanOperator = booleanOperator
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_booleanOperatorType4(self, value):
        # Validate type booleanOperatorType4, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['isIn', 'isNotIn']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on booleanOperatorType4' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SimpleSetPredicate', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SimpleSetPredicate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SimpleSetPredicate':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SimpleSetPredicate')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SimpleSetPredicate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SimpleSetPredicate'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.booleanOperator is not None and 'booleanOperator' not in already_processed:
            already_processed.add('booleanOperator')
            outfile.write(' booleanOperator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.booleanOperator), input_name='booleanOperator')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SimpleSetPredicate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('booleanOperator', node)
        if value is not None and 'booleanOperator' not in already_processed:
            already_processed.add('booleanOperator')
            self.booleanOperator = value
            self.validate_booleanOperatorType4(self.booleanOperator)    # validate type booleanOperatorType4
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class SimpleSetPredicate


class True_(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, True_)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if True_.subclass:
            return True_.subclass(*args_, **kwargs_)
        else:
            return True_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='True', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('True')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'True':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='True')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='True', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='True'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='True', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class True_


class False_(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, False_)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if False_.subclass:
            return False_.subclass(*args_, **kwargs_)
        else:
            return False_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='False', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('False')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'False':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='False')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='False', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='False'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='False', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class False_


class ScoreDistribution(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value=None, recordCount=None, confidence=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.recordCount = _cast(float, recordCount)
        self.recordCount_nsprefix_ = None
        self.confidence = _cast(float, confidence)
        self.confidence_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScoreDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScoreDistribution.subclass:
            return ScoreDistribution.subclass(*args_, **kwargs_)
        else:
            return ScoreDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_recordCount(self):
        return self.recordCount
    def set_recordCount(self, recordCount):
        self.recordCount = recordCount
    def get_confidence(self):
        return self.confidence
    def set_confidence(self, confidence):
        self.confidence = confidence
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ScoreDistribution', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ScoreDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ScoreDistribution':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ScoreDistribution')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ScoreDistribution', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ScoreDistribution'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            outfile.write(' recordCount="%s"' % self.gds_format_double(self.recordCount, input_name='recordCount'))
        if self.confidence is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            outfile.write(' confidence="%s"' % self.gds_format_decimal(self.confidence, input_name='confidence'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ScoreDistribution', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('recordCount', node)
        if value is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            value = self.gds_parse_double(value, node, 'recordCount')
            self.recordCount = value
            self.validate_NUMBER(self.recordCount)    # validate type NUMBER
        value = find_attr_value_('confidence', node)
        if value is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            value = self.gds_parse_decimal(value, node, 'confidence')
            self.confidence = value
            self.validate_PROB_NUMBER(self.confidence)    # validate type PROB-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class ScoreDistribution


class RegressionModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, modelType=None, targetFieldName=None, normalizationMethod='none', MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, RegressionTable=None, ModelVerification=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.modelType = _cast(None, modelType)
        self.modelType_nsprefix_ = None
        self.targetFieldName = _cast(None, targetFieldName)
        self.targetFieldName_nsprefix_ = None
        self.normalizationMethod = _cast(None, normalizationMethod)
        self.normalizationMethod_nsprefix_ = None
        self.MiningSchema = MiningSchema
        self.MiningSchema_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.ModelExplanation = ModelExplanation
        self.ModelExplanation_nsprefix_ = None
        self.Targets = Targets
        self.Targets_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        if RegressionTable is None:
            self.RegressionTable = []
        else:
            self.RegressionTable = RegressionTable
        self.RegressionTable_nsprefix_ = None
        self.ModelVerification = ModelVerification
        self.ModelVerification_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegressionModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegressionModel.subclass:
            return RegressionModel.subclass(*args_, **kwargs_)
        else:
            return RegressionModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MiningSchema(self):
        return self.MiningSchema
    def set_MiningSchema(self, MiningSchema):
        self.MiningSchema = MiningSchema
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_ModelExplanation(self):
        return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation):
        self.ModelExplanation = ModelExplanation
    def get_Targets(self):
        return self.Targets
    def set_Targets(self, Targets):
        self.Targets = Targets
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_RegressionTable(self):
        return self.RegressionTable
    def set_RegressionTable(self, RegressionTable):
        self.RegressionTable = RegressionTable
    def add_RegressionTable(self, value):
        self.RegressionTable.append(value)
    def insert_RegressionTable_at(self, index, value):
        self.RegressionTable.insert(index, value)
    def replace_RegressionTable_at(self, index, value):
        self.RegressionTable[index] = value
    def get_ModelVerification(self):
        return self.ModelVerification
    def set_ModelVerification(self, ModelVerification):
        self.ModelVerification = ModelVerification
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def get_modelType(self):
        return self.modelType
    def set_modelType(self, modelType):
        self.modelType = modelType
    def get_targetFieldName(self):
        return self.targetFieldName
    def set_targetFieldName(self, targetFieldName):
        self.targetFieldName = targetFieldName
    def get_normalizationMethod(self):
        return self.normalizationMethod
    def set_normalizationMethod(self, normalizationMethod):
        self.normalizationMethod = normalizationMethod
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_modelTypeType(self, value):
        # Validate type modelTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['linearRegression', 'stepwisePolynomialRegression', 'logisticRegression']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on modelTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REGRESSIONNORMALIZATIONMETHOD(self, value):
        # Validate type REGRESSIONNORMALIZATIONMETHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'simplemax', 'softmax', 'logit', 'probit', 'cloglog', 'exp', 'loglog', 'cauchit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on REGRESSIONNORMALIZATIONMETHOD' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.RegressionTable or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RegressionModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegressionModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RegressionModel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RegressionModel')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RegressionModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RegressionModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.modelType is not None and 'modelType' not in already_processed:
            already_processed.add('modelType')
            outfile.write(' modelType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelType), input_name='modelType')), ))
        if self.targetFieldName is not None and 'targetFieldName' not in already_processed:
            already_processed.add('targetFieldName')
            outfile.write(' targetFieldName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetFieldName), input_name='targetFieldName')), ))
        if self.normalizationMethod != "none" and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            outfile.write(' normalizationMethod=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.normalizationMethod), input_name='normalizationMethod')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RegressionModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            namespaceprefix_ = self.MiningSchema_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningSchema_nsprefix_) else ''
            self.MiningSchema.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            namespaceprefix_ = self.ModelExplanation_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelExplanation_nsprefix_) else ''
            self.ModelExplanation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            namespaceprefix_ = self.Targets_nsprefix_ + ':' if (UseCapturedNS_ and self.Targets_nsprefix_) else ''
            self.Targets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        for RegressionTable_ in self.RegressionTable:
            namespaceprefix_ = self.RegressionTable_nsprefix_ + ':' if (UseCapturedNS_ and self.RegressionTable_nsprefix_) else ''
            RegressionTable_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RegressionTable', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            namespaceprefix_ = self.ModelVerification_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelVerification_nsprefix_) else ''
            self.ModelVerification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('modelType', node)
        if value is not None and 'modelType' not in already_processed:
            already_processed.add('modelType')
            self.modelType = value
            self.validate_modelTypeType(self.modelType)    # validate type modelTypeType
        value = find_attr_value_('targetFieldName', node)
        if value is not None and 'targetFieldName' not in already_processed:
            already_processed.add('targetFieldName')
            self.targetFieldName = value
            self.validate_FIELD_NAME(self.targetFieldName)    # validate type FIELD-NAME
        value = find_attr_value_('normalizationMethod', node)
        if value is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            self.normalizationMethod = value
            self.validate_REGRESSIONNORMALIZATIONMETHOD(self.normalizationMethod)    # validate type REGRESSIONNORMALIZATIONMETHOD
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'RegressionTable':
            obj_ = RegressionTable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RegressionTable.append(obj_)
            obj_.original_tagname_ = 'RegressionTable'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class RegressionModel


class RegressionTable(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, intercept=None, targetCategory=None, Extension=None, NumericPredictor=None, CategoricalPredictor=None, PredictorTerm=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.intercept = _cast(float, intercept)
        self.intercept_nsprefix_ = None
        self.targetCategory = _cast(None, targetCategory)
        self.targetCategory_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if NumericPredictor is None:
            self.NumericPredictor = []
        else:
            self.NumericPredictor = NumericPredictor
        self.NumericPredictor_nsprefix_ = None
        if CategoricalPredictor is None:
            self.CategoricalPredictor = []
        else:
            self.CategoricalPredictor = CategoricalPredictor
        self.CategoricalPredictor_nsprefix_ = None
        if PredictorTerm is None:
            self.PredictorTerm = []
        else:
            self.PredictorTerm = PredictorTerm
        self.PredictorTerm_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegressionTable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegressionTable.subclass:
            return RegressionTable.subclass(*args_, **kwargs_)
        else:
            return RegressionTable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_NumericPredictor(self):
        return self.NumericPredictor
    def set_NumericPredictor(self, NumericPredictor):
        self.NumericPredictor = NumericPredictor
    def add_NumericPredictor(self, value):
        self.NumericPredictor.append(value)
    def insert_NumericPredictor_at(self, index, value):
        self.NumericPredictor.insert(index, value)
    def replace_NumericPredictor_at(self, index, value):
        self.NumericPredictor[index] = value
    def get_CategoricalPredictor(self):
        return self.CategoricalPredictor
    def set_CategoricalPredictor(self, CategoricalPredictor):
        self.CategoricalPredictor = CategoricalPredictor
    def add_CategoricalPredictor(self, value):
        self.CategoricalPredictor.append(value)
    def insert_CategoricalPredictor_at(self, index, value):
        self.CategoricalPredictor.insert(index, value)
    def replace_CategoricalPredictor_at(self, index, value):
        self.CategoricalPredictor[index] = value
    def get_PredictorTerm(self):
        return self.PredictorTerm
    def set_PredictorTerm(self, PredictorTerm):
        self.PredictorTerm = PredictorTerm
    def add_PredictorTerm(self, value):
        self.PredictorTerm.append(value)
    def insert_PredictorTerm_at(self, index, value):
        self.PredictorTerm.insert(index, value)
    def replace_PredictorTerm_at(self, index, value):
        self.PredictorTerm[index] = value
    def get_intercept(self):
        return self.intercept
    def set_intercept(self, intercept):
        self.intercept = intercept
    def get_targetCategory(self):
        return self.targetCategory
    def set_targetCategory(self, targetCategory):
        self.targetCategory = targetCategory
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.NumericPredictor or
            self.CategoricalPredictor or
            self.PredictorTerm
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RegressionTable', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegressionTable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RegressionTable':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RegressionTable')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RegressionTable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RegressionTable'):
        if self.intercept is not None and 'intercept' not in already_processed:
            already_processed.add('intercept')
            outfile.write(' intercept="%s"' % self.gds_format_double(self.intercept, input_name='intercept'))
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            outfile.write(' targetCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetCategory), input_name='targetCategory')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RegressionTable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for NumericPredictor_ in self.NumericPredictor:
            namespaceprefix_ = self.NumericPredictor_nsprefix_ + ':' if (UseCapturedNS_ and self.NumericPredictor_nsprefix_) else ''
            NumericPredictor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NumericPredictor', pretty_print=pretty_print)
        for CategoricalPredictor_ in self.CategoricalPredictor:
            namespaceprefix_ = self.CategoricalPredictor_nsprefix_ + ':' if (UseCapturedNS_ and self.CategoricalPredictor_nsprefix_) else ''
            CategoricalPredictor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CategoricalPredictor', pretty_print=pretty_print)
        for PredictorTerm_ in self.PredictorTerm:
            namespaceprefix_ = self.PredictorTerm_nsprefix_ + ':' if (UseCapturedNS_ and self.PredictorTerm_nsprefix_) else ''
            PredictorTerm_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PredictorTerm', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('intercept', node)
        if value is not None and 'intercept' not in already_processed:
            already_processed.add('intercept')
            value = self.gds_parse_double(value, node, 'intercept')
            self.intercept = value
            self.validate_REAL_NUMBER(self.intercept)    # validate type REAL-NUMBER
        value = find_attr_value_('targetCategory', node)
        if value is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            self.targetCategory = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'NumericPredictor':
            obj_ = NumericPredictor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NumericPredictor.append(obj_)
            obj_.original_tagname_ = 'NumericPredictor'
        elif nodeName_ == 'CategoricalPredictor':
            obj_ = CategoricalPredictor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CategoricalPredictor.append(obj_)
            obj_.original_tagname_ = 'CategoricalPredictor'
        elif nodeName_ == 'PredictorTerm':
            obj_ = PredictorTerm.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PredictorTerm.append(obj_)
            obj_.original_tagname_ = 'PredictorTerm'
# end class RegressionTable


class NumericPredictor(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, exponent='1', coefficient=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.exponent = _cast(int, exponent)
        self.exponent_nsprefix_ = None
        self.coefficient = _cast(float, coefficient)
        self.coefficient_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumericPredictor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumericPredictor.subclass:
            return NumericPredictor.subclass(*args_, **kwargs_)
        else:
            return NumericPredictor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_exponent(self):
        return self.exponent
    def set_exponent(self, exponent):
        self.exponent = exponent
    def get_coefficient(self):
        return self.coefficient
    def set_coefficient(self, coefficient):
        self.coefficient = coefficient
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NumericPredictor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumericPredictor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NumericPredictor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumericPredictor')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NumericPredictor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NumericPredictor'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.exponent != 1 and 'exponent' not in already_processed:
            already_processed.add('exponent')
            outfile.write(' exponent="%s"' % self.gds_format_integer(self.exponent, input_name='exponent'))
        if self.coefficient is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            outfile.write(' coefficient="%s"' % self.gds_format_double(self.coefficient, input_name='coefficient'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NumericPredictor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('exponent', node)
        if value is not None and 'exponent' not in already_processed:
            already_processed.add('exponent')
            self.exponent = self.gds_parse_integer(value, node, 'exponent')
            self.validate_INT_NUMBER(self.exponent)    # validate type INT-NUMBER
        value = find_attr_value_('coefficient', node)
        if value is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            value = self.gds_parse_double(value, node, 'coefficient')
            self.coefficient = value
            self.validate_REAL_NUMBER(self.coefficient)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class NumericPredictor


class CategoricalPredictor(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, coefficient=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.coefficient = _cast(float, coefficient)
        self.coefficient_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CategoricalPredictor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CategoricalPredictor.subclass:
            return CategoricalPredictor.subclass(*args_, **kwargs_)
        else:
            return CategoricalPredictor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_coefficient(self):
        return self.coefficient
    def set_coefficient(self, coefficient):
        self.coefficient = coefficient
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CategoricalPredictor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CategoricalPredictor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CategoricalPredictor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CategoricalPredictor')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CategoricalPredictor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CategoricalPredictor'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.coefficient is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            outfile.write(' coefficient="%s"' % self.gds_format_double(self.coefficient, input_name='coefficient'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CategoricalPredictor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('coefficient', node)
        if value is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            value = self.gds_parse_double(value, node, 'coefficient')
            self.coefficient = value
            self.validate_REAL_NUMBER(self.coefficient)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class CategoricalPredictor


class PredictorTerm(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, coefficient=None, Extension=None, FieldRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.coefficient = _cast(float, coefficient)
        self.coefficient_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if FieldRef is None:
            self.FieldRef = []
        else:
            self.FieldRef = FieldRef
        self.FieldRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PredictorTerm)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PredictorTerm.subclass:
            return PredictorTerm.subclass(*args_, **kwargs_)
        else:
            return PredictorTerm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_FieldRef(self):
        return self.FieldRef
    def set_FieldRef(self, FieldRef):
        self.FieldRef = FieldRef
    def add_FieldRef(self, value):
        self.FieldRef.append(value)
    def insert_FieldRef_at(self, index, value):
        self.FieldRef.insert(index, value)
    def replace_FieldRef_at(self, index, value):
        self.FieldRef[index] = value
    def get_coefficient(self):
        return self.coefficient
    def set_coefficient(self, coefficient):
        self.coefficient = coefficient
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.FieldRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PredictorTerm', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PredictorTerm')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PredictorTerm':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PredictorTerm')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PredictorTerm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PredictorTerm'):
        if self.coefficient is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            outfile.write(' coefficient="%s"' % self.gds_format_double(self.coefficient, input_name='coefficient'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PredictorTerm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for FieldRef_ in self.FieldRef:
            namespaceprefix_ = self.FieldRef_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldRef_nsprefix_) else ''
            FieldRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('coefficient', node)
        if value is not None and 'coefficient' not in already_processed:
            already_processed.add('coefficient')
            value = self.gds_parse_double(value, node, 'coefficient')
            self.coefficient = value
            self.validate_REAL_NUMBER(self.coefficient)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldRef.append(obj_)
            obj_.original_tagname_ = 'FieldRef'
# end class PredictorTerm


class RuleSetModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, RuleSet=None, ModelVerification=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.MiningSchema = MiningSchema
        self.MiningSchema_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.ModelExplanation = ModelExplanation
        self.ModelExplanation_nsprefix_ = None
        self.Targets = Targets
        self.Targets_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        self.RuleSet = RuleSet
        self.RuleSet_nsprefix_ = None
        self.ModelVerification = ModelVerification
        self.ModelVerification_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RuleSetModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RuleSetModel.subclass:
            return RuleSetModel.subclass(*args_, **kwargs_)
        else:
            return RuleSetModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MiningSchema(self):
        return self.MiningSchema
    def set_MiningSchema(self, MiningSchema):
        self.MiningSchema = MiningSchema
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_ModelExplanation(self):
        return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation):
        self.ModelExplanation = ModelExplanation
    def get_Targets(self):
        return self.Targets
    def set_Targets(self, Targets):
        self.Targets = Targets
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_RuleSet(self):
        return self.RuleSet
    def set_RuleSet(self, RuleSet):
        self.RuleSet = RuleSet
    def get_ModelVerification(self):
        return self.ModelVerification
    def set_ModelVerification(self, ModelVerification):
        self.ModelVerification = ModelVerification
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.RuleSet is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RuleSetModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RuleSetModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RuleSetModel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RuleSetModel')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RuleSetModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RuleSetModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RuleSetModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            namespaceprefix_ = self.MiningSchema_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningSchema_nsprefix_) else ''
            self.MiningSchema.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            namespaceprefix_ = self.ModelExplanation_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelExplanation_nsprefix_) else ''
            self.ModelExplanation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            namespaceprefix_ = self.Targets_nsprefix_ + ':' if (UseCapturedNS_ and self.Targets_nsprefix_) else ''
            self.Targets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        if self.RuleSet is not None:
            namespaceprefix_ = self.RuleSet_nsprefix_ + ':' if (UseCapturedNS_ and self.RuleSet_nsprefix_) else ''
            self.RuleSet.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RuleSet', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            namespaceprefix_ = self.ModelVerification_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelVerification_nsprefix_) else ''
            self.ModelVerification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'RuleSet':
            obj_ = RuleSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RuleSet = obj_
            obj_.original_tagname_ = 'RuleSet'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class RuleSetModel


class RuleSet(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, recordCount=None, nbCorrect=None, defaultScore=None, defaultConfidence=None, Extension=None, RuleSelectionMethod=None, ScoreDistribution=None, SimpleRule=None, CompoundRule=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.recordCount = _cast(float, recordCount)
        self.recordCount_nsprefix_ = None
        self.nbCorrect = _cast(float, nbCorrect)
        self.nbCorrect_nsprefix_ = None
        self.defaultScore = _cast(None, defaultScore)
        self.defaultScore_nsprefix_ = None
        self.defaultConfidence = _cast(float, defaultConfidence)
        self.defaultConfidence_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if RuleSelectionMethod is None:
            self.RuleSelectionMethod = []
        else:
            self.RuleSelectionMethod = RuleSelectionMethod
        self.RuleSelectionMethod_nsprefix_ = None
        if ScoreDistribution is None:
            self.ScoreDistribution = []
        else:
            self.ScoreDistribution = ScoreDistribution
        self.ScoreDistribution_nsprefix_ = None
        if SimpleRule is None:
            self.SimpleRule = []
        else:
            self.SimpleRule = SimpleRule
        self.SimpleRule_nsprefix_ = None
        if CompoundRule is None:
            self.CompoundRule = []
        else:
            self.CompoundRule = CompoundRule
        self.CompoundRule_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RuleSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RuleSet.subclass:
            return RuleSet.subclass(*args_, **kwargs_)
        else:
            return RuleSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_RuleSelectionMethod(self):
        return self.RuleSelectionMethod
    def set_RuleSelectionMethod(self, RuleSelectionMethod):
        self.RuleSelectionMethod = RuleSelectionMethod
    def add_RuleSelectionMethod(self, value):
        self.RuleSelectionMethod.append(value)
    def insert_RuleSelectionMethod_at(self, index, value):
        self.RuleSelectionMethod.insert(index, value)
    def replace_RuleSelectionMethod_at(self, index, value):
        self.RuleSelectionMethod[index] = value
    def get_ScoreDistribution(self):
        return self.ScoreDistribution
    def set_ScoreDistribution(self, ScoreDistribution):
        self.ScoreDistribution = ScoreDistribution
    def add_ScoreDistribution(self, value):
        self.ScoreDistribution.append(value)
    def insert_ScoreDistribution_at(self, index, value):
        self.ScoreDistribution.insert(index, value)
    def replace_ScoreDistribution_at(self, index, value):
        self.ScoreDistribution[index] = value
    def get_SimpleRule(self):
        return self.SimpleRule
    def set_SimpleRule(self, SimpleRule):
        self.SimpleRule = SimpleRule
    def add_SimpleRule(self, value):
        self.SimpleRule.append(value)
    def insert_SimpleRule_at(self, index, value):
        self.SimpleRule.insert(index, value)
    def replace_SimpleRule_at(self, index, value):
        self.SimpleRule[index] = value
    def get_CompoundRule(self):
        return self.CompoundRule
    def set_CompoundRule(self, CompoundRule):
        self.CompoundRule = CompoundRule
    def add_CompoundRule(self, value):
        self.CompoundRule.append(value)
    def insert_CompoundRule_at(self, index, value):
        self.CompoundRule.insert(index, value)
    def replace_CompoundRule_at(self, index, value):
        self.CompoundRule[index] = value
    def get_recordCount(self):
        return self.recordCount
    def set_recordCount(self, recordCount):
        self.recordCount = recordCount
    def get_nbCorrect(self):
        return self.nbCorrect
    def set_nbCorrect(self, nbCorrect):
        self.nbCorrect = nbCorrect
    def get_defaultScore(self):
        return self.defaultScore
    def set_defaultScore(self, defaultScore):
        self.defaultScore = defaultScore
    def get_defaultConfidence(self):
        return self.defaultConfidence
    def set_defaultConfidence(self, defaultConfidence):
        self.defaultConfidence = defaultConfidence
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.RuleSelectionMethod or
            self.ScoreDistribution or
            self.SimpleRule or
            self.CompoundRule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RuleSet', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RuleSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RuleSet':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RuleSet')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RuleSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RuleSet'):
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            outfile.write(' recordCount="%s"' % self.gds_format_double(self.recordCount, input_name='recordCount'))
        if self.nbCorrect is not None and 'nbCorrect' not in already_processed:
            already_processed.add('nbCorrect')
            outfile.write(' nbCorrect="%s"' % self.gds_format_double(self.nbCorrect, input_name='nbCorrect'))
        if self.defaultScore is not None and 'defaultScore' not in already_processed:
            already_processed.add('defaultScore')
            outfile.write(' defaultScore=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.defaultScore), input_name='defaultScore')), ))
        if self.defaultConfidence is not None and 'defaultConfidence' not in already_processed:
            already_processed.add('defaultConfidence')
            outfile.write(' defaultConfidence="%s"' % self.gds_format_double(self.defaultConfidence, input_name='defaultConfidence'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RuleSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for RuleSelectionMethod_ in self.RuleSelectionMethod:
            namespaceprefix_ = self.RuleSelectionMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.RuleSelectionMethod_nsprefix_) else ''
            RuleSelectionMethod_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RuleSelectionMethod', pretty_print=pretty_print)
        for ScoreDistribution_ in self.ScoreDistribution:
            namespaceprefix_ = self.ScoreDistribution_nsprefix_ + ':' if (UseCapturedNS_ and self.ScoreDistribution_nsprefix_) else ''
            ScoreDistribution_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ScoreDistribution', pretty_print=pretty_print)
        for SimpleRule_ in self.SimpleRule:
            namespaceprefix_ = self.SimpleRule_nsprefix_ + ':' if (UseCapturedNS_ and self.SimpleRule_nsprefix_) else ''
            SimpleRule_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SimpleRule', pretty_print=pretty_print)
        for CompoundRule_ in self.CompoundRule:
            namespaceprefix_ = self.CompoundRule_nsprefix_ + ':' if (UseCapturedNS_ and self.CompoundRule_nsprefix_) else ''
            CompoundRule_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CompoundRule', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('recordCount', node)
        if value is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            value = self.gds_parse_double(value, node, 'recordCount')
            self.recordCount = value
            self.validate_NUMBER(self.recordCount)    # validate type NUMBER
        value = find_attr_value_('nbCorrect', node)
        if value is not None and 'nbCorrect' not in already_processed:
            already_processed.add('nbCorrect')
            value = self.gds_parse_double(value, node, 'nbCorrect')
            self.nbCorrect = value
            self.validate_NUMBER(self.nbCorrect)    # validate type NUMBER
        value = find_attr_value_('defaultScore', node)
        if value is not None and 'defaultScore' not in already_processed:
            already_processed.add('defaultScore')
            self.defaultScore = value
        value = find_attr_value_('defaultConfidence', node)
        if value is not None and 'defaultConfidence' not in already_processed:
            already_processed.add('defaultConfidence')
            value = self.gds_parse_double(value, node, 'defaultConfidence')
            self.defaultConfidence = value
            self.validate_NUMBER(self.defaultConfidence)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'RuleSelectionMethod':
            obj_ = RuleSelectionMethod.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RuleSelectionMethod.append(obj_)
            obj_.original_tagname_ = 'RuleSelectionMethod'
        elif nodeName_ == 'ScoreDistribution':
            obj_ = ScoreDistribution.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ScoreDistribution.append(obj_)
            obj_.original_tagname_ = 'ScoreDistribution'
        elif nodeName_ == 'SimpleRule':
            obj_ = SimpleRule.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SimpleRule.append(obj_)
            obj_.original_tagname_ = 'SimpleRule'
        elif nodeName_ == 'CompoundRule':
            obj_ = CompoundRule.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CompoundRule.append(obj_)
            obj_.original_tagname_ = 'CompoundRule'
# end class RuleSet


class RuleSelectionMethod(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, criterion=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.criterion = _cast(None, criterion)
        self.criterion_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RuleSelectionMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RuleSelectionMethod.subclass:
            return RuleSelectionMethod.subclass(*args_, **kwargs_)
        else:
            return RuleSelectionMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_criterion(self):
        return self.criterion
    def set_criterion(self, criterion):
        self.criterion = criterion
    def validate_criterionType(self, value):
        # Validate type criterionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['weightedSum', 'weightedMax', 'firstHit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on criterionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RuleSelectionMethod', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RuleSelectionMethod')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RuleSelectionMethod':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RuleSelectionMethod')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RuleSelectionMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RuleSelectionMethod'):
        if self.criterion is not None and 'criterion' not in already_processed:
            already_processed.add('criterion')
            outfile.write(' criterion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.criterion), input_name='criterion')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RuleSelectionMethod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('criterion', node)
        if value is not None and 'criterion' not in already_processed:
            already_processed.add('criterion')
            self.criterion = value
            self.validate_criterionType(self.criterion)    # validate type criterionType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class RuleSelectionMethod


class SimpleRule(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, score=None, recordCount=None, nbCorrect=None, confidence=None, weight=None, Extension=None, SimplePredicate=None, CompoundPredicate=None, SimpleSetPredicate=None, True_=None, False_=None, ScoreDistribution=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.score = _cast(None, score)
        self.score_nsprefix_ = None
        self.recordCount = _cast(float, recordCount)
        self.recordCount_nsprefix_ = None
        self.nbCorrect = _cast(float, nbCorrect)
        self.nbCorrect_nsprefix_ = None
        self.confidence = _cast(float, confidence)
        self.confidence_nsprefix_ = None
        self.weight = _cast(float, weight)
        self.weight_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.SimplePredicate = SimplePredicate
        self.SimplePredicate_nsprefix_ = None
        self.CompoundPredicate = CompoundPredicate
        self.CompoundPredicate_nsprefix_ = None
        self.SimpleSetPredicate = SimpleSetPredicate
        self.SimpleSetPredicate_nsprefix_ = None
        self.True_ = True_
        self.True__nsprefix_ = None
        self.False_ = False_
        self.False__nsprefix_ = None
        if ScoreDistribution is None:
            self.ScoreDistribution = []
        else:
            self.ScoreDistribution = ScoreDistribution
        self.ScoreDistribution_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SimpleRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SimpleRule.subclass:
            return SimpleRule.subclass(*args_, **kwargs_)
        else:
            return SimpleRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_SimplePredicate(self):
        return self.SimplePredicate
    def set_SimplePredicate(self, SimplePredicate):
        self.SimplePredicate = SimplePredicate
    def get_CompoundPredicate(self):
        return self.CompoundPredicate
    def set_CompoundPredicate(self, CompoundPredicate):
        self.CompoundPredicate = CompoundPredicate
    def get_SimpleSetPredicate(self):
        return self.SimpleSetPredicate
    def set_SimpleSetPredicate(self, SimpleSetPredicate):
        self.SimpleSetPredicate = SimpleSetPredicate
    def get_True(self):
        return self.True_
    def set_True(self, True_):
        self.True_ = True_
    def get_False(self):
        return self.False_
    def set_False(self, False_):
        self.False_ = False_
    def get_ScoreDistribution(self):
        return self.ScoreDistribution
    def set_ScoreDistribution(self, ScoreDistribution):
        self.ScoreDistribution = ScoreDistribution
    def add_ScoreDistribution(self, value):
        self.ScoreDistribution.append(value)
    def insert_ScoreDistribution_at(self, index, value):
        self.ScoreDistribution.insert(index, value)
    def replace_ScoreDistribution_at(self, index, value):
        self.ScoreDistribution[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_score(self):
        return self.score
    def set_score(self, score):
        self.score = score
    def get_recordCount(self):
        return self.recordCount
    def set_recordCount(self, recordCount):
        self.recordCount = recordCount
    def get_nbCorrect(self):
        return self.nbCorrect
    def set_nbCorrect(self, nbCorrect):
        self.nbCorrect = nbCorrect
    def get_confidence(self):
        return self.confidence
    def set_confidence(self, confidence):
        self.confidence = confidence
    def get_weight(self):
        return self.weight
    def set_weight(self, weight):
        self.weight = weight
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.SimplePredicate is not None or
            self.CompoundPredicate is not None or
            self.SimpleSetPredicate is not None or
            self.True_ is not None or
            self.False_ is not None or
            self.ScoreDistribution
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SimpleRule', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SimpleRule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SimpleRule':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SimpleRule')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SimpleRule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SimpleRule'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.score is not None and 'score' not in already_processed:
            already_processed.add('score')
            outfile.write(' score=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.score), input_name='score')), ))
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            outfile.write(' recordCount="%s"' % self.gds_format_double(self.recordCount, input_name='recordCount'))
        if self.nbCorrect is not None and 'nbCorrect' not in already_processed:
            already_processed.add('nbCorrect')
            outfile.write(' nbCorrect="%s"' % self.gds_format_double(self.nbCorrect, input_name='nbCorrect'))
        if self.confidence is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            outfile.write(' confidence="%s"' % self.gds_format_double(self.confidence, input_name='confidence'))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight="%s"' % self.gds_format_double(self.weight, input_name='weight'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SimpleRule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.SimplePredicate is not None:
            namespaceprefix_ = self.SimplePredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.SimplePredicate_nsprefix_) else ''
            self.SimplePredicate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SimplePredicate', pretty_print=pretty_print)
        if self.CompoundPredicate is not None:
            namespaceprefix_ = self.CompoundPredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.CompoundPredicate_nsprefix_) else ''
            self.CompoundPredicate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CompoundPredicate', pretty_print=pretty_print)
        if self.SimpleSetPredicate is not None:
            namespaceprefix_ = self.SimpleSetPredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.SimpleSetPredicate_nsprefix_) else ''
            self.SimpleSetPredicate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SimpleSetPredicate', pretty_print=pretty_print)
        if self.True_ is not None:
            namespaceprefix_ = self.True__nsprefix_ + ':' if (UseCapturedNS_ and self.True__nsprefix_) else ''
            self.True_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='True', pretty_print=pretty_print)
        if self.False_ is not None:
            namespaceprefix_ = self.False__nsprefix_ + ':' if (UseCapturedNS_ and self.False__nsprefix_) else ''
            self.False_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='False', pretty_print=pretty_print)
        for ScoreDistribution_ in self.ScoreDistribution:
            namespaceprefix_ = self.ScoreDistribution_nsprefix_ + ':' if (UseCapturedNS_ and self.ScoreDistribution_nsprefix_) else ''
            ScoreDistribution_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ScoreDistribution', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('score', node)
        if value is not None and 'score' not in already_processed:
            already_processed.add('score')
            self.score = value
        value = find_attr_value_('recordCount', node)
        if value is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            value = self.gds_parse_double(value, node, 'recordCount')
            self.recordCount = value
            self.validate_NUMBER(self.recordCount)    # validate type NUMBER
        value = find_attr_value_('nbCorrect', node)
        if value is not None and 'nbCorrect' not in already_processed:
            already_processed.add('nbCorrect')
            value = self.gds_parse_double(value, node, 'nbCorrect')
            self.nbCorrect = value
            self.validate_NUMBER(self.nbCorrect)    # validate type NUMBER
        value = find_attr_value_('confidence', node)
        if value is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            value = self.gds_parse_double(value, node, 'confidence')
            self.confidence = value
            self.validate_NUMBER(self.confidence)    # validate type NUMBER
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            value = self.gds_parse_double(value, node, 'weight')
            self.weight = value
            self.validate_NUMBER(self.weight)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SimplePredicate':
            obj_ = SimplePredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SimplePredicate = obj_
            obj_.original_tagname_ = 'SimplePredicate'
        elif nodeName_ == 'CompoundPredicate':
            obj_ = CompoundPredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CompoundPredicate = obj_
            obj_.original_tagname_ = 'CompoundPredicate'
        elif nodeName_ == 'SimpleSetPredicate':
            obj_ = SimpleSetPredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SimpleSetPredicate = obj_
            obj_.original_tagname_ = 'SimpleSetPredicate'
        elif nodeName_ == 'True':
            obj_ = True_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.True_ = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            obj_ = False_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.False_ = obj_
            obj_.original_tagname_ = 'False'
        elif nodeName_ == 'ScoreDistribution':
            obj_ = ScoreDistribution.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ScoreDistribution.append(obj_)
            obj_.original_tagname_ = 'ScoreDistribution'
# end class SimpleRule


class CompoundRule(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, SimplePredicate=None, CompoundPredicate=None, SimpleSetPredicate=None, True_=None, False_=None, SimpleRule=None, CompoundRule_member=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.SimplePredicate = SimplePredicate
        self.SimplePredicate_nsprefix_ = None
        self.CompoundPredicate = CompoundPredicate
        self.CompoundPredicate_nsprefix_ = None
        self.SimpleSetPredicate = SimpleSetPredicate
        self.SimpleSetPredicate_nsprefix_ = None
        self.True_ = True_
        self.True__nsprefix_ = None
        self.False_ = False_
        self.False__nsprefix_ = None
        if SimpleRule is None:
            self.SimpleRule = []
        else:
            self.SimpleRule = SimpleRule
        self.SimpleRule_nsprefix_ = None
        if CompoundRule_member is None:
            self.CompoundRule = []
        else:
            self.CompoundRule = CompoundRule_member
        self.CompoundRule_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompoundRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompoundRule.subclass:
            return CompoundRule.subclass(*args_, **kwargs_)
        else:
            return CompoundRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_SimplePredicate(self):
        return self.SimplePredicate
    def set_SimplePredicate(self, SimplePredicate):
        self.SimplePredicate = SimplePredicate
    def get_CompoundPredicate(self):
        return self.CompoundPredicate
    def set_CompoundPredicate(self, CompoundPredicate):
        self.CompoundPredicate = CompoundPredicate
    def get_SimpleSetPredicate(self):
        return self.SimpleSetPredicate
    def set_SimpleSetPredicate(self, SimpleSetPredicate):
        self.SimpleSetPredicate = SimpleSetPredicate
    def get_True(self):
        return self.True_
    def set_True(self, True_):
        self.True_ = True_
    def get_False(self):
        return self.False_
    def set_False(self, False_):
        self.False_ = False_
    def get_SimpleRule(self):
        return self.SimpleRule
    def set_SimpleRule(self, SimpleRule):
        self.SimpleRule = SimpleRule
    def add_SimpleRule(self, value):
        self.SimpleRule.append(value)
    def insert_SimpleRule_at(self, index, value):
        self.SimpleRule.insert(index, value)
    def replace_SimpleRule_at(self, index, value):
        self.SimpleRule[index] = value
    def get_CompoundRule(self):
        return self.CompoundRule
    def set_CompoundRule(self, CompoundRule):
        self.CompoundRule = CompoundRule
    def add_CompoundRule(self, value):
        self.CompoundRule.append(value)
    def insert_CompoundRule_at(self, index, value):
        self.CompoundRule.insert(index, value)
    def replace_CompoundRule_at(self, index, value):
        self.CompoundRule[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.SimplePredicate is not None or
            self.CompoundPredicate is not None or
            self.SimpleSetPredicate is not None or
            self.True_ is not None or
            self.False_ is not None or
            self.SimpleRule or
            self.CompoundRule
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CompoundRule', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompoundRule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CompoundRule':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompoundRule')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CompoundRule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CompoundRule'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CompoundRule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.SimplePredicate is not None:
            namespaceprefix_ = self.SimplePredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.SimplePredicate_nsprefix_) else ''
            self.SimplePredicate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SimplePredicate', pretty_print=pretty_print)
        if self.CompoundPredicate is not None:
            namespaceprefix_ = self.CompoundPredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.CompoundPredicate_nsprefix_) else ''
            self.CompoundPredicate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CompoundPredicate', pretty_print=pretty_print)
        if self.SimpleSetPredicate is not None:
            namespaceprefix_ = self.SimpleSetPredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.SimpleSetPredicate_nsprefix_) else ''
            self.SimpleSetPredicate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SimpleSetPredicate', pretty_print=pretty_print)
        if self.True_ is not None:
            namespaceprefix_ = self.True__nsprefix_ + ':' if (UseCapturedNS_ and self.True__nsprefix_) else ''
            self.True_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='True', pretty_print=pretty_print)
        if self.False_ is not None:
            namespaceprefix_ = self.False__nsprefix_ + ':' if (UseCapturedNS_ and self.False__nsprefix_) else ''
            self.False_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='False', pretty_print=pretty_print)
        for SimpleRule_ in self.SimpleRule:
            namespaceprefix_ = self.SimpleRule_nsprefix_ + ':' if (UseCapturedNS_ and self.SimpleRule_nsprefix_) else ''
            SimpleRule_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SimpleRule', pretty_print=pretty_print)
        for CompoundRule_ in self.CompoundRule:
            namespaceprefix_ = self.CompoundRule_nsprefix_ + ':' if (UseCapturedNS_ and self.CompoundRule_nsprefix_) else ''
            CompoundRule_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CompoundRule', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SimplePredicate':
            obj_ = SimplePredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SimplePredicate = obj_
            obj_.original_tagname_ = 'SimplePredicate'
        elif nodeName_ == 'CompoundPredicate':
            obj_ = CompoundPredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CompoundPredicate = obj_
            obj_.original_tagname_ = 'CompoundPredicate'
        elif nodeName_ == 'SimpleSetPredicate':
            obj_ = SimpleSetPredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SimpleSetPredicate = obj_
            obj_.original_tagname_ = 'SimpleSetPredicate'
        elif nodeName_ == 'True':
            obj_ = True_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.True_ = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            obj_ = False_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.False_ = obj_
            obj_.original_tagname_ = 'False'
        elif nodeName_ == 'SimpleRule':
            obj_ = SimpleRule.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SimpleRule.append(obj_)
            obj_.original_tagname_ = 'SimpleRule'
        elif nodeName_ == 'CompoundRule':
            obj_ = CompoundRule.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CompoundRule.append(obj_)
            obj_.original_tagname_ = 'CompoundRule'
# end class CompoundRule


class SupportVectorMachineModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, threshold='0', svmRepresentation='SupportVectors', classificationMethod='OneAgainstAll', MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, LinearKernelType=None, PolynomialKernelType=None, RadialBasisKernelType=None, SigmoidKernelType=None, VectorDictionary=None, SupportVectorMachine=None, ModelVerification=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.threshold = _cast(float, threshold)
        self.threshold_nsprefix_ = None
        self.svmRepresentation = _cast(None, svmRepresentation)
        self.svmRepresentation_nsprefix_ = None
        self.classificationMethod = _cast(None, classificationMethod)
        self.classificationMethod_nsprefix_ = None
        self.MiningSchema = MiningSchema
        self.MiningSchema_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.ModelExplanation = ModelExplanation
        self.ModelExplanation_nsprefix_ = None
        self.Targets = Targets
        self.Targets_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        self.LinearKernelType = LinearKernelType
        self.LinearKernelType_nsprefix_ = None
        self.PolynomialKernelType = PolynomialKernelType
        self.PolynomialKernelType_nsprefix_ = None
        self.RadialBasisKernelType = RadialBasisKernelType
        self.RadialBasisKernelType_nsprefix_ = None
        self.SigmoidKernelType = SigmoidKernelType
        self.SigmoidKernelType_nsprefix_ = None
        self.VectorDictionary = VectorDictionary
        self.VectorDictionary_nsprefix_ = None
        if SupportVectorMachine is None:
            self.SupportVectorMachine = []
        else:
            self.SupportVectorMachine = SupportVectorMachine
        self.SupportVectorMachine_nsprefix_ = None
        self.ModelVerification = ModelVerification
        self.ModelVerification_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupportVectorMachineModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupportVectorMachineModel.subclass:
            return SupportVectorMachineModel.subclass(*args_, **kwargs_)
        else:
            return SupportVectorMachineModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MiningSchema(self):
        return self.MiningSchema
    def set_MiningSchema(self, MiningSchema):
        self.MiningSchema = MiningSchema
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_ModelExplanation(self):
        return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation):
        self.ModelExplanation = ModelExplanation
    def get_Targets(self):
        return self.Targets
    def set_Targets(self, Targets):
        self.Targets = Targets
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_LinearKernelType(self):
        return self.LinearKernelType
    def set_LinearKernelType(self, LinearKernelType):
        self.LinearKernelType = LinearKernelType
    def get_PolynomialKernelType(self):
        return self.PolynomialKernelType
    def set_PolynomialKernelType(self, PolynomialKernelType):
        self.PolynomialKernelType = PolynomialKernelType
    def get_RadialBasisKernelType(self):
        return self.RadialBasisKernelType
    def set_RadialBasisKernelType(self, RadialBasisKernelType):
        self.RadialBasisKernelType = RadialBasisKernelType
    def get_SigmoidKernelType(self):
        return self.SigmoidKernelType
    def set_SigmoidKernelType(self, SigmoidKernelType):
        self.SigmoidKernelType = SigmoidKernelType
    def get_VectorDictionary(self):
        return self.VectorDictionary
    def set_VectorDictionary(self, VectorDictionary):
        self.VectorDictionary = VectorDictionary
    def get_SupportVectorMachine(self):
        return self.SupportVectorMachine
    def set_SupportVectorMachine(self, SupportVectorMachine):
        self.SupportVectorMachine = SupportVectorMachine
    def add_SupportVectorMachine(self, value):
        self.SupportVectorMachine.append(value)
    def insert_SupportVectorMachine_at(self, index, value):
        self.SupportVectorMachine.insert(index, value)
    def replace_SupportVectorMachine_at(self, index, value):
        self.SupportVectorMachine[index] = value
    def get_ModelVerification(self):
        return self.ModelVerification
    def set_ModelVerification(self, ModelVerification):
        self.ModelVerification = ModelVerification
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def get_threshold(self):
        return self.threshold
    def set_threshold(self, threshold):
        self.threshold = threshold
    def get_svmRepresentation(self):
        return self.svmRepresentation
    def set_svmRepresentation(self, svmRepresentation):
        self.svmRepresentation = svmRepresentation
    def get_classificationMethod(self):
        return self.classificationMethod
    def set_classificationMethod(self, classificationMethod):
        self.classificationMethod = classificationMethod
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_SVM_REPRESENTATION(self, value):
        # Validate type SVM-REPRESENTATION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['SupportVectors', 'Coefficients']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SVM-REPRESENTATION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_SVM_CLASSIFICATION_METHOD(self, value):
        # Validate type SVM-CLASSIFICATION-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['OneAgainstAll', 'OneAgainstOne']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on SVM-CLASSIFICATION-METHOD' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.LinearKernelType is not None or
            self.PolynomialKernelType is not None or
            self.RadialBasisKernelType is not None or
            self.SigmoidKernelType is not None or
            self.VectorDictionary is not None or
            self.SupportVectorMachine or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SupportVectorMachineModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupportVectorMachineModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupportVectorMachineModel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupportVectorMachineModel')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupportVectorMachineModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupportVectorMachineModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.threshold != 0 and 'threshold' not in already_processed:
            already_processed.add('threshold')
            outfile.write(' threshold="%s"' % self.gds_format_double(self.threshold, input_name='threshold'))
        if self.svmRepresentation != "SupportVectors" and 'svmRepresentation' not in already_processed:
            already_processed.add('svmRepresentation')
            outfile.write(' svmRepresentation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.svmRepresentation), input_name='svmRepresentation')), ))
        if self.classificationMethod != "OneAgainstAll" and 'classificationMethod' not in already_processed:
            already_processed.add('classificationMethod')
            outfile.write(' classificationMethod=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.classificationMethod), input_name='classificationMethod')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SupportVectorMachineModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            namespaceprefix_ = self.MiningSchema_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningSchema_nsprefix_) else ''
            self.MiningSchema.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            namespaceprefix_ = self.ModelExplanation_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelExplanation_nsprefix_) else ''
            self.ModelExplanation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            namespaceprefix_ = self.Targets_nsprefix_ + ':' if (UseCapturedNS_ and self.Targets_nsprefix_) else ''
            self.Targets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        if self.LinearKernelType is not None:
            namespaceprefix_ = self.LinearKernelType_nsprefix_ + ':' if (UseCapturedNS_ and self.LinearKernelType_nsprefix_) else ''
            self.LinearKernelType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LinearKernelType', pretty_print=pretty_print)
        if self.PolynomialKernelType is not None:
            namespaceprefix_ = self.PolynomialKernelType_nsprefix_ + ':' if (UseCapturedNS_ and self.PolynomialKernelType_nsprefix_) else ''
            self.PolynomialKernelType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PolynomialKernelType', pretty_print=pretty_print)
        if self.RadialBasisKernelType is not None:
            namespaceprefix_ = self.RadialBasisKernelType_nsprefix_ + ':' if (UseCapturedNS_ and self.RadialBasisKernelType_nsprefix_) else ''
            self.RadialBasisKernelType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RadialBasisKernelType', pretty_print=pretty_print)
        if self.SigmoidKernelType is not None:
            namespaceprefix_ = self.SigmoidKernelType_nsprefix_ + ':' if (UseCapturedNS_ and self.SigmoidKernelType_nsprefix_) else ''
            self.SigmoidKernelType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SigmoidKernelType', pretty_print=pretty_print)
        if self.VectorDictionary is not None:
            namespaceprefix_ = self.VectorDictionary_nsprefix_ + ':' if (UseCapturedNS_ and self.VectorDictionary_nsprefix_) else ''
            self.VectorDictionary.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VectorDictionary', pretty_print=pretty_print)
        for SupportVectorMachine_ in self.SupportVectorMachine:
            namespaceprefix_ = self.SupportVectorMachine_nsprefix_ + ':' if (UseCapturedNS_ and self.SupportVectorMachine_nsprefix_) else ''
            SupportVectorMachine_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SupportVectorMachine', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            namespaceprefix_ = self.ModelVerification_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelVerification_nsprefix_) else ''
            self.ModelVerification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('threshold', node)
        if value is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            value = self.gds_parse_double(value, node, 'threshold')
            self.threshold = value
            self.validate_REAL_NUMBER(self.threshold)    # validate type REAL-NUMBER
        value = find_attr_value_('svmRepresentation', node)
        if value is not None and 'svmRepresentation' not in already_processed:
            already_processed.add('svmRepresentation')
            self.svmRepresentation = value
            self.validate_SVM_REPRESENTATION(self.svmRepresentation)    # validate type SVM-REPRESENTATION
        value = find_attr_value_('classificationMethod', node)
        if value is not None and 'classificationMethod' not in already_processed:
            already_processed.add('classificationMethod')
            self.classificationMethod = value
            self.validate_SVM_CLASSIFICATION_METHOD(self.classificationMethod)    # validate type SVM-CLASSIFICATION-METHOD
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'LinearKernelType':
            obj_ = LinearKernelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LinearKernelType = obj_
            obj_.original_tagname_ = 'LinearKernelType'
        elif nodeName_ == 'PolynomialKernelType':
            obj_ = PolynomialKernelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PolynomialKernelType = obj_
            obj_.original_tagname_ = 'PolynomialKernelType'
        elif nodeName_ == 'RadialBasisKernelType':
            obj_ = RadialBasisKernelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RadialBasisKernelType = obj_
            obj_.original_tagname_ = 'RadialBasisKernelType'
        elif nodeName_ == 'SigmoidKernelType':
            obj_ = SigmoidKernelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SigmoidKernelType = obj_
            obj_.original_tagname_ = 'SigmoidKernelType'
        elif nodeName_ == 'VectorDictionary':
            obj_ = VectorDictionary.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VectorDictionary = obj_
            obj_.original_tagname_ = 'VectorDictionary'
        elif nodeName_ == 'SupportVectorMachine':
            obj_ = SupportVectorMachine.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SupportVectorMachine.append(obj_)
            obj_.original_tagname_ = 'SupportVectorMachine'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SupportVectorMachineModel


class LinearKernelType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, description=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinearKernelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinearKernelType.subclass:
            return LinearKernelType.subclass(*args_, **kwargs_)
        else:
            return LinearKernelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='LinearKernelType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LinearKernelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LinearKernelType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LinearKernelType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LinearKernelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LinearKernelType'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='LinearKernelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class LinearKernelType


class PolynomialKernelType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, description=None, gamma='1', coef0='1', degree='1', Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.gamma = _cast(float, gamma)
        self.gamma_nsprefix_ = None
        self.coef0 = _cast(float, coef0)
        self.coef0_nsprefix_ = None
        self.degree = _cast(float, degree)
        self.degree_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PolynomialKernelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PolynomialKernelType.subclass:
            return PolynomialKernelType.subclass(*args_, **kwargs_)
        else:
            return PolynomialKernelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_gamma(self):
        return self.gamma
    def set_gamma(self, gamma):
        self.gamma = gamma
    def get_coef0(self):
        return self.coef0
    def set_coef0(self, coef0):
        self.coef0 = coef0
    def get_degree(self):
        return self.degree
    def set_degree(self, degree):
        self.degree = degree
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PolynomialKernelType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PolynomialKernelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PolynomialKernelType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PolynomialKernelType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PolynomialKernelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PolynomialKernelType'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.gamma != 1 and 'gamma' not in already_processed:
            already_processed.add('gamma')
            outfile.write(' gamma="%s"' % self.gds_format_double(self.gamma, input_name='gamma'))
        if self.coef0 != 1 and 'coef0' not in already_processed:
            already_processed.add('coef0')
            outfile.write(' coef0="%s"' % self.gds_format_double(self.coef0, input_name='coef0'))
        if self.degree != 1 and 'degree' not in already_processed:
            already_processed.add('degree')
            outfile.write(' degree="%s"' % self.gds_format_double(self.degree, input_name='degree'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PolynomialKernelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            value = self.gds_parse_double(value, node, 'gamma')
            self.gamma = value
            self.validate_REAL_NUMBER(self.gamma)    # validate type REAL-NUMBER
        value = find_attr_value_('coef0', node)
        if value is not None and 'coef0' not in already_processed:
            already_processed.add('coef0')
            value = self.gds_parse_double(value, node, 'coef0')
            self.coef0 = value
            self.validate_REAL_NUMBER(self.coef0)    # validate type REAL-NUMBER
        value = find_attr_value_('degree', node)
        if value is not None and 'degree' not in already_processed:
            already_processed.add('degree')
            value = self.gds_parse_double(value, node, 'degree')
            self.degree = value
            self.validate_REAL_NUMBER(self.degree)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class PolynomialKernelType


class RadialBasisKernelType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, description=None, gamma='1', Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.gamma = _cast(float, gamma)
        self.gamma_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RadialBasisKernelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RadialBasisKernelType.subclass:
            return RadialBasisKernelType.subclass(*args_, **kwargs_)
        else:
            return RadialBasisKernelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_gamma(self):
        return self.gamma
    def set_gamma(self, gamma):
        self.gamma = gamma
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RadialBasisKernelType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RadialBasisKernelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RadialBasisKernelType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RadialBasisKernelType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RadialBasisKernelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RadialBasisKernelType'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.gamma != 1 and 'gamma' not in already_processed:
            already_processed.add('gamma')
            outfile.write(' gamma="%s"' % self.gds_format_double(self.gamma, input_name='gamma'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RadialBasisKernelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            value = self.gds_parse_double(value, node, 'gamma')
            self.gamma = value
            self.validate_REAL_NUMBER(self.gamma)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class RadialBasisKernelType


class SigmoidKernelType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, description=None, gamma='1', coef0='1', Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.gamma = _cast(float, gamma)
        self.gamma_nsprefix_ = None
        self.coef0 = _cast(float, coef0)
        self.coef0_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SigmoidKernelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SigmoidKernelType.subclass:
            return SigmoidKernelType.subclass(*args_, **kwargs_)
        else:
            return SigmoidKernelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_gamma(self):
        return self.gamma
    def set_gamma(self, gamma):
        self.gamma = gamma
    def get_coef0(self):
        return self.coef0
    def set_coef0(self, coef0):
        self.coef0 = coef0
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SigmoidKernelType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SigmoidKernelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SigmoidKernelType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SigmoidKernelType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SigmoidKernelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SigmoidKernelType'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.gamma != 1 and 'gamma' not in already_processed:
            already_processed.add('gamma')
            outfile.write(' gamma="%s"' % self.gds_format_double(self.gamma, input_name='gamma'))
        if self.coef0 != 1 and 'coef0' not in already_processed:
            already_processed.add('coef0')
            outfile.write(' coef0="%s"' % self.gds_format_double(self.coef0, input_name='coef0'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SigmoidKernelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            value = self.gds_parse_double(value, node, 'gamma')
            self.gamma = value
            self.validate_REAL_NUMBER(self.gamma)    # validate type REAL-NUMBER
        value = find_attr_value_('coef0', node)
        if value is not None and 'coef0' not in already_processed:
            already_processed.add('coef0')
            value = self.gds_parse_double(value, node, 'coef0')
            self.coef0 = value
            self.validate_REAL_NUMBER(self.coef0)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SigmoidKernelType


class VectorDictionary(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, numberOfVectors=None, Extension=None, VectorFields=None, VectorInstance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numberOfVectors = _cast(int, numberOfVectors)
        self.numberOfVectors_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.VectorFields = VectorFields
        self.VectorFields_nsprefix_ = None
        if VectorInstance is None:
            self.VectorInstance = []
        else:
            self.VectorInstance = VectorInstance
        self.VectorInstance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VectorDictionary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VectorDictionary.subclass:
            return VectorDictionary.subclass(*args_, **kwargs_)
        else:
            return VectorDictionary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_VectorFields(self):
        return self.VectorFields
    def set_VectorFields(self, VectorFields):
        self.VectorFields = VectorFields
    def get_VectorInstance(self):
        return self.VectorInstance
    def set_VectorInstance(self, VectorInstance):
        self.VectorInstance = VectorInstance
    def add_VectorInstance(self, value):
        self.VectorInstance.append(value)
    def insert_VectorInstance_at(self, index, value):
        self.VectorInstance.insert(index, value)
    def replace_VectorInstance_at(self, index, value):
        self.VectorInstance[index] = value
    def get_numberOfVectors(self):
        return self.numberOfVectors
    def set_numberOfVectors(self, numberOfVectors):
        self.numberOfVectors = numberOfVectors
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.VectorFields is not None or
            self.VectorInstance
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='VectorDictionary', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VectorDictionary')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VectorDictionary':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VectorDictionary')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VectorDictionary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VectorDictionary'):
        if self.numberOfVectors is not None and 'numberOfVectors' not in already_processed:
            already_processed.add('numberOfVectors')
            outfile.write(' numberOfVectors="%s"' % self.gds_format_integer(self.numberOfVectors, input_name='numberOfVectors'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='VectorDictionary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.VectorFields is not None:
            namespaceprefix_ = self.VectorFields_nsprefix_ + ':' if (UseCapturedNS_ and self.VectorFields_nsprefix_) else ''
            self.VectorFields.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VectorFields', pretty_print=pretty_print)
        for VectorInstance_ in self.VectorInstance:
            namespaceprefix_ = self.VectorInstance_nsprefix_ + ':' if (UseCapturedNS_ and self.VectorInstance_nsprefix_) else ''
            VectorInstance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VectorInstance', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfVectors', node)
        if value is not None and 'numberOfVectors' not in already_processed:
            already_processed.add('numberOfVectors')
            self.numberOfVectors = self.gds_parse_integer(value, node, 'numberOfVectors')
            self.validate_INT_NUMBER(self.numberOfVectors)    # validate type INT-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'VectorFields':
            obj_ = VectorFields.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VectorFields = obj_
            obj_.original_tagname_ = 'VectorFields'
        elif nodeName_ == 'VectorInstance':
            obj_ = VectorInstance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VectorInstance.append(obj_)
            obj_.original_tagname_ = 'VectorInstance'
# end class VectorDictionary


class VectorFields(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, numberOfFields=None, Extension=None, FieldRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numberOfFields = _cast(int, numberOfFields)
        self.numberOfFields_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if FieldRef is None:
            self.FieldRef = []
        else:
            self.FieldRef = FieldRef
        self.FieldRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VectorFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VectorFields.subclass:
            return VectorFields.subclass(*args_, **kwargs_)
        else:
            return VectorFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_FieldRef(self):
        return self.FieldRef
    def set_FieldRef(self, FieldRef):
        self.FieldRef = FieldRef
    def add_FieldRef(self, value):
        self.FieldRef.append(value)
    def insert_FieldRef_at(self, index, value):
        self.FieldRef.insert(index, value)
    def replace_FieldRef_at(self, index, value):
        self.FieldRef[index] = value
    def get_numberOfFields(self):
        return self.numberOfFields
    def set_numberOfFields(self, numberOfFields):
        self.numberOfFields = numberOfFields
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.FieldRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='VectorFields', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VectorFields')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VectorFields':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VectorFields')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VectorFields', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VectorFields'):
        if self.numberOfFields is not None and 'numberOfFields' not in already_processed:
            already_processed.add('numberOfFields')
            outfile.write(' numberOfFields="%s"' % self.gds_format_integer(self.numberOfFields, input_name='numberOfFields'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='VectorFields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for FieldRef_ in self.FieldRef:
            namespaceprefix_ = self.FieldRef_nsprefix_ + ':' if (UseCapturedNS_ and self.FieldRef_nsprefix_) else ''
            FieldRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FieldRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfFields', node)
        if value is not None and 'numberOfFields' not in already_processed:
            already_processed.add('numberOfFields')
            self.numberOfFields = self.gds_parse_integer(value, node, 'numberOfFields')
            self.validate_INT_NUMBER(self.numberOfFields)    # validate type INT-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'FieldRef':
            obj_ = FieldRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FieldRef.append(obj_)
            obj_.original_tagname_ = 'FieldRef'
# end class VectorFields


class VectorInstance(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, Extension=None, REAL_SparseArray=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.REAL_SparseArray = REAL_SparseArray
        self.REAL_SparseArray_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VectorInstance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VectorInstance.subclass:
            return VectorInstance.subclass(*args_, **kwargs_)
        else:
            return VectorInstance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_REAL_SparseArray(self):
        return self.REAL_SparseArray
    def set_REAL_SparseArray(self, REAL_SparseArray):
        self.REAL_SparseArray = REAL_SparseArray
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_VECTOR_ID(self, value):
        # Validate type VECTOR-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.REAL_SparseArray is not None or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='VectorInstance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VectorInstance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VectorInstance':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VectorInstance')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VectorInstance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VectorInstance'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='VectorInstance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.REAL_SparseArray is not None:
            namespaceprefix_ = self.REAL_SparseArray_nsprefix_ + ':' if (UseCapturedNS_ and self.REAL_SparseArray_nsprefix_) else ''
            self.REAL_SparseArray.export(outfile, level, namespaceprefix_, namespacedef_='', name_='REAL-SparseArray', pretty_print=pretty_print)
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_VECTOR_ID(self.id)    # validate type VECTOR-ID
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'REAL-SparseArray':
            obj_ = REAL_SparseArray.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.REAL_SparseArray = obj_
            obj_.original_tagname_ = 'REAL-SparseArray'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class VectorInstance


class SupportVectorMachine(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, targetCategory=None, alternateTargetCategory=None, threshold=None, Extension=None, SupportVectors=None, Coefficients=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.targetCategory = _cast(None, targetCategory)
        self.targetCategory_nsprefix_ = None
        self.alternateTargetCategory = _cast(None, alternateTargetCategory)
        self.alternateTargetCategory_nsprefix_ = None
        self.threshold = _cast(float, threshold)
        self.threshold_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.SupportVectors = SupportVectors
        self.SupportVectors_nsprefix_ = None
        self.Coefficients = Coefficients
        self.Coefficients_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupportVectorMachine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupportVectorMachine.subclass:
            return SupportVectorMachine.subclass(*args_, **kwargs_)
        else:
            return SupportVectorMachine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_SupportVectors(self):
        return self.SupportVectors
    def set_SupportVectors(self, SupportVectors):
        self.SupportVectors = SupportVectors
    def get_Coefficients(self):
        return self.Coefficients
    def set_Coefficients(self, Coefficients):
        self.Coefficients = Coefficients
    def get_targetCategory(self):
        return self.targetCategory
    def set_targetCategory(self, targetCategory):
        self.targetCategory = targetCategory
    def get_alternateTargetCategory(self):
        return self.alternateTargetCategory
    def set_alternateTargetCategory(self, alternateTargetCategory):
        self.alternateTargetCategory = alternateTargetCategory
    def get_threshold(self):
        return self.threshold
    def set_threshold(self, threshold):
        self.threshold = threshold
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.SupportVectors is not None or
            self.Coefficients is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SupportVectorMachine', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupportVectorMachine')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupportVectorMachine':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupportVectorMachine')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupportVectorMachine', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupportVectorMachine'):
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            outfile.write(' targetCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetCategory), input_name='targetCategory')), ))
        if self.alternateTargetCategory is not None and 'alternateTargetCategory' not in already_processed:
            already_processed.add('alternateTargetCategory')
            outfile.write(' alternateTargetCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alternateTargetCategory), input_name='alternateTargetCategory')), ))
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            outfile.write(' threshold="%s"' % self.gds_format_double(self.threshold, input_name='threshold'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SupportVectorMachine', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.SupportVectors is not None:
            namespaceprefix_ = self.SupportVectors_nsprefix_ + ':' if (UseCapturedNS_ and self.SupportVectors_nsprefix_) else ''
            self.SupportVectors.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SupportVectors', pretty_print=pretty_print)
        if self.Coefficients is not None:
            namespaceprefix_ = self.Coefficients_nsprefix_ + ':' if (UseCapturedNS_ and self.Coefficients_nsprefix_) else ''
            self.Coefficients.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Coefficients', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetCategory', node)
        if value is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            self.targetCategory = value
        value = find_attr_value_('alternateTargetCategory', node)
        if value is not None and 'alternateTargetCategory' not in already_processed:
            already_processed.add('alternateTargetCategory')
            self.alternateTargetCategory = value
        value = find_attr_value_('threshold', node)
        if value is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            value = self.gds_parse_double(value, node, 'threshold')
            self.threshold = value
            self.validate_REAL_NUMBER(self.threshold)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SupportVectors':
            obj_ = SupportVectors.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SupportVectors = obj_
            obj_.original_tagname_ = 'SupportVectors'
        elif nodeName_ == 'Coefficients':
            obj_ = Coefficients.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Coefficients = obj_
            obj_.original_tagname_ = 'Coefficients'
# end class SupportVectorMachine


class SupportVectors(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, numberOfSupportVectors=None, numberOfAttributes=None, Extension=None, SupportVector=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numberOfSupportVectors = _cast(int, numberOfSupportVectors)
        self.numberOfSupportVectors_nsprefix_ = None
        self.numberOfAttributes = _cast(int, numberOfAttributes)
        self.numberOfAttributes_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if SupportVector is None:
            self.SupportVector = []
        else:
            self.SupportVector = SupportVector
        self.SupportVector_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupportVectors)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupportVectors.subclass:
            return SupportVectors.subclass(*args_, **kwargs_)
        else:
            return SupportVectors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_SupportVector(self):
        return self.SupportVector
    def set_SupportVector(self, SupportVector):
        self.SupportVector = SupportVector
    def add_SupportVector(self, value):
        self.SupportVector.append(value)
    def insert_SupportVector_at(self, index, value):
        self.SupportVector.insert(index, value)
    def replace_SupportVector_at(self, index, value):
        self.SupportVector[index] = value
    def get_numberOfSupportVectors(self):
        return self.numberOfSupportVectors
    def set_numberOfSupportVectors(self, numberOfSupportVectors):
        self.numberOfSupportVectors = numberOfSupportVectors
    def get_numberOfAttributes(self):
        return self.numberOfAttributes
    def set_numberOfAttributes(self, numberOfAttributes):
        self.numberOfAttributes = numberOfAttributes
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.SupportVector
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SupportVectors', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupportVectors')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupportVectors':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupportVectors')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupportVectors', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupportVectors'):
        if self.numberOfSupportVectors is not None and 'numberOfSupportVectors' not in already_processed:
            already_processed.add('numberOfSupportVectors')
            outfile.write(' numberOfSupportVectors="%s"' % self.gds_format_integer(self.numberOfSupportVectors, input_name='numberOfSupportVectors'))
        if self.numberOfAttributes is not None and 'numberOfAttributes' not in already_processed:
            already_processed.add('numberOfAttributes')
            outfile.write(' numberOfAttributes="%s"' % self.gds_format_integer(self.numberOfAttributes, input_name='numberOfAttributes'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SupportVectors', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for SupportVector_ in self.SupportVector:
            namespaceprefix_ = self.SupportVector_nsprefix_ + ':' if (UseCapturedNS_ and self.SupportVector_nsprefix_) else ''
            SupportVector_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SupportVector', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfSupportVectors', node)
        if value is not None and 'numberOfSupportVectors' not in already_processed:
            already_processed.add('numberOfSupportVectors')
            self.numberOfSupportVectors = self.gds_parse_integer(value, node, 'numberOfSupportVectors')
            self.validate_INT_NUMBER(self.numberOfSupportVectors)    # validate type INT-NUMBER
        value = find_attr_value_('numberOfAttributes', node)
        if value is not None and 'numberOfAttributes' not in already_processed:
            already_processed.add('numberOfAttributes')
            self.numberOfAttributes = self.gds_parse_integer(value, node, 'numberOfAttributes')
            self.validate_INT_NUMBER(self.numberOfAttributes)    # validate type INT-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SupportVector':
            obj_ = SupportVector.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SupportVector.append(obj_)
            obj_.original_tagname_ = 'SupportVector'
# end class SupportVectors


class SupportVector(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, vectorId=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.vectorId = _cast(None, vectorId)
        self.vectorId_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupportVector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupportVector.subclass:
            return SupportVector.subclass(*args_, **kwargs_)
        else:
            return SupportVector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_vectorId(self):
        return self.vectorId
    def set_vectorId(self, vectorId):
        self.vectorId = vectorId
    def validate_VECTOR_ID(self, value):
        # Validate type VECTOR-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SupportVector', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupportVector')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupportVector':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupportVector')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupportVector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupportVector'):
        if self.vectorId is not None and 'vectorId' not in already_processed:
            already_processed.add('vectorId')
            outfile.write(' vectorId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vectorId), input_name='vectorId')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SupportVector', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vectorId', node)
        if value is not None and 'vectorId' not in already_processed:
            already_processed.add('vectorId')
            self.vectorId = value
            self.validate_VECTOR_ID(self.vectorId)    # validate type VECTOR-ID
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SupportVector


class Coefficients(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, numberOfCoefficients=None, absoluteValue='0', Extension=None, Coefficient=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.numberOfCoefficients = _cast(int, numberOfCoefficients)
        self.numberOfCoefficients_nsprefix_ = None
        self.absoluteValue = _cast(float, absoluteValue)
        self.absoluteValue_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Coefficient is None:
            self.Coefficient = []
        else:
            self.Coefficient = Coefficient
        self.Coefficient_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Coefficients)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Coefficients.subclass:
            return Coefficients.subclass(*args_, **kwargs_)
        else:
            return Coefficients(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Coefficient(self):
        return self.Coefficient
    def set_Coefficient(self, Coefficient):
        self.Coefficient = Coefficient
    def add_Coefficient(self, value):
        self.Coefficient.append(value)
    def insert_Coefficient_at(self, index, value):
        self.Coefficient.insert(index, value)
    def replace_Coefficient_at(self, index, value):
        self.Coefficient[index] = value
    def get_numberOfCoefficients(self):
        return self.numberOfCoefficients
    def set_numberOfCoefficients(self, numberOfCoefficients):
        self.numberOfCoefficients = numberOfCoefficients
    def get_absoluteValue(self):
        return self.absoluteValue
    def set_absoluteValue(self, absoluteValue):
        self.absoluteValue = absoluteValue
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.Coefficient
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Coefficients', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Coefficients')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Coefficients':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Coefficients')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Coefficients', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Coefficients'):
        if self.numberOfCoefficients is not None and 'numberOfCoefficients' not in already_processed:
            already_processed.add('numberOfCoefficients')
            outfile.write(' numberOfCoefficients="%s"' % self.gds_format_integer(self.numberOfCoefficients, input_name='numberOfCoefficients'))
        if self.absoluteValue != 0 and 'absoluteValue' not in already_processed:
            already_processed.add('absoluteValue')
            outfile.write(' absoluteValue="%s"' % self.gds_format_double(self.absoluteValue, input_name='absoluteValue'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Coefficients', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Coefficient_ in self.Coefficient:
            namespaceprefix_ = self.Coefficient_nsprefix_ + ':' if (UseCapturedNS_ and self.Coefficient_nsprefix_) else ''
            Coefficient_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Coefficient', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfCoefficients', node)
        if value is not None and 'numberOfCoefficients' not in already_processed:
            already_processed.add('numberOfCoefficients')
            self.numberOfCoefficients = self.gds_parse_integer(value, node, 'numberOfCoefficients')
            self.validate_INT_NUMBER(self.numberOfCoefficients)    # validate type INT-NUMBER
        value = find_attr_value_('absoluteValue', node)
        if value is not None and 'absoluteValue' not in already_processed:
            already_processed.add('absoluteValue')
            value = self.gds_parse_double(value, node, 'absoluteValue')
            self.absoluteValue = value
            self.validate_REAL_NUMBER(self.absoluteValue)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Coefficient':
            obj_ = Coefficient.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Coefficient.append(obj_)
            obj_.original_tagname_ = 'Coefficient'
# end class Coefficients


class Coefficient(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value='0', Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(float, value)
        self.value_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Coefficient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Coefficient.subclass:
            return Coefficient.subclass(*args_, **kwargs_)
        else:
            return Coefficient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Coefficient', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Coefficient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Coefficient':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Coefficient')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Coefficient', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Coefficient'):
        if self.value != 0 and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Coefficient', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            value = self.gds_parse_double(value, node, 'value')
            self.value = value
            self.validate_REAL_NUMBER(self.value)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Coefficient


class TextModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, numberOfTerms=None, numberOfDocuments=None, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, TextDictionary=None, TextCorpus=None, DocumentTermMatrix=None, TextModelNormalization=None, TextModelSimiliarity=None, ModelVerification=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.numberOfTerms = _cast(int, numberOfTerms)
        self.numberOfTerms_nsprefix_ = None
        self.numberOfDocuments = _cast(int, numberOfDocuments)
        self.numberOfDocuments_nsprefix_ = None
        self.MiningSchema = MiningSchema
        self.MiningSchema_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.ModelExplanation = ModelExplanation
        self.ModelExplanation_nsprefix_ = None
        self.Targets = Targets
        self.Targets_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        self.TextDictionary = TextDictionary
        self.TextDictionary_nsprefix_ = None
        self.TextCorpus = TextCorpus
        self.TextCorpus_nsprefix_ = None
        self.DocumentTermMatrix = DocumentTermMatrix
        self.DocumentTermMatrix_nsprefix_ = None
        self.TextModelNormalization = TextModelNormalization
        self.TextModelNormalization_nsprefix_ = None
        self.TextModelSimiliarity = TextModelSimiliarity
        self.TextModelSimiliarity_nsprefix_ = None
        self.ModelVerification = ModelVerification
        self.ModelVerification_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextModel.subclass:
            return TextModel.subclass(*args_, **kwargs_)
        else:
            return TextModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MiningSchema(self):
        return self.MiningSchema
    def set_MiningSchema(self, MiningSchema):
        self.MiningSchema = MiningSchema
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_ModelExplanation(self):
        return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation):
        self.ModelExplanation = ModelExplanation
    def get_Targets(self):
        return self.Targets
    def set_Targets(self, Targets):
        self.Targets = Targets
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_TextDictionary(self):
        return self.TextDictionary
    def set_TextDictionary(self, TextDictionary):
        self.TextDictionary = TextDictionary
    def get_TextCorpus(self):
        return self.TextCorpus
    def set_TextCorpus(self, TextCorpus):
        self.TextCorpus = TextCorpus
    def get_DocumentTermMatrix(self):
        return self.DocumentTermMatrix
    def set_DocumentTermMatrix(self, DocumentTermMatrix):
        self.DocumentTermMatrix = DocumentTermMatrix
    def get_TextModelNormalization(self):
        return self.TextModelNormalization
    def set_TextModelNormalization(self, TextModelNormalization):
        self.TextModelNormalization = TextModelNormalization
    def get_TextModelSimiliarity(self):
        return self.TextModelSimiliarity
    def set_TextModelSimiliarity(self, TextModelSimiliarity):
        self.TextModelSimiliarity = TextModelSimiliarity
    def get_ModelVerification(self):
        return self.ModelVerification
    def set_ModelVerification(self, ModelVerification):
        self.ModelVerification = ModelVerification
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def get_numberOfTerms(self):
        return self.numberOfTerms
    def set_numberOfTerms(self, numberOfTerms):
        self.numberOfTerms = numberOfTerms
    def get_numberOfDocuments(self):
        return self.numberOfDocuments
    def set_numberOfDocuments(self, numberOfDocuments):
        self.numberOfDocuments = numberOfDocuments
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.TextDictionary is not None or
            self.TextCorpus is not None or
            self.DocumentTermMatrix is not None or
            self.TextModelNormalization is not None or
            self.TextModelSimiliarity is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TextModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextModel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextModel')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.numberOfTerms is not None and 'numberOfTerms' not in already_processed:
            already_processed.add('numberOfTerms')
            outfile.write(' numberOfTerms="%s"' % self.gds_format_integer(self.numberOfTerms, input_name='numberOfTerms'))
        if self.numberOfDocuments is not None and 'numberOfDocuments' not in already_processed:
            already_processed.add('numberOfDocuments')
            outfile.write(' numberOfDocuments="%s"' % self.gds_format_integer(self.numberOfDocuments, input_name='numberOfDocuments'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TextModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            namespaceprefix_ = self.MiningSchema_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningSchema_nsprefix_) else ''
            self.MiningSchema.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            namespaceprefix_ = self.ModelExplanation_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelExplanation_nsprefix_) else ''
            self.ModelExplanation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            namespaceprefix_ = self.Targets_nsprefix_ + ':' if (UseCapturedNS_ and self.Targets_nsprefix_) else ''
            self.Targets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        if self.TextDictionary is not None:
            namespaceprefix_ = self.TextDictionary_nsprefix_ + ':' if (UseCapturedNS_ and self.TextDictionary_nsprefix_) else ''
            self.TextDictionary.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextDictionary', pretty_print=pretty_print)
        if self.TextCorpus is not None:
            namespaceprefix_ = self.TextCorpus_nsprefix_ + ':' if (UseCapturedNS_ and self.TextCorpus_nsprefix_) else ''
            self.TextCorpus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextCorpus', pretty_print=pretty_print)
        if self.DocumentTermMatrix is not None:
            namespaceprefix_ = self.DocumentTermMatrix_nsprefix_ + ':' if (UseCapturedNS_ and self.DocumentTermMatrix_nsprefix_) else ''
            self.DocumentTermMatrix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DocumentTermMatrix', pretty_print=pretty_print)
        if self.TextModelNormalization is not None:
            namespaceprefix_ = self.TextModelNormalization_nsprefix_ + ':' if (UseCapturedNS_ and self.TextModelNormalization_nsprefix_) else ''
            self.TextModelNormalization.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextModelNormalization', pretty_print=pretty_print)
        if self.TextModelSimiliarity is not None:
            namespaceprefix_ = self.TextModelSimiliarity_nsprefix_ + ':' if (UseCapturedNS_ and self.TextModelSimiliarity_nsprefix_) else ''
            self.TextModelSimiliarity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextModelSimiliarity', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            namespaceprefix_ = self.ModelVerification_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelVerification_nsprefix_) else ''
            self.ModelVerification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('numberOfTerms', node)
        if value is not None and 'numberOfTerms' not in already_processed:
            already_processed.add('numberOfTerms')
            self.numberOfTerms = self.gds_parse_integer(value, node, 'numberOfTerms')
        value = find_attr_value_('numberOfDocuments', node)
        if value is not None and 'numberOfDocuments' not in already_processed:
            already_processed.add('numberOfDocuments')
            self.numberOfDocuments = self.gds_parse_integer(value, node, 'numberOfDocuments')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'TextDictionary':
            obj_ = TextDictionary.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TextDictionary = obj_
            obj_.original_tagname_ = 'TextDictionary'
        elif nodeName_ == 'TextCorpus':
            obj_ = TextCorpus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TextCorpus = obj_
            obj_.original_tagname_ = 'TextCorpus'
        elif nodeName_ == 'DocumentTermMatrix':
            obj_ = DocumentTermMatrix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DocumentTermMatrix = obj_
            obj_.original_tagname_ = 'DocumentTermMatrix'
        elif nodeName_ == 'TextModelNormalization':
            obj_ = TextModelNormalization.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TextModelNormalization = obj_
            obj_.original_tagname_ = 'TextModelNormalization'
        elif nodeName_ == 'TextModelSimiliarity':
            obj_ = TextModelSimiliarity.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TextModelSimiliarity = obj_
            obj_.original_tagname_ = 'TextModelSimiliarity'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TextModel


class TextDictionary(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Taxonomy=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Taxonomy = Taxonomy
        self.Taxonomy_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextDictionary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextDictionary.subclass:
            return TextDictionary.subclass(*args_, **kwargs_)
        else:
            return TextDictionary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Taxonomy(self):
        return self.Taxonomy
    def set_Taxonomy(self, Taxonomy):
        self.Taxonomy = Taxonomy
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def _hasContent(self):
        if (
            self.Extension or
            self.Taxonomy is not None or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TextDictionary', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextDictionary')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextDictionary':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextDictionary')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextDictionary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextDictionary'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TextDictionary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Taxonomy is not None:
            namespaceprefix_ = self.Taxonomy_nsprefix_ + ':' if (UseCapturedNS_ and self.Taxonomy_nsprefix_) else ''
            self.Taxonomy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Taxonomy', pretty_print=pretty_print)
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Taxonomy':
            obj_ = Taxonomy.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Taxonomy = obj_
            obj_.original_tagname_ = 'Taxonomy'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class TextDictionary


class TextCorpus(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, TextDocument=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if TextDocument is None:
            self.TextDocument = []
        else:
            self.TextDocument = TextDocument
        self.TextDocument_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextCorpus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextCorpus.subclass:
            return TextCorpus.subclass(*args_, **kwargs_)
        else:
            return TextCorpus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_TextDocument(self):
        return self.TextDocument
    def set_TextDocument(self, TextDocument):
        self.TextDocument = TextDocument
    def add_TextDocument(self, value):
        self.TextDocument.append(value)
    def insert_TextDocument_at(self, index, value):
        self.TextDocument.insert(index, value)
    def replace_TextDocument_at(self, index, value):
        self.TextDocument[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.TextDocument
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TextCorpus', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextCorpus')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextCorpus':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextCorpus')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextCorpus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextCorpus'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TextCorpus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for TextDocument_ in self.TextDocument:
            namespaceprefix_ = self.TextDocument_nsprefix_ + ':' if (UseCapturedNS_ and self.TextDocument_nsprefix_) else ''
            TextDocument_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextDocument', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TextDocument':
            obj_ = TextDocument.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TextDocument.append(obj_)
            obj_.original_tagname_ = 'TextDocument'
# end class TextCorpus


class TextDocument(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, length=None, file=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.length = _cast(int, length)
        self.length_nsprefix_ = None
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextDocument)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextDocument.subclass:
            return TextDocument.subclass(*args_, **kwargs_)
        else:
            return TextDocument(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TextDocument', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextDocument')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextDocument':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextDocument')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextDocument', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextDocument'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_integer(self.length, input_name='length'))
        if self.file is not None and 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TextDocument', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            self.length = self.gds_parse_integer(value, node, 'length')
            self.validate_INT_NUMBER(self.length)    # validate type INT-NUMBER
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TextDocument


class DocumentTermMatrix(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Matrix = Matrix
        self.Matrix_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DocumentTermMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DocumentTermMatrix.subclass:
            return DocumentTermMatrix.subclass(*args_, **kwargs_)
        else:
            return DocumentTermMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Matrix(self):
        return self.Matrix
    def set_Matrix(self, Matrix):
        self.Matrix = Matrix
    def _hasContent(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DocumentTermMatrix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DocumentTermMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DocumentTermMatrix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DocumentTermMatrix')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DocumentTermMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DocumentTermMatrix'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DocumentTermMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            namespaceprefix_ = self.Matrix_nsprefix_ + ':' if (UseCapturedNS_ and self.Matrix_nsprefix_) else ''
            self.Matrix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Matrix', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class DocumentTermMatrix


class TextModelNormalization(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, localTermWeights='termFrequency', globalTermWeights='inverseDocumentFrequency', documentNormalization='none', Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.localTermWeights = _cast(None, localTermWeights)
        self.localTermWeights_nsprefix_ = None
        self.globalTermWeights = _cast(None, globalTermWeights)
        self.globalTermWeights_nsprefix_ = None
        self.documentNormalization = _cast(None, documentNormalization)
        self.documentNormalization_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextModelNormalization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextModelNormalization.subclass:
            return TextModelNormalization.subclass(*args_, **kwargs_)
        else:
            return TextModelNormalization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_localTermWeights(self):
        return self.localTermWeights
    def set_localTermWeights(self, localTermWeights):
        self.localTermWeights = localTermWeights
    def get_globalTermWeights(self):
        return self.globalTermWeights
    def set_globalTermWeights(self, globalTermWeights):
        self.globalTermWeights = globalTermWeights
    def get_documentNormalization(self):
        return self.documentNormalization
    def set_documentNormalization(self, documentNormalization):
        self.documentNormalization = documentNormalization
    def validate_localTermWeightsType(self, value):
        # Validate type localTermWeightsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['termFrequency', 'binary', 'logarithmic', 'augmentedNormalizedTermFrequency']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on localTermWeightsType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_globalTermWeightsType(self, value):
        # Validate type globalTermWeightsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['inverseDocumentFrequency', 'none', 'GFIDF', 'normal', 'probabilisticInverse']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on globalTermWeightsType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_documentNormalizationType(self, value):
        # Validate type documentNormalizationType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'cosine']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on documentNormalizationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TextModelNormalization', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextModelNormalization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextModelNormalization':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextModelNormalization')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextModelNormalization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextModelNormalization'):
        if self.localTermWeights != "termFrequency" and 'localTermWeights' not in already_processed:
            already_processed.add('localTermWeights')
            outfile.write(' localTermWeights=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.localTermWeights), input_name='localTermWeights')), ))
        if self.globalTermWeights != "inverseDocumentFrequency" and 'globalTermWeights' not in already_processed:
            already_processed.add('globalTermWeights')
            outfile.write(' globalTermWeights=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.globalTermWeights), input_name='globalTermWeights')), ))
        if self.documentNormalization != "none" and 'documentNormalization' not in already_processed:
            already_processed.add('documentNormalization')
            outfile.write(' documentNormalization=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.documentNormalization), input_name='documentNormalization')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TextModelNormalization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('localTermWeights', node)
        if value is not None and 'localTermWeights' not in already_processed:
            already_processed.add('localTermWeights')
            self.localTermWeights = value
            self.validate_localTermWeightsType(self.localTermWeights)    # validate type localTermWeightsType
        value = find_attr_value_('globalTermWeights', node)
        if value is not None and 'globalTermWeights' not in already_processed:
            already_processed.add('globalTermWeights')
            self.globalTermWeights = value
            self.validate_globalTermWeightsType(self.globalTermWeights)    # validate type globalTermWeightsType
        value = find_attr_value_('documentNormalization', node)
        if value is not None and 'documentNormalization' not in already_processed:
            already_processed.add('documentNormalization')
            self.documentNormalization = value
            self.validate_documentNormalizationType(self.documentNormalization)    # validate type documentNormalizationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TextModelNormalization


class TextModelSimiliarity(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, similarityType=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.similarityType = _cast(None, similarityType)
        self.similarityType_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextModelSimiliarity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextModelSimiliarity.subclass:
            return TextModelSimiliarity.subclass(*args_, **kwargs_)
        else:
            return TextModelSimiliarity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_similarityType(self):
        return self.similarityType
    def set_similarityType(self, similarityType):
        self.similarityType = similarityType
    def validate_similarityTypeType(self, value):
        # Validate type similarityTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['euclidean', 'cosine']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on similarityTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TextModelSimiliarity', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextModelSimiliarity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextModelSimiliarity':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextModelSimiliarity')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextModelSimiliarity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextModelSimiliarity'):
        if self.similarityType is not None and 'similarityType' not in already_processed:
            already_processed.add('similarityType')
            outfile.write(' similarityType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.similarityType), input_name='similarityType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TextModelSimiliarity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('similarityType', node)
        if value is not None and 'similarityType' not in already_processed:
            already_processed.add('similarityType')
            self.similarityType = value
            self.validate_similarityTypeType(self.similarityType)    # validate type similarityTypeType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TextModelSimiliarity


class GeneralRegressionModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, targetVariableName=None, modelType=None, modelName=None, functionName=None, algorithmName=None, targetReferenceCategory=None, cumulativeLink=None, linkFunction=None, linkParameter=None, trialsVariable=None, trialsValue=None, distribution=None, distParameter=None, offsetVariable=None, offsetValue=None, modelDF=None, endTimeVariable=None, startTimeVariable=None, subjectIDVariable=None, statusVariable=None, baselineStrataVariable=None, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, ParameterList=None, FactorList=None, CovariateList=None, PPMatrix=None, PCovMatrix=None, ParamMatrix=None, EventValues=None, BaseCumHazardTables=None, ModelVerification=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.targetVariableName = _cast(None, targetVariableName)
        self.targetVariableName_nsprefix_ = None
        self.modelType = _cast(None, modelType)
        self.modelType_nsprefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.targetReferenceCategory = _cast(None, targetReferenceCategory)
        self.targetReferenceCategory_nsprefix_ = None
        self.cumulativeLink = _cast(None, cumulativeLink)
        self.cumulativeLink_nsprefix_ = None
        self.linkFunction = _cast(None, linkFunction)
        self.linkFunction_nsprefix_ = None
        self.linkParameter = _cast(float, linkParameter)
        self.linkParameter_nsprefix_ = None
        self.trialsVariable = _cast(None, trialsVariable)
        self.trialsVariable_nsprefix_ = None
        self.trialsValue = _cast(int, trialsValue)
        self.trialsValue_nsprefix_ = None
        self.distribution = _cast(None, distribution)
        self.distribution_nsprefix_ = None
        self.distParameter = _cast(float, distParameter)
        self.distParameter_nsprefix_ = None
        self.offsetVariable = _cast(None, offsetVariable)
        self.offsetVariable_nsprefix_ = None
        self.offsetValue = _cast(float, offsetValue)
        self.offsetValue_nsprefix_ = None
        self.modelDF = _cast(float, modelDF)
        self.modelDF_nsprefix_ = None
        self.endTimeVariable = _cast(None, endTimeVariable)
        self.endTimeVariable_nsprefix_ = None
        self.startTimeVariable = _cast(None, startTimeVariable)
        self.startTimeVariable_nsprefix_ = None
        self.subjectIDVariable = _cast(None, subjectIDVariable)
        self.subjectIDVariable_nsprefix_ = None
        self.statusVariable = _cast(None, statusVariable)
        self.statusVariable_nsprefix_ = None
        self.baselineStrataVariable = _cast(None, baselineStrataVariable)
        self.baselineStrataVariable_nsprefix_ = None
        self.MiningSchema = MiningSchema
        self.MiningSchema_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.ModelExplanation = ModelExplanation
        self.ModelExplanation_nsprefix_ = None
        self.Targets = Targets
        self.Targets_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        self.ParameterList = ParameterList
        self.ParameterList_nsprefix_ = None
        self.FactorList = FactorList
        self.FactorList_nsprefix_ = None
        self.CovariateList = CovariateList
        self.CovariateList_nsprefix_ = None
        self.PPMatrix = PPMatrix
        self.PPMatrix_nsprefix_ = None
        self.PCovMatrix = PCovMatrix
        self.PCovMatrix_nsprefix_ = None
        self.ParamMatrix = ParamMatrix
        self.ParamMatrix_nsprefix_ = None
        self.EventValues = EventValues
        self.EventValues_nsprefix_ = None
        self.BaseCumHazardTables = BaseCumHazardTables
        self.BaseCumHazardTables_nsprefix_ = None
        self.ModelVerification = ModelVerification
        self.ModelVerification_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralRegressionModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralRegressionModel.subclass:
            return GeneralRegressionModel.subclass(*args_, **kwargs_)
        else:
            return GeneralRegressionModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MiningSchema(self):
        return self.MiningSchema
    def set_MiningSchema(self, MiningSchema):
        self.MiningSchema = MiningSchema
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_ModelExplanation(self):
        return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation):
        self.ModelExplanation = ModelExplanation
    def get_Targets(self):
        return self.Targets
    def set_Targets(self, Targets):
        self.Targets = Targets
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_ParameterList(self):
        return self.ParameterList
    def set_ParameterList(self, ParameterList):
        self.ParameterList = ParameterList
    def get_FactorList(self):
        return self.FactorList
    def set_FactorList(self, FactorList):
        self.FactorList = FactorList
    def get_CovariateList(self):
        return self.CovariateList
    def set_CovariateList(self, CovariateList):
        self.CovariateList = CovariateList
    def get_PPMatrix(self):
        return self.PPMatrix
    def set_PPMatrix(self, PPMatrix):
        self.PPMatrix = PPMatrix
    def get_PCovMatrix(self):
        return self.PCovMatrix
    def set_PCovMatrix(self, PCovMatrix):
        self.PCovMatrix = PCovMatrix
    def get_ParamMatrix(self):
        return self.ParamMatrix
    def set_ParamMatrix(self, ParamMatrix):
        self.ParamMatrix = ParamMatrix
    def get_EventValues(self):
        return self.EventValues
    def set_EventValues(self, EventValues):
        self.EventValues = EventValues
    def get_BaseCumHazardTables(self):
        return self.BaseCumHazardTables
    def set_BaseCumHazardTables(self, BaseCumHazardTables):
        self.BaseCumHazardTables = BaseCumHazardTables
    def get_ModelVerification(self):
        return self.ModelVerification
    def set_ModelVerification(self, ModelVerification):
        self.ModelVerification = ModelVerification
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_targetVariableName(self):
        return self.targetVariableName
    def set_targetVariableName(self, targetVariableName):
        self.targetVariableName = targetVariableName
    def get_modelType(self):
        return self.modelType
    def set_modelType(self, modelType):
        self.modelType = modelType
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def get_targetReferenceCategory(self):
        return self.targetReferenceCategory
    def set_targetReferenceCategory(self, targetReferenceCategory):
        self.targetReferenceCategory = targetReferenceCategory
    def get_cumulativeLink(self):
        return self.cumulativeLink
    def set_cumulativeLink(self, cumulativeLink):
        self.cumulativeLink = cumulativeLink
    def get_linkFunction(self):
        return self.linkFunction
    def set_linkFunction(self, linkFunction):
        self.linkFunction = linkFunction
    def get_linkParameter(self):
        return self.linkParameter
    def set_linkParameter(self, linkParameter):
        self.linkParameter = linkParameter
    def get_trialsVariable(self):
        return self.trialsVariable
    def set_trialsVariable(self, trialsVariable):
        self.trialsVariable = trialsVariable
    def get_trialsValue(self):
        return self.trialsValue
    def set_trialsValue(self, trialsValue):
        self.trialsValue = trialsValue
    def get_distribution(self):
        return self.distribution
    def set_distribution(self, distribution):
        self.distribution = distribution
    def get_distParameter(self):
        return self.distParameter
    def set_distParameter(self, distParameter):
        self.distParameter = distParameter
    def get_offsetVariable(self):
        return self.offsetVariable
    def set_offsetVariable(self, offsetVariable):
        self.offsetVariable = offsetVariable
    def get_offsetValue(self):
        return self.offsetValue
    def set_offsetValue(self, offsetValue):
        self.offsetValue = offsetValue
    def get_modelDF(self):
        return self.modelDF
    def set_modelDF(self, modelDF):
        self.modelDF = modelDF
    def get_endTimeVariable(self):
        return self.endTimeVariable
    def set_endTimeVariable(self, endTimeVariable):
        self.endTimeVariable = endTimeVariable
    def get_startTimeVariable(self):
        return self.startTimeVariable
    def set_startTimeVariable(self, startTimeVariable):
        self.startTimeVariable = startTimeVariable
    def get_subjectIDVariable(self):
        return self.subjectIDVariable
    def set_subjectIDVariable(self, subjectIDVariable):
        self.subjectIDVariable = subjectIDVariable
    def get_statusVariable(self):
        return self.statusVariable
    def set_statusVariable(self, statusVariable):
        self.statusVariable = statusVariable
    def get_baselineStrataVariable(self):
        return self.baselineStrataVariable
    def set_baselineStrataVariable(self, baselineStrataVariable):
        self.baselineStrataVariable = baselineStrataVariable
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_modelTypeType5(self, value):
        # Validate type modelTypeType5, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['regression', 'generalLinear', 'multinomialLogistic', 'ordinalMultinomial', 'generalizedLinear', 'CoxRegression']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on modelTypeType5' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_CUMULATIVE_LINK_FUNCTION(self, value):
        # Validate type CUMULATIVE-LINK-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['logit', 'probit', 'cloglog', 'loglog', 'cauchit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on CUMULATIVE-LINK-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_LINK_FUNCTION(self, value):
        # Validate type LINK-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['cloglog', 'identity', 'log', 'logc', 'logit', 'loglog', 'negbin', 'oddspower', 'power', 'probit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on LINK-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_distributionType(self, value):
        # Validate type distributionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['binomial', 'gamma', 'igauss', 'negbin', 'normal', 'poisson', 'tweedie']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on distributionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.ParameterList is not None or
            self.FactorList is not None or
            self.CovariateList is not None or
            self.PPMatrix is not None or
            self.PCovMatrix is not None or
            self.ParamMatrix is not None or
            self.EventValues is not None or
            self.BaseCumHazardTables is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='GeneralRegressionModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneralRegressionModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GeneralRegressionModel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralRegressionModel')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GeneralRegressionModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GeneralRegressionModel'):
        if self.targetVariableName is not None and 'targetVariableName' not in already_processed:
            already_processed.add('targetVariableName')
            outfile.write(' targetVariableName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetVariableName), input_name='targetVariableName')), ))
        if self.modelType is not None and 'modelType' not in already_processed:
            already_processed.add('modelType')
            outfile.write(' modelType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelType), input_name='modelType')), ))
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.targetReferenceCategory is not None and 'targetReferenceCategory' not in already_processed:
            already_processed.add('targetReferenceCategory')
            outfile.write(' targetReferenceCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetReferenceCategory), input_name='targetReferenceCategory')), ))
        if self.cumulativeLink is not None and 'cumulativeLink' not in already_processed:
            already_processed.add('cumulativeLink')
            outfile.write(' cumulativeLink=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cumulativeLink), input_name='cumulativeLink')), ))
        if self.linkFunction is not None and 'linkFunction' not in already_processed:
            already_processed.add('linkFunction')
            outfile.write(' linkFunction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.linkFunction), input_name='linkFunction')), ))
        if self.linkParameter is not None and 'linkParameter' not in already_processed:
            already_processed.add('linkParameter')
            outfile.write(' linkParameter="%s"' % self.gds_format_double(self.linkParameter, input_name='linkParameter'))
        if self.trialsVariable is not None and 'trialsVariable' not in already_processed:
            already_processed.add('trialsVariable')
            outfile.write(' trialsVariable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.trialsVariable), input_name='trialsVariable')), ))
        if self.trialsValue is not None and 'trialsValue' not in already_processed:
            already_processed.add('trialsValue')
            outfile.write(' trialsValue="%s"' % self.gds_format_integer(self.trialsValue, input_name='trialsValue'))
        if self.distribution is not None and 'distribution' not in already_processed:
            already_processed.add('distribution')
            outfile.write(' distribution=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.distribution), input_name='distribution')), ))
        if self.distParameter is not None and 'distParameter' not in already_processed:
            already_processed.add('distParameter')
            outfile.write(' distParameter="%s"' % self.gds_format_double(self.distParameter, input_name='distParameter'))
        if self.offsetVariable is not None and 'offsetVariable' not in already_processed:
            already_processed.add('offsetVariable')
            outfile.write(' offsetVariable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.offsetVariable), input_name='offsetVariable')), ))
        if self.offsetValue is not None and 'offsetValue' not in already_processed:
            already_processed.add('offsetValue')
            outfile.write(' offsetValue="%s"' % self.gds_format_double(self.offsetValue, input_name='offsetValue'))
        if self.modelDF is not None and 'modelDF' not in already_processed:
            already_processed.add('modelDF')
            outfile.write(' modelDF="%s"' % self.gds_format_double(self.modelDF, input_name='modelDF'))
        if self.endTimeVariable is not None and 'endTimeVariable' not in already_processed:
            already_processed.add('endTimeVariable')
            outfile.write(' endTimeVariable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.endTimeVariable), input_name='endTimeVariable')), ))
        if self.startTimeVariable is not None and 'startTimeVariable' not in already_processed:
            already_processed.add('startTimeVariable')
            outfile.write(' startTimeVariable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.startTimeVariable), input_name='startTimeVariable')), ))
        if self.subjectIDVariable is not None and 'subjectIDVariable' not in already_processed:
            already_processed.add('subjectIDVariable')
            outfile.write(' subjectIDVariable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.subjectIDVariable), input_name='subjectIDVariable')), ))
        if self.statusVariable is not None and 'statusVariable' not in already_processed:
            already_processed.add('statusVariable')
            outfile.write(' statusVariable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.statusVariable), input_name='statusVariable')), ))
        if self.baselineStrataVariable is not None and 'baselineStrataVariable' not in already_processed:
            already_processed.add('baselineStrataVariable')
            outfile.write(' baselineStrataVariable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.baselineStrataVariable), input_name='baselineStrataVariable')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='GeneralRegressionModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            namespaceprefix_ = self.MiningSchema_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningSchema_nsprefix_) else ''
            self.MiningSchema.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            namespaceprefix_ = self.ModelExplanation_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelExplanation_nsprefix_) else ''
            self.ModelExplanation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            namespaceprefix_ = self.Targets_nsprefix_ + ':' if (UseCapturedNS_ and self.Targets_nsprefix_) else ''
            self.Targets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        if self.ParameterList is not None:
            namespaceprefix_ = self.ParameterList_nsprefix_ + ':' if (UseCapturedNS_ and self.ParameterList_nsprefix_) else ''
            self.ParameterList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParameterList', pretty_print=pretty_print)
        if self.FactorList is not None:
            namespaceprefix_ = self.FactorList_nsprefix_ + ':' if (UseCapturedNS_ and self.FactorList_nsprefix_) else ''
            self.FactorList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FactorList', pretty_print=pretty_print)
        if self.CovariateList is not None:
            namespaceprefix_ = self.CovariateList_nsprefix_ + ':' if (UseCapturedNS_ and self.CovariateList_nsprefix_) else ''
            self.CovariateList.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CovariateList', pretty_print=pretty_print)
        if self.PPMatrix is not None:
            namespaceprefix_ = self.PPMatrix_nsprefix_ + ':' if (UseCapturedNS_ and self.PPMatrix_nsprefix_) else ''
            self.PPMatrix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PPMatrix', pretty_print=pretty_print)
        if self.PCovMatrix is not None:
            namespaceprefix_ = self.PCovMatrix_nsprefix_ + ':' if (UseCapturedNS_ and self.PCovMatrix_nsprefix_) else ''
            self.PCovMatrix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PCovMatrix', pretty_print=pretty_print)
        if self.ParamMatrix is not None:
            namespaceprefix_ = self.ParamMatrix_nsprefix_ + ':' if (UseCapturedNS_ and self.ParamMatrix_nsprefix_) else ''
            self.ParamMatrix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ParamMatrix', pretty_print=pretty_print)
        if self.EventValues is not None:
            namespaceprefix_ = self.EventValues_nsprefix_ + ':' if (UseCapturedNS_ and self.EventValues_nsprefix_) else ''
            self.EventValues.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EventValues', pretty_print=pretty_print)
        if self.BaseCumHazardTables is not None:
            namespaceprefix_ = self.BaseCumHazardTables_nsprefix_ + ':' if (UseCapturedNS_ and self.BaseCumHazardTables_nsprefix_) else ''
            self.BaseCumHazardTables.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BaseCumHazardTables', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            namespaceprefix_ = self.ModelVerification_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelVerification_nsprefix_) else ''
            self.ModelVerification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetVariableName', node)
        if value is not None and 'targetVariableName' not in already_processed:
            already_processed.add('targetVariableName')
            self.targetVariableName = value
            self.validate_FIELD_NAME(self.targetVariableName)    # validate type FIELD-NAME
        value = find_attr_value_('modelType', node)
        if value is not None and 'modelType' not in already_processed:
            already_processed.add('modelType')
            self.modelType = value
            self.validate_modelTypeType5(self.modelType)    # validate type modelTypeType5
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('targetReferenceCategory', node)
        if value is not None and 'targetReferenceCategory' not in already_processed:
            already_processed.add('targetReferenceCategory')
            self.targetReferenceCategory = value
        value = find_attr_value_('cumulativeLink', node)
        if value is not None and 'cumulativeLink' not in already_processed:
            already_processed.add('cumulativeLink')
            self.cumulativeLink = value
            self.validate_CUMULATIVE_LINK_FUNCTION(self.cumulativeLink)    # validate type CUMULATIVE-LINK-FUNCTION
        value = find_attr_value_('linkFunction', node)
        if value is not None and 'linkFunction' not in already_processed:
            already_processed.add('linkFunction')
            self.linkFunction = value
            self.validate_LINK_FUNCTION(self.linkFunction)    # validate type LINK-FUNCTION
        value = find_attr_value_('linkParameter', node)
        if value is not None and 'linkParameter' not in already_processed:
            already_processed.add('linkParameter')
            value = self.gds_parse_double(value, node, 'linkParameter')
            self.linkParameter = value
            self.validate_REAL_NUMBER(self.linkParameter)    # validate type REAL-NUMBER
        value = find_attr_value_('trialsVariable', node)
        if value is not None and 'trialsVariable' not in already_processed:
            already_processed.add('trialsVariable')
            self.trialsVariable = value
            self.validate_FIELD_NAME(self.trialsVariable)    # validate type FIELD-NAME
        value = find_attr_value_('trialsValue', node)
        if value is not None and 'trialsValue' not in already_processed:
            already_processed.add('trialsValue')
            self.trialsValue = self.gds_parse_integer(value, node, 'trialsValue')
            self.validate_INT_NUMBER(self.trialsValue)    # validate type INT-NUMBER
        value = find_attr_value_('distribution', node)
        if value is not None and 'distribution' not in already_processed:
            already_processed.add('distribution')
            self.distribution = value
            self.validate_distributionType(self.distribution)    # validate type distributionType
        value = find_attr_value_('distParameter', node)
        if value is not None and 'distParameter' not in already_processed:
            already_processed.add('distParameter')
            value = self.gds_parse_double(value, node, 'distParameter')
            self.distParameter = value
            self.validate_REAL_NUMBER(self.distParameter)    # validate type REAL-NUMBER
        value = find_attr_value_('offsetVariable', node)
        if value is not None and 'offsetVariable' not in already_processed:
            already_processed.add('offsetVariable')
            self.offsetVariable = value
            self.validate_FIELD_NAME(self.offsetVariable)    # validate type FIELD-NAME
        value = find_attr_value_('offsetValue', node)
        if value is not None and 'offsetValue' not in already_processed:
            already_processed.add('offsetValue')
            value = self.gds_parse_double(value, node, 'offsetValue')
            self.offsetValue = value
            self.validate_REAL_NUMBER(self.offsetValue)    # validate type REAL-NUMBER
        value = find_attr_value_('modelDF', node)
        if value is not None and 'modelDF' not in already_processed:
            already_processed.add('modelDF')
            value = self.gds_parse_double(value, node, 'modelDF')
            self.modelDF = value
            self.validate_REAL_NUMBER(self.modelDF)    # validate type REAL-NUMBER
        value = find_attr_value_('endTimeVariable', node)
        if value is not None and 'endTimeVariable' not in already_processed:
            already_processed.add('endTimeVariable')
            self.endTimeVariable = value
            self.validate_FIELD_NAME(self.endTimeVariable)    # validate type FIELD-NAME
        value = find_attr_value_('startTimeVariable', node)
        if value is not None and 'startTimeVariable' not in already_processed:
            already_processed.add('startTimeVariable')
            self.startTimeVariable = value
            self.validate_FIELD_NAME(self.startTimeVariable)    # validate type FIELD-NAME
        value = find_attr_value_('subjectIDVariable', node)
        if value is not None and 'subjectIDVariable' not in already_processed:
            already_processed.add('subjectIDVariable')
            self.subjectIDVariable = value
            self.validate_FIELD_NAME(self.subjectIDVariable)    # validate type FIELD-NAME
        value = find_attr_value_('statusVariable', node)
        if value is not None and 'statusVariable' not in already_processed:
            already_processed.add('statusVariable')
            self.statusVariable = value
            self.validate_FIELD_NAME(self.statusVariable)    # validate type FIELD-NAME
        value = find_attr_value_('baselineStrataVariable', node)
        if value is not None and 'baselineStrataVariable' not in already_processed:
            already_processed.add('baselineStrataVariable')
            self.baselineStrataVariable = value
            self.validate_FIELD_NAME(self.baselineStrataVariable)    # validate type FIELD-NAME
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'ParameterList':
            obj_ = ParameterList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParameterList = obj_
            obj_.original_tagname_ = 'ParameterList'
        elif nodeName_ == 'FactorList':
            obj_ = FactorList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FactorList = obj_
            obj_.original_tagname_ = 'FactorList'
        elif nodeName_ == 'CovariateList':
            obj_ = CovariateList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CovariateList = obj_
            obj_.original_tagname_ = 'CovariateList'
        elif nodeName_ == 'PPMatrix':
            obj_ = PPMatrix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PPMatrix = obj_
            obj_.original_tagname_ = 'PPMatrix'
        elif nodeName_ == 'PCovMatrix':
            obj_ = PCovMatrix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PCovMatrix = obj_
            obj_.original_tagname_ = 'PCovMatrix'
        elif nodeName_ == 'ParamMatrix':
            obj_ = ParamMatrix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ParamMatrix = obj_
            obj_.original_tagname_ = 'ParamMatrix'
        elif nodeName_ == 'EventValues':
            obj_ = EventValues.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EventValues = obj_
            obj_.original_tagname_ = 'EventValues'
        elif nodeName_ == 'BaseCumHazardTables':
            obj_ = BaseCumHazardTables.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BaseCumHazardTables = obj_
            obj_.original_tagname_ = 'BaseCumHazardTables'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class GeneralRegressionModel


class ParameterList(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Parameter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        self.Parameter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParameterList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParameterList.subclass:
            return ParameterList.subclass(*args_, **kwargs_)
        else:
            return ParameterList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Parameter(self):
        return self.Parameter
    def set_Parameter(self, Parameter):
        self.Parameter = Parameter
    def add_Parameter(self, value):
        self.Parameter.append(value)
    def insert_Parameter_at(self, index, value):
        self.Parameter.insert(index, value)
    def replace_Parameter_at(self, index, value):
        self.Parameter[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.Parameter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ParameterList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParameterList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParameterList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParameterList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParameterList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParameterList'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ParameterList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Parameter_ in self.Parameter:
            namespaceprefix_ = self.Parameter_nsprefix_ + ':' if (UseCapturedNS_ and self.Parameter_nsprefix_) else ''
            Parameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Parameter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Parameter':
            obj_ = Parameter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Parameter.append(obj_)
            obj_.original_tagname_ = 'Parameter'
# end class ParameterList


class Parameter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, label=None, referencePoint='0', Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.referencePoint = _cast(float, referencePoint)
        self.referencePoint_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Parameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Parameter.subclass:
            return Parameter.subclass(*args_, **kwargs_)
        else:
            return Parameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_referencePoint(self):
        return self.referencePoint
    def set_referencePoint(self, referencePoint):
        self.referencePoint = referencePoint
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Parameter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Parameter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Parameter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Parameter')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Parameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Parameter'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.referencePoint != 0 and 'referencePoint' not in already_processed:
            already_processed.add('referencePoint')
            outfile.write(' referencePoint="%s"' % self.gds_format_double(self.referencePoint, input_name='referencePoint'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Parameter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('referencePoint', node)
        if value is not None and 'referencePoint' not in already_processed:
            already_processed.add('referencePoint')
            value = self.gds_parse_double(value, node, 'referencePoint')
            self.referencePoint = value
            self.validate_REAL_NUMBER(self.referencePoint)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Parameter


class FactorList(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Predictor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Predictor is None:
            self.Predictor = []
        else:
            self.Predictor = Predictor
        self.Predictor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FactorList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FactorList.subclass:
            return FactorList.subclass(*args_, **kwargs_)
        else:
            return FactorList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Predictor(self):
        return self.Predictor
    def set_Predictor(self, Predictor):
        self.Predictor = Predictor
    def add_Predictor(self, value):
        self.Predictor.append(value)
    def insert_Predictor_at(self, index, value):
        self.Predictor.insert(index, value)
    def replace_Predictor_at(self, index, value):
        self.Predictor[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.Predictor
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='FactorList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FactorList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FactorList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FactorList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FactorList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FactorList'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='FactorList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Predictor_ in self.Predictor:
            namespaceprefix_ = self.Predictor_nsprefix_ + ':' if (UseCapturedNS_ and self.Predictor_nsprefix_) else ''
            Predictor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Predictor', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Predictor':
            obj_ = Predictor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Predictor.append(obj_)
            obj_.original_tagname_ = 'Predictor'
# end class FactorList


class CovariateList(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Predictor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Predictor is None:
            self.Predictor = []
        else:
            self.Predictor = Predictor
        self.Predictor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CovariateList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CovariateList.subclass:
            return CovariateList.subclass(*args_, **kwargs_)
        else:
            return CovariateList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Predictor(self):
        return self.Predictor
    def set_Predictor(self, Predictor):
        self.Predictor = Predictor
    def add_Predictor(self, value):
        self.Predictor.append(value)
    def insert_Predictor_at(self, index, value):
        self.Predictor.insert(index, value)
    def replace_Predictor_at(self, index, value):
        self.Predictor[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.Predictor
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CovariateList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CovariateList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CovariateList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CovariateList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CovariateList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CovariateList'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CovariateList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Predictor_ in self.Predictor:
            namespaceprefix_ = self.Predictor_nsprefix_ + ':' if (UseCapturedNS_ and self.Predictor_nsprefix_) else ''
            Predictor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Predictor', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Predictor':
            obj_ = Predictor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Predictor.append(obj_)
            obj_.original_tagname_ = 'Predictor'
# end class CovariateList


class Predictor(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, contrastMatrixType=None, Extension=None, Matrix=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.contrastMatrixType = _cast(None, contrastMatrixType)
        self.contrastMatrixType_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Matrix = Matrix
        self.Matrix_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Predictor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Predictor.subclass:
            return Predictor.subclass(*args_, **kwargs_)
        else:
            return Predictor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Matrix(self):
        return self.Matrix
    def set_Matrix(self, Matrix):
        self.Matrix = Matrix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_contrastMatrixType(self):
        return self.contrastMatrixType
    def set_contrastMatrixType(self, contrastMatrixType):
        self.contrastMatrixType = contrastMatrixType
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Predictor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Predictor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Predictor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Predictor')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Predictor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Predictor'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.contrastMatrixType is not None and 'contrastMatrixType' not in already_processed:
            already_processed.add('contrastMatrixType')
            outfile.write(' contrastMatrixType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contrastMatrixType), input_name='contrastMatrixType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Predictor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            namespaceprefix_ = self.Matrix_nsprefix_ + ':' if (UseCapturedNS_ and self.Matrix_nsprefix_) else ''
            self.Matrix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Matrix', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('contrastMatrixType', node)
        if value is not None and 'contrastMatrixType' not in already_processed:
            already_processed.add('contrastMatrixType')
            self.contrastMatrixType = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class Predictor


class PPMatrix(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, PPCell=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if PPCell is None:
            self.PPCell = []
        else:
            self.PPCell = PPCell
        self.PPCell_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PPMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PPMatrix.subclass:
            return PPMatrix.subclass(*args_, **kwargs_)
        else:
            return PPMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_PPCell(self):
        return self.PPCell
    def set_PPCell(self, PPCell):
        self.PPCell = PPCell
    def add_PPCell(self, value):
        self.PPCell.append(value)
    def insert_PPCell_at(self, index, value):
        self.PPCell.insert(index, value)
    def replace_PPCell_at(self, index, value):
        self.PPCell[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.PPCell
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PPMatrix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PPMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PPMatrix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPMatrix')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PPMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PPMatrix'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PPMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for PPCell_ in self.PPCell:
            namespaceprefix_ = self.PPCell_nsprefix_ + ':' if (UseCapturedNS_ and self.PPCell_nsprefix_) else ''
            PPCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PPCell', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'PPCell':
            obj_ = PPCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PPCell.append(obj_)
            obj_.original_tagname_ = 'PPCell'
# end class PPMatrix


class PPCell(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value=None, predictorName=None, parameterName=None, targetCategory=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.predictorName = _cast(None, predictorName)
        self.predictorName_nsprefix_ = None
        self.parameterName = _cast(None, parameterName)
        self.parameterName_nsprefix_ = None
        self.targetCategory = _cast(None, targetCategory)
        self.targetCategory_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PPCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PPCell.subclass:
            return PPCell.subclass(*args_, **kwargs_)
        else:
            return PPCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_predictorName(self):
        return self.predictorName
    def set_predictorName(self, predictorName):
        self.predictorName = predictorName
    def get_parameterName(self):
        return self.parameterName
    def set_parameterName(self, parameterName):
        self.parameterName = parameterName
    def get_targetCategory(self):
        return self.targetCategory
    def set_targetCategory(self, targetCategory):
        self.targetCategory = targetCategory
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PPCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PPCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PPCell':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PPCell')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PPCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PPCell'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.predictorName is not None and 'predictorName' not in already_processed:
            already_processed.add('predictorName')
            outfile.write(' predictorName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.predictorName), input_name='predictorName')), ))
        if self.parameterName is not None and 'parameterName' not in already_processed:
            already_processed.add('parameterName')
            outfile.write(' parameterName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parameterName), input_name='parameterName')), ))
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            outfile.write(' targetCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetCategory), input_name='targetCategory')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PPCell', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('predictorName', node)
        if value is not None and 'predictorName' not in already_processed:
            already_processed.add('predictorName')
            self.predictorName = value
            self.validate_FIELD_NAME(self.predictorName)    # validate type FIELD-NAME
        value = find_attr_value_('parameterName', node)
        if value is not None and 'parameterName' not in already_processed:
            already_processed.add('parameterName')
            self.parameterName = value
        value = find_attr_value_('targetCategory', node)
        if value is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            self.targetCategory = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class PPCell


class PCovMatrix(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, Extension=None, PCovCell=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if PCovCell is None:
            self.PCovCell = []
        else:
            self.PCovCell = PCovCell
        self.PCovCell_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PCovMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PCovMatrix.subclass:
            return PCovMatrix.subclass(*args_, **kwargs_)
        else:
            return PCovMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_PCovCell(self):
        return self.PCovCell
    def set_PCovCell(self, PCovCell):
        self.PCovCell = PCovCell
    def add_PCovCell(self, value):
        self.PCovCell.append(value)
    def insert_PCovCell_at(self, index, value):
        self.PCovCell.insert(index, value)
    def replace_PCovCell_at(self, index, value):
        self.PCovCell[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_typeType6(self, value):
        # Validate type typeType6, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['model', 'robust']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType6' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.PCovCell
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PCovMatrix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PCovMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PCovMatrix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PCovMatrix')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PCovMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PCovMatrix'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PCovMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for PCovCell_ in self.PCovCell:
            namespaceprefix_ = self.PCovCell_nsprefix_ + ':' if (UseCapturedNS_ and self.PCovCell_nsprefix_) else ''
            PCovCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PCovCell', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType6(self.type_)    # validate type typeType6
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'PCovCell':
            obj_ = PCovCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PCovCell.append(obj_)
            obj_.original_tagname_ = 'PCovCell'
# end class PCovMatrix


class PCovCell(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, pRow=None, pCol=None, tRow=None, tCol=None, value=None, targetCategory=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.pRow = _cast(None, pRow)
        self.pRow_nsprefix_ = None
        self.pCol = _cast(None, pCol)
        self.pCol_nsprefix_ = None
        self.tRow = _cast(None, tRow)
        self.tRow_nsprefix_ = None
        self.tCol = _cast(None, tCol)
        self.tCol_nsprefix_ = None
        self.value = _cast(float, value)
        self.value_nsprefix_ = None
        self.targetCategory = _cast(None, targetCategory)
        self.targetCategory_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PCovCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PCovCell.subclass:
            return PCovCell.subclass(*args_, **kwargs_)
        else:
            return PCovCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_pRow(self):
        return self.pRow
    def set_pRow(self, pRow):
        self.pRow = pRow
    def get_pCol(self):
        return self.pCol
    def set_pCol(self, pCol):
        self.pCol = pCol
    def get_tRow(self):
        return self.tRow
    def set_tRow(self, tRow):
        self.tRow = tRow
    def get_tCol(self):
        return self.tCol
    def set_tCol(self, tCol):
        self.tCol = tCol
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_targetCategory(self):
        return self.targetCategory
    def set_targetCategory(self, targetCategory):
        self.targetCategory = targetCategory
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PCovCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PCovCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PCovCell':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PCovCell')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PCovCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PCovCell'):
        if self.pRow is not None and 'pRow' not in already_processed:
            already_processed.add('pRow')
            outfile.write(' pRow=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pRow), input_name='pRow')), ))
        if self.pCol is not None and 'pCol' not in already_processed:
            already_processed.add('pCol')
            outfile.write(' pCol=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.pCol), input_name='pCol')), ))
        if self.tRow is not None and 'tRow' not in already_processed:
            already_processed.add('tRow')
            outfile.write(' tRow=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tRow), input_name='tRow')), ))
        if self.tCol is not None and 'tCol' not in already_processed:
            already_processed.add('tCol')
            outfile.write(' tCol=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tCol), input_name='tCol')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            outfile.write(' targetCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetCategory), input_name='targetCategory')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PCovCell', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pRow', node)
        if value is not None and 'pRow' not in already_processed:
            already_processed.add('pRow')
            self.pRow = value
        value = find_attr_value_('pCol', node)
        if value is not None and 'pCol' not in already_processed:
            already_processed.add('pCol')
            self.pCol = value
        value = find_attr_value_('tRow', node)
        if value is not None and 'tRow' not in already_processed:
            already_processed.add('tRow')
            self.tRow = value
        value = find_attr_value_('tCol', node)
        if value is not None and 'tCol' not in already_processed:
            already_processed.add('tCol')
            self.tCol = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            value = self.gds_parse_double(value, node, 'value')
            self.value = value
            self.validate_REAL_NUMBER(self.value)    # validate type REAL-NUMBER
        value = find_attr_value_('targetCategory', node)
        if value is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            self.targetCategory = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class PCovCell


class ParamMatrix(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, PCell=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if PCell is None:
            self.PCell = []
        else:
            self.PCell = PCell
        self.PCell_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParamMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParamMatrix.subclass:
            return ParamMatrix.subclass(*args_, **kwargs_)
        else:
            return ParamMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_PCell(self):
        return self.PCell
    def set_PCell(self, PCell):
        self.PCell = PCell
    def add_PCell(self, value):
        self.PCell.append(value)
    def insert_PCell_at(self, index, value):
        self.PCell.insert(index, value)
    def replace_PCell_at(self, index, value):
        self.PCell[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.PCell
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ParamMatrix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ParamMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ParamMatrix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ParamMatrix')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ParamMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ParamMatrix'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ParamMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for PCell_ in self.PCell:
            namespaceprefix_ = self.PCell_nsprefix_ + ':' if (UseCapturedNS_ and self.PCell_nsprefix_) else ''
            PCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PCell', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'PCell':
            obj_ = PCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PCell.append(obj_)
            obj_.original_tagname_ = 'PCell'
# end class ParamMatrix


class PCell(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, targetCategory=None, parameterName=None, beta=None, df=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.targetCategory = _cast(None, targetCategory)
        self.targetCategory_nsprefix_ = None
        self.parameterName = _cast(None, parameterName)
        self.parameterName_nsprefix_ = None
        self.beta = _cast(float, beta)
        self.beta_nsprefix_ = None
        self.df = _cast(int, df)
        self.df_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PCell.subclass:
            return PCell.subclass(*args_, **kwargs_)
        else:
            return PCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_targetCategory(self):
        return self.targetCategory
    def set_targetCategory(self, targetCategory):
        self.targetCategory = targetCategory
    def get_parameterName(self):
        return self.parameterName
    def set_parameterName(self, parameterName):
        self.parameterName = parameterName
    def get_beta(self):
        return self.beta
    def set_beta(self, beta):
        self.beta = beta
    def get_df(self):
        return self.df
    def set_df(self, df):
        self.df = df
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PCell':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PCell')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PCell'):
        if self.targetCategory is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            outfile.write(' targetCategory=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetCategory), input_name='targetCategory')), ))
        if self.parameterName is not None and 'parameterName' not in already_processed:
            already_processed.add('parameterName')
            outfile.write(' parameterName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parameterName), input_name='parameterName')), ))
        if self.beta is not None and 'beta' not in already_processed:
            already_processed.add('beta')
            outfile.write(' beta="%s"' % self.gds_format_double(self.beta, input_name='beta'))
        if self.df is not None and 'df' not in already_processed:
            already_processed.add('df')
            outfile.write(' df="%s"' % self.gds_format_integer(self.df, input_name='df'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PCell', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetCategory', node)
        if value is not None and 'targetCategory' not in already_processed:
            already_processed.add('targetCategory')
            self.targetCategory = value
        value = find_attr_value_('parameterName', node)
        if value is not None and 'parameterName' not in already_processed:
            already_processed.add('parameterName')
            self.parameterName = value
        value = find_attr_value_('beta', node)
        if value is not None and 'beta' not in already_processed:
            already_processed.add('beta')
            value = self.gds_parse_double(value, node, 'beta')
            self.beta = value
            self.validate_REAL_NUMBER(self.beta)    # validate type REAL-NUMBER
        value = find_attr_value_('df', node)
        if value is not None and 'df' not in already_processed:
            already_processed.add('df')
            self.df = self.gds_parse_integer(value, node, 'df')
            self.validate_INT_NUMBER(self.df)    # validate type INT-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class PCell


class BaseCumHazardTables(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, maxTime=None, Extension=None, BaselineStratum=None, BaselineCell=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.maxTime = _cast(float, maxTime)
        self.maxTime_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if BaselineStratum is None:
            self.BaselineStratum = []
        else:
            self.BaselineStratum = BaselineStratum
        self.BaselineStratum_nsprefix_ = None
        if BaselineCell is None:
            self.BaselineCell = []
        else:
            self.BaselineCell = BaselineCell
        self.BaselineCell_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseCumHazardTables)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseCumHazardTables.subclass:
            return BaseCumHazardTables.subclass(*args_, **kwargs_)
        else:
            return BaseCumHazardTables(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_BaselineStratum(self):
        return self.BaselineStratum
    def set_BaselineStratum(self, BaselineStratum):
        self.BaselineStratum = BaselineStratum
    def add_BaselineStratum(self, value):
        self.BaselineStratum.append(value)
    def insert_BaselineStratum_at(self, index, value):
        self.BaselineStratum.insert(index, value)
    def replace_BaselineStratum_at(self, index, value):
        self.BaselineStratum[index] = value
    def get_BaselineCell(self):
        return self.BaselineCell
    def set_BaselineCell(self, BaselineCell):
        self.BaselineCell = BaselineCell
    def add_BaselineCell(self, value):
        self.BaselineCell.append(value)
    def insert_BaselineCell_at(self, index, value):
        self.BaselineCell.insert(index, value)
    def replace_BaselineCell_at(self, index, value):
        self.BaselineCell[index] = value
    def get_maxTime(self):
        return self.maxTime
    def set_maxTime(self, maxTime):
        self.maxTime = maxTime
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.BaselineStratum or
            self.BaselineCell
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BaseCumHazardTables', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseCumHazardTables')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BaseCumHazardTables':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseCumHazardTables')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaseCumHazardTables', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseCumHazardTables'):
        if self.maxTime is not None and 'maxTime' not in already_processed:
            already_processed.add('maxTime')
            outfile.write(' maxTime="%s"' % self.gds_format_double(self.maxTime, input_name='maxTime'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BaseCumHazardTables', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for BaselineStratum_ in self.BaselineStratum:
            namespaceprefix_ = self.BaselineStratum_nsprefix_ + ':' if (UseCapturedNS_ and self.BaselineStratum_nsprefix_) else ''
            BaselineStratum_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BaselineStratum', pretty_print=pretty_print)
        for BaselineCell_ in self.BaselineCell:
            namespaceprefix_ = self.BaselineCell_nsprefix_ + ':' if (UseCapturedNS_ and self.BaselineCell_nsprefix_) else ''
            BaselineCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BaselineCell', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maxTime', node)
        if value is not None and 'maxTime' not in already_processed:
            already_processed.add('maxTime')
            value = self.gds_parse_double(value, node, 'maxTime')
            self.maxTime = value
            self.validate_REAL_NUMBER(self.maxTime)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'BaselineStratum':
            obj_ = BaselineStratum.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BaselineStratum.append(obj_)
            obj_.original_tagname_ = 'BaselineStratum'
        elif nodeName_ == 'BaselineCell':
            obj_ = BaselineCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BaselineCell.append(obj_)
            obj_.original_tagname_ = 'BaselineCell'
# end class BaseCumHazardTables


class BaselineStratum(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value=None, label=None, maxTime=None, Extension=None, BaselineCell=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.maxTime = _cast(float, maxTime)
        self.maxTime_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if BaselineCell is None:
            self.BaselineCell = []
        else:
            self.BaselineCell = BaselineCell
        self.BaselineCell_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaselineStratum)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaselineStratum.subclass:
            return BaselineStratum.subclass(*args_, **kwargs_)
        else:
            return BaselineStratum(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_BaselineCell(self):
        return self.BaselineCell
    def set_BaselineCell(self, BaselineCell):
        self.BaselineCell = BaselineCell
    def add_BaselineCell(self, value):
        self.BaselineCell.append(value)
    def insert_BaselineCell_at(self, index, value):
        self.BaselineCell.insert(index, value)
    def replace_BaselineCell_at(self, index, value):
        self.BaselineCell[index] = value
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_maxTime(self):
        return self.maxTime
    def set_maxTime(self, maxTime):
        self.maxTime = maxTime
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.BaselineCell
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BaselineStratum', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaselineStratum')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BaselineStratum':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaselineStratum')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaselineStratum', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaselineStratum'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.maxTime is not None and 'maxTime' not in already_processed:
            already_processed.add('maxTime')
            outfile.write(' maxTime="%s"' % self.gds_format_double(self.maxTime, input_name='maxTime'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BaselineStratum', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for BaselineCell_ in self.BaselineCell:
            namespaceprefix_ = self.BaselineCell_nsprefix_ + ':' if (UseCapturedNS_ and self.BaselineCell_nsprefix_) else ''
            BaselineCell_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BaselineCell', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('maxTime', node)
        if value is not None and 'maxTime' not in already_processed:
            already_processed.add('maxTime')
            value = self.gds_parse_double(value, node, 'maxTime')
            self.maxTime = value
            self.validate_REAL_NUMBER(self.maxTime)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'BaselineCell':
            obj_ = BaselineCell.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BaselineCell.append(obj_)
            obj_.original_tagname_ = 'BaselineCell'
# end class BaselineStratum


class BaselineCell(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, time=None, cumHazard=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.time = _cast(float, time)
        self.time_nsprefix_ = None
        self.cumHazard = _cast(float, cumHazard)
        self.cumHazard_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaselineCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaselineCell.subclass:
            return BaselineCell.subclass(*args_, **kwargs_)
        else:
            return BaselineCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_cumHazard(self):
        return self.cumHazard
    def set_cumHazard(self, cumHazard):
        self.cumHazard = cumHazard
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BaselineCell', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaselineCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BaselineCell':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaselineCell')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BaselineCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaselineCell'):
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time="%s"' % self.gds_format_double(self.time, input_name='time'))
        if self.cumHazard is not None and 'cumHazard' not in already_processed:
            already_processed.add('cumHazard')
            outfile.write(' cumHazard="%s"' % self.gds_format_double(self.cumHazard, input_name='cumHazard'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BaselineCell', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            value = self.gds_parse_double(value, node, 'time')
            self.time = value
            self.validate_REAL_NUMBER(self.time)    # validate type REAL-NUMBER
        value = find_attr_value_('cumHazard', node)
        if value is not None and 'cumHazard' not in already_processed:
            already_processed.add('cumHazard')
            value = self.gds_parse_double(value, node, 'cumHazard')
            self.cumHazard = value
            self.validate_REAL_NUMBER(self.cumHazard)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class BaselineCell


class EventValues(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Value=None, Interval=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.Value_nsprefix_ = None
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
        self.Interval_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventValues.subclass:
            return EventValues.subclass(*args_, **kwargs_)
        else:
            return EventValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Value(self):
        return self.Value
    def set_Value(self, Value):
        self.Value = Value
    def add_Value(self, value):
        self.Value.append(value)
    def insert_Value_at(self, index, value):
        self.Value.insert(index, value)
    def replace_Value_at(self, index, value):
        self.Value[index] = value
    def get_Interval(self):
        return self.Interval
    def set_Interval(self, Interval):
        self.Interval = Interval
    def add_Interval(self, value):
        self.Interval.append(value)
    def insert_Interval_at(self, index, value):
        self.Interval.insert(index, value)
    def replace_Interval_at(self, index, value):
        self.Interval[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.Value or
            self.Interval
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='EventValues', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EventValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EventValues':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EventValues')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EventValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EventValues'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='EventValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Value_ in self.Value:
            namespaceprefix_ = self.Value_nsprefix_ + ':' if (UseCapturedNS_ and self.Value_nsprefix_) else ''
            Value_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Value', pretty_print=pretty_print)
        for Interval_ in self.Interval:
            namespaceprefix_ = self.Interval_nsprefix_ + ':' if (UseCapturedNS_ and self.Interval_nsprefix_) else ''
            Interval_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Interval', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Value':
            obj_ = Value.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
        elif nodeName_ == 'Interval':
            obj_ = Interval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Interval.append(obj_)
            obj_.original_tagname_ = 'Interval'
# end class EventValues


class SequenceModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, numberOfTransactions=None, maxNumberOfItemsPerTransaction=None, avgNumberOfItemsPerTransaction=None, numberOfTransactionGroups=None, maxNumberOfTAsPerTAGroup=None, avgNumberOfTAsPerTAGroup=None, MiningSchema=None, ModelStats=None, LocalTransformations=None, Constraints=None, Item=None, Itemset=None, SetPredicate=None, Sequence=None, SequenceRule=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.numberOfTransactions = _cast(int, numberOfTransactions)
        self.numberOfTransactions_nsprefix_ = None
        self.maxNumberOfItemsPerTransaction = _cast(int, maxNumberOfItemsPerTransaction)
        self.maxNumberOfItemsPerTransaction_nsprefix_ = None
        self.avgNumberOfItemsPerTransaction = _cast(float, avgNumberOfItemsPerTransaction)
        self.avgNumberOfItemsPerTransaction_nsprefix_ = None
        self.numberOfTransactionGroups = _cast(int, numberOfTransactionGroups)
        self.numberOfTransactionGroups_nsprefix_ = None
        self.maxNumberOfTAsPerTAGroup = _cast(int, maxNumberOfTAsPerTAGroup)
        self.maxNumberOfTAsPerTAGroup_nsprefix_ = None
        self.avgNumberOfTAsPerTAGroup = _cast(float, avgNumberOfTAsPerTAGroup)
        self.avgNumberOfTAsPerTAGroup_nsprefix_ = None
        self.MiningSchema = MiningSchema
        self.MiningSchema_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        self.Constraints = Constraints
        self.Constraints_nsprefix_ = None
        if Item is None:
            self.Item = []
        else:
            self.Item = Item
        self.Item_nsprefix_ = None
        if Itemset is None:
            self.Itemset = []
        else:
            self.Itemset = Itemset
        self.Itemset_nsprefix_ = None
        if SetPredicate is None:
            self.SetPredicate = []
        else:
            self.SetPredicate = SetPredicate
        self.SetPredicate_nsprefix_ = None
        if Sequence is None:
            self.Sequence = []
        else:
            self.Sequence = Sequence
        self.Sequence_nsprefix_ = None
        if SequenceRule is None:
            self.SequenceRule = []
        else:
            self.SequenceRule = SequenceRule
        self.SequenceRule_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequenceModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequenceModel.subclass:
            return SequenceModel.subclass(*args_, **kwargs_)
        else:
            return SequenceModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MiningSchema(self):
        return self.MiningSchema
    def set_MiningSchema(self, MiningSchema):
        self.MiningSchema = MiningSchema
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_Constraints(self):
        return self.Constraints
    def set_Constraints(self, Constraints):
        self.Constraints = Constraints
    def get_Item(self):
        return self.Item
    def set_Item(self, Item):
        self.Item = Item
    def add_Item(self, value):
        self.Item.append(value)
    def insert_Item_at(self, index, value):
        self.Item.insert(index, value)
    def replace_Item_at(self, index, value):
        self.Item[index] = value
    def get_Itemset(self):
        return self.Itemset
    def set_Itemset(self, Itemset):
        self.Itemset = Itemset
    def add_Itemset(self, value):
        self.Itemset.append(value)
    def insert_Itemset_at(self, index, value):
        self.Itemset.insert(index, value)
    def replace_Itemset_at(self, index, value):
        self.Itemset[index] = value
    def get_SetPredicate(self):
        return self.SetPredicate
    def set_SetPredicate(self, SetPredicate):
        self.SetPredicate = SetPredicate
    def add_SetPredicate(self, value):
        self.SetPredicate.append(value)
    def insert_SetPredicate_at(self, index, value):
        self.SetPredicate.insert(index, value)
    def replace_SetPredicate_at(self, index, value):
        self.SetPredicate[index] = value
    def get_Sequence(self):
        return self.Sequence
    def set_Sequence(self, Sequence):
        self.Sequence = Sequence
    def add_Sequence(self, value):
        self.Sequence.append(value)
    def insert_Sequence_at(self, index, value):
        self.Sequence.insert(index, value)
    def replace_Sequence_at(self, index, value):
        self.Sequence[index] = value
    def get_SequenceRule(self):
        return self.SequenceRule
    def set_SequenceRule(self, SequenceRule):
        self.SequenceRule = SequenceRule
    def add_SequenceRule(self, value):
        self.SequenceRule.append(value)
    def insert_SequenceRule_at(self, index, value):
        self.SequenceRule.insert(index, value)
    def replace_SequenceRule_at(self, index, value):
        self.SequenceRule[index] = value
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def get_numberOfTransactions(self):
        return self.numberOfTransactions
    def set_numberOfTransactions(self, numberOfTransactions):
        self.numberOfTransactions = numberOfTransactions
    def get_maxNumberOfItemsPerTransaction(self):
        return self.maxNumberOfItemsPerTransaction
    def set_maxNumberOfItemsPerTransaction(self, maxNumberOfItemsPerTransaction):
        self.maxNumberOfItemsPerTransaction = maxNumberOfItemsPerTransaction
    def get_avgNumberOfItemsPerTransaction(self):
        return self.avgNumberOfItemsPerTransaction
    def set_avgNumberOfItemsPerTransaction(self, avgNumberOfItemsPerTransaction):
        self.avgNumberOfItemsPerTransaction = avgNumberOfItemsPerTransaction
    def get_numberOfTransactionGroups(self):
        return self.numberOfTransactionGroups
    def set_numberOfTransactionGroups(self, numberOfTransactionGroups):
        self.numberOfTransactionGroups = numberOfTransactionGroups
    def get_maxNumberOfTAsPerTAGroup(self):
        return self.maxNumberOfTAsPerTAGroup
    def set_maxNumberOfTAsPerTAGroup(self, maxNumberOfTAsPerTAGroup):
        self.maxNumberOfTAsPerTAGroup = maxNumberOfTAsPerTAGroup
    def get_avgNumberOfTAsPerTAGroup(self):
        return self.avgNumberOfTAsPerTAGroup
    def set_avgNumberOfTAsPerTAGroup(self, avgNumberOfTAsPerTAGroup):
        self.avgNumberOfTAsPerTAGroup = avgNumberOfTAsPerTAGroup
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.MiningSchema is not None or
            self.ModelStats is not None or
            self.LocalTransformations is not None or
            self.Constraints is not None or
            self.Item or
            self.Itemset or
            self.SetPredicate or
            self.Sequence or
            self.SequenceRule or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SequenceModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SequenceModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SequenceModel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SequenceModel')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SequenceModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SequenceModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.numberOfTransactions is not None and 'numberOfTransactions' not in already_processed:
            already_processed.add('numberOfTransactions')
            outfile.write(' numberOfTransactions="%s"' % self.gds_format_integer(self.numberOfTransactions, input_name='numberOfTransactions'))
        if self.maxNumberOfItemsPerTransaction is not None and 'maxNumberOfItemsPerTransaction' not in already_processed:
            already_processed.add('maxNumberOfItemsPerTransaction')
            outfile.write(' maxNumberOfItemsPerTransaction="%s"' % self.gds_format_integer(self.maxNumberOfItemsPerTransaction, input_name='maxNumberOfItemsPerTransaction'))
        if self.avgNumberOfItemsPerTransaction is not None and 'avgNumberOfItemsPerTransaction' not in already_processed:
            already_processed.add('avgNumberOfItemsPerTransaction')
            outfile.write(' avgNumberOfItemsPerTransaction="%s"' % self.gds_format_double(self.avgNumberOfItemsPerTransaction, input_name='avgNumberOfItemsPerTransaction'))
        if self.numberOfTransactionGroups is not None and 'numberOfTransactionGroups' not in already_processed:
            already_processed.add('numberOfTransactionGroups')
            outfile.write(' numberOfTransactionGroups="%s"' % self.gds_format_integer(self.numberOfTransactionGroups, input_name='numberOfTransactionGroups'))
        if self.maxNumberOfTAsPerTAGroup is not None and 'maxNumberOfTAsPerTAGroup' not in already_processed:
            already_processed.add('maxNumberOfTAsPerTAGroup')
            outfile.write(' maxNumberOfTAsPerTAGroup="%s"' % self.gds_format_integer(self.maxNumberOfTAsPerTAGroup, input_name='maxNumberOfTAsPerTAGroup'))
        if self.avgNumberOfTAsPerTAGroup is not None and 'avgNumberOfTAsPerTAGroup' not in already_processed:
            already_processed.add('avgNumberOfTAsPerTAGroup')
            outfile.write(' avgNumberOfTAsPerTAGroup="%s"' % self.gds_format_double(self.avgNumberOfTAsPerTAGroup, input_name='avgNumberOfTAsPerTAGroup'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SequenceModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            namespaceprefix_ = self.MiningSchema_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningSchema_nsprefix_) else ''
            self.MiningSchema.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningSchema', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        if self.Constraints is not None:
            namespaceprefix_ = self.Constraints_nsprefix_ + ':' if (UseCapturedNS_ and self.Constraints_nsprefix_) else ''
            self.Constraints.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Constraints', pretty_print=pretty_print)
        for Item_ in self.Item:
            namespaceprefix_ = self.Item_nsprefix_ + ':' if (UseCapturedNS_ and self.Item_nsprefix_) else ''
            Item_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Item', pretty_print=pretty_print)
        for Itemset_ in self.Itemset:
            namespaceprefix_ = self.Itemset_nsprefix_ + ':' if (UseCapturedNS_ and self.Itemset_nsprefix_) else ''
            Itemset_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Itemset', pretty_print=pretty_print)
        for SetPredicate_ in self.SetPredicate:
            namespaceprefix_ = self.SetPredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.SetPredicate_nsprefix_) else ''
            SetPredicate_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SetPredicate', pretty_print=pretty_print)
        for Sequence_ in self.Sequence:
            namespaceprefix_ = self.Sequence_nsprefix_ + ':' if (UseCapturedNS_ and self.Sequence_nsprefix_) else ''
            Sequence_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Sequence', pretty_print=pretty_print)
        for SequenceRule_ in self.SequenceRule:
            namespaceprefix_ = self.SequenceRule_nsprefix_ + ':' if (UseCapturedNS_ and self.SequenceRule_nsprefix_) else ''
            SequenceRule_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SequenceRule', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('numberOfTransactions', node)
        if value is not None and 'numberOfTransactions' not in already_processed:
            already_processed.add('numberOfTransactions')
            self.numberOfTransactions = self.gds_parse_integer(value, node, 'numberOfTransactions')
            self.validate_INT_NUMBER(self.numberOfTransactions)    # validate type INT-NUMBER
        value = find_attr_value_('maxNumberOfItemsPerTransaction', node)
        if value is not None and 'maxNumberOfItemsPerTransaction' not in already_processed:
            already_processed.add('maxNumberOfItemsPerTransaction')
            self.maxNumberOfItemsPerTransaction = self.gds_parse_integer(value, node, 'maxNumberOfItemsPerTransaction')
            self.validate_INT_NUMBER(self.maxNumberOfItemsPerTransaction)    # validate type INT-NUMBER
        value = find_attr_value_('avgNumberOfItemsPerTransaction', node)
        if value is not None and 'avgNumberOfItemsPerTransaction' not in already_processed:
            already_processed.add('avgNumberOfItemsPerTransaction')
            value = self.gds_parse_double(value, node, 'avgNumberOfItemsPerTransaction')
            self.avgNumberOfItemsPerTransaction = value
            self.validate_REAL_NUMBER(self.avgNumberOfItemsPerTransaction)    # validate type REAL-NUMBER
        value = find_attr_value_('numberOfTransactionGroups', node)
        if value is not None and 'numberOfTransactionGroups' not in already_processed:
            already_processed.add('numberOfTransactionGroups')
            self.numberOfTransactionGroups = self.gds_parse_integer(value, node, 'numberOfTransactionGroups')
            self.validate_INT_NUMBER(self.numberOfTransactionGroups)    # validate type INT-NUMBER
        value = find_attr_value_('maxNumberOfTAsPerTAGroup', node)
        if value is not None and 'maxNumberOfTAsPerTAGroup' not in already_processed:
            already_processed.add('maxNumberOfTAsPerTAGroup')
            self.maxNumberOfTAsPerTAGroup = self.gds_parse_integer(value, node, 'maxNumberOfTAsPerTAGroup')
            self.validate_INT_NUMBER(self.maxNumberOfTAsPerTAGroup)    # validate type INT-NUMBER
        value = find_attr_value_('avgNumberOfTAsPerTAGroup', node)
        if value is not None and 'avgNumberOfTAsPerTAGroup' not in already_processed:
            already_processed.add('avgNumberOfTAsPerTAGroup')
            value = self.gds_parse_double(value, node, 'avgNumberOfTAsPerTAGroup')
            self.avgNumberOfTAsPerTAGroup = value
            self.validate_REAL_NUMBER(self.avgNumberOfTAsPerTAGroup)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'Constraints':
            obj_ = Constraints.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Constraints = obj_
            obj_.original_tagname_ = 'Constraints'
        elif nodeName_ == 'Item':
            obj_ = Item.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Item.append(obj_)
            obj_.original_tagname_ = 'Item'
        elif nodeName_ == 'Itemset':
            obj_ = Itemset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Itemset.append(obj_)
            obj_.original_tagname_ = 'Itemset'
        elif nodeName_ == 'SetPredicate':
            obj_ = SetPredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SetPredicate.append(obj_)
            obj_.original_tagname_ = 'SetPredicate'
        elif nodeName_ == 'Sequence':
            obj_ = Sequence.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Sequence.append(obj_)
            obj_.original_tagname_ = 'Sequence'
        elif nodeName_ == 'SequenceRule':
            obj_ = SequenceRule.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SequenceRule.append(obj_)
            obj_.original_tagname_ = 'SequenceRule'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SequenceModel


class Constraints(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, minimumNumberOfItems='1', maximumNumberOfItems=None, minimumNumberOfAntecedentItems='1', maximumNumberOfAntecedentItems=None, minimumNumberOfConsequentItems='1', maximumNumberOfConsequentItems=None, minimumSupport='0', minimumConfidence='0', minimumLift='0', minimumTotalSequenceTime='0', maximumTotalSequenceTime=None, minimumItemsetSeparationTime='0', maximumItemsetSeparationTime=None, minimumAntConsSeparationTime='0', maximumAntConsSeparationTime=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.minimumNumberOfItems = _cast(int, minimumNumberOfItems)
        self.minimumNumberOfItems_nsprefix_ = None
        self.maximumNumberOfItems = _cast(int, maximumNumberOfItems)
        self.maximumNumberOfItems_nsprefix_ = None
        self.minimumNumberOfAntecedentItems = _cast(int, minimumNumberOfAntecedentItems)
        self.minimumNumberOfAntecedentItems_nsprefix_ = None
        self.maximumNumberOfAntecedentItems = _cast(int, maximumNumberOfAntecedentItems)
        self.maximumNumberOfAntecedentItems_nsprefix_ = None
        self.minimumNumberOfConsequentItems = _cast(int, minimumNumberOfConsequentItems)
        self.minimumNumberOfConsequentItems_nsprefix_ = None
        self.maximumNumberOfConsequentItems = _cast(int, maximumNumberOfConsequentItems)
        self.maximumNumberOfConsequentItems_nsprefix_ = None
        self.minimumSupport = _cast(float, minimumSupport)
        self.minimumSupport_nsprefix_ = None
        self.minimumConfidence = _cast(float, minimumConfidence)
        self.minimumConfidence_nsprefix_ = None
        self.minimumLift = _cast(float, minimumLift)
        self.minimumLift_nsprefix_ = None
        self.minimumTotalSequenceTime = _cast(float, minimumTotalSequenceTime)
        self.minimumTotalSequenceTime_nsprefix_ = None
        self.maximumTotalSequenceTime = _cast(float, maximumTotalSequenceTime)
        self.maximumTotalSequenceTime_nsprefix_ = None
        self.minimumItemsetSeparationTime = _cast(float, minimumItemsetSeparationTime)
        self.minimumItemsetSeparationTime_nsprefix_ = None
        self.maximumItemsetSeparationTime = _cast(float, maximumItemsetSeparationTime)
        self.maximumItemsetSeparationTime_nsprefix_ = None
        self.minimumAntConsSeparationTime = _cast(float, minimumAntConsSeparationTime)
        self.minimumAntConsSeparationTime_nsprefix_ = None
        self.maximumAntConsSeparationTime = _cast(float, maximumAntConsSeparationTime)
        self.maximumAntConsSeparationTime_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Constraints)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Constraints.subclass:
            return Constraints.subclass(*args_, **kwargs_)
        else:
            return Constraints(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_minimumNumberOfItems(self):
        return self.minimumNumberOfItems
    def set_minimumNumberOfItems(self, minimumNumberOfItems):
        self.minimumNumberOfItems = minimumNumberOfItems
    def get_maximumNumberOfItems(self):
        return self.maximumNumberOfItems
    def set_maximumNumberOfItems(self, maximumNumberOfItems):
        self.maximumNumberOfItems = maximumNumberOfItems
    def get_minimumNumberOfAntecedentItems(self):
        return self.minimumNumberOfAntecedentItems
    def set_minimumNumberOfAntecedentItems(self, minimumNumberOfAntecedentItems):
        self.minimumNumberOfAntecedentItems = minimumNumberOfAntecedentItems
    def get_maximumNumberOfAntecedentItems(self):
        return self.maximumNumberOfAntecedentItems
    def set_maximumNumberOfAntecedentItems(self, maximumNumberOfAntecedentItems):
        self.maximumNumberOfAntecedentItems = maximumNumberOfAntecedentItems
    def get_minimumNumberOfConsequentItems(self):
        return self.minimumNumberOfConsequentItems
    def set_minimumNumberOfConsequentItems(self, minimumNumberOfConsequentItems):
        self.minimumNumberOfConsequentItems = minimumNumberOfConsequentItems
    def get_maximumNumberOfConsequentItems(self):
        return self.maximumNumberOfConsequentItems
    def set_maximumNumberOfConsequentItems(self, maximumNumberOfConsequentItems):
        self.maximumNumberOfConsequentItems = maximumNumberOfConsequentItems
    def get_minimumSupport(self):
        return self.minimumSupport
    def set_minimumSupport(self, minimumSupport):
        self.minimumSupport = minimumSupport
    def get_minimumConfidence(self):
        return self.minimumConfidence
    def set_minimumConfidence(self, minimumConfidence):
        self.minimumConfidence = minimumConfidence
    def get_minimumLift(self):
        return self.minimumLift
    def set_minimumLift(self, minimumLift):
        self.minimumLift = minimumLift
    def get_minimumTotalSequenceTime(self):
        return self.minimumTotalSequenceTime
    def set_minimumTotalSequenceTime(self, minimumTotalSequenceTime):
        self.minimumTotalSequenceTime = minimumTotalSequenceTime
    def get_maximumTotalSequenceTime(self):
        return self.maximumTotalSequenceTime
    def set_maximumTotalSequenceTime(self, maximumTotalSequenceTime):
        self.maximumTotalSequenceTime = maximumTotalSequenceTime
    def get_minimumItemsetSeparationTime(self):
        return self.minimumItemsetSeparationTime
    def set_minimumItemsetSeparationTime(self, minimumItemsetSeparationTime):
        self.minimumItemsetSeparationTime = minimumItemsetSeparationTime
    def get_maximumItemsetSeparationTime(self):
        return self.maximumItemsetSeparationTime
    def set_maximumItemsetSeparationTime(self, maximumItemsetSeparationTime):
        self.maximumItemsetSeparationTime = maximumItemsetSeparationTime
    def get_minimumAntConsSeparationTime(self):
        return self.minimumAntConsSeparationTime
    def set_minimumAntConsSeparationTime(self, minimumAntConsSeparationTime):
        self.minimumAntConsSeparationTime = minimumAntConsSeparationTime
    def get_maximumAntConsSeparationTime(self):
        return self.maximumAntConsSeparationTime
    def set_maximumAntConsSeparationTime(self, maximumAntConsSeparationTime):
        self.maximumAntConsSeparationTime = maximumAntConsSeparationTime
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Constraints', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Constraints')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Constraints':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Constraints')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Constraints', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Constraints'):
        if self.minimumNumberOfItems != 1 and 'minimumNumberOfItems' not in already_processed:
            already_processed.add('minimumNumberOfItems')
            outfile.write(' minimumNumberOfItems="%s"' % self.gds_format_integer(self.minimumNumberOfItems, input_name='minimumNumberOfItems'))
        if self.maximumNumberOfItems is not None and 'maximumNumberOfItems' not in already_processed:
            already_processed.add('maximumNumberOfItems')
            outfile.write(' maximumNumberOfItems="%s"' % self.gds_format_integer(self.maximumNumberOfItems, input_name='maximumNumberOfItems'))
        if self.minimumNumberOfAntecedentItems != 1 and 'minimumNumberOfAntecedentItems' not in already_processed:
            already_processed.add('minimumNumberOfAntecedentItems')
            outfile.write(' minimumNumberOfAntecedentItems="%s"' % self.gds_format_integer(self.minimumNumberOfAntecedentItems, input_name='minimumNumberOfAntecedentItems'))
        if self.maximumNumberOfAntecedentItems is not None and 'maximumNumberOfAntecedentItems' not in already_processed:
            already_processed.add('maximumNumberOfAntecedentItems')
            outfile.write(' maximumNumberOfAntecedentItems="%s"' % self.gds_format_integer(self.maximumNumberOfAntecedentItems, input_name='maximumNumberOfAntecedentItems'))
        if self.minimumNumberOfConsequentItems != 1 and 'minimumNumberOfConsequentItems' not in already_processed:
            already_processed.add('minimumNumberOfConsequentItems')
            outfile.write(' minimumNumberOfConsequentItems="%s"' % self.gds_format_integer(self.minimumNumberOfConsequentItems, input_name='minimumNumberOfConsequentItems'))
        if self.maximumNumberOfConsequentItems is not None and 'maximumNumberOfConsequentItems' not in already_processed:
            already_processed.add('maximumNumberOfConsequentItems')
            outfile.write(' maximumNumberOfConsequentItems="%s"' % self.gds_format_integer(self.maximumNumberOfConsequentItems, input_name='maximumNumberOfConsequentItems'))
        if self.minimumSupport != 0 and 'minimumSupport' not in already_processed:
            already_processed.add('minimumSupport')
            outfile.write(' minimumSupport="%s"' % self.gds_format_double(self.minimumSupport, input_name='minimumSupport'))
        if self.minimumConfidence != 0 and 'minimumConfidence' not in already_processed:
            already_processed.add('minimumConfidence')
            outfile.write(' minimumConfidence="%s"' % self.gds_format_double(self.minimumConfidence, input_name='minimumConfidence'))
        if self.minimumLift != 0 and 'minimumLift' not in already_processed:
            already_processed.add('minimumLift')
            outfile.write(' minimumLift="%s"' % self.gds_format_double(self.minimumLift, input_name='minimumLift'))
        if self.minimumTotalSequenceTime != 0 and 'minimumTotalSequenceTime' not in already_processed:
            already_processed.add('minimumTotalSequenceTime')
            outfile.write(' minimumTotalSequenceTime="%s"' % self.gds_format_double(self.minimumTotalSequenceTime, input_name='minimumTotalSequenceTime'))
        if self.maximumTotalSequenceTime is not None and 'maximumTotalSequenceTime' not in already_processed:
            already_processed.add('maximumTotalSequenceTime')
            outfile.write(' maximumTotalSequenceTime="%s"' % self.gds_format_double(self.maximumTotalSequenceTime, input_name='maximumTotalSequenceTime'))
        if self.minimumItemsetSeparationTime != 0 and 'minimumItemsetSeparationTime' not in already_processed:
            already_processed.add('minimumItemsetSeparationTime')
            outfile.write(' minimumItemsetSeparationTime="%s"' % self.gds_format_double(self.minimumItemsetSeparationTime, input_name='minimumItemsetSeparationTime'))
        if self.maximumItemsetSeparationTime is not None and 'maximumItemsetSeparationTime' not in already_processed:
            already_processed.add('maximumItemsetSeparationTime')
            outfile.write(' maximumItemsetSeparationTime="%s"' % self.gds_format_double(self.maximumItemsetSeparationTime, input_name='maximumItemsetSeparationTime'))
        if self.minimumAntConsSeparationTime != 0 and 'minimumAntConsSeparationTime' not in already_processed:
            already_processed.add('minimumAntConsSeparationTime')
            outfile.write(' minimumAntConsSeparationTime="%s"' % self.gds_format_double(self.minimumAntConsSeparationTime, input_name='minimumAntConsSeparationTime'))
        if self.maximumAntConsSeparationTime is not None and 'maximumAntConsSeparationTime' not in already_processed:
            already_processed.add('maximumAntConsSeparationTime')
            outfile.write(' maximumAntConsSeparationTime="%s"' % self.gds_format_double(self.maximumAntConsSeparationTime, input_name='maximumAntConsSeparationTime'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Constraints', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimumNumberOfItems', node)
        if value is not None and 'minimumNumberOfItems' not in already_processed:
            already_processed.add('minimumNumberOfItems')
            self.minimumNumberOfItems = self.gds_parse_integer(value, node, 'minimumNumberOfItems')
            self.validate_INT_NUMBER(self.minimumNumberOfItems)    # validate type INT-NUMBER
        value = find_attr_value_('maximumNumberOfItems', node)
        if value is not None and 'maximumNumberOfItems' not in already_processed:
            already_processed.add('maximumNumberOfItems')
            self.maximumNumberOfItems = self.gds_parse_integer(value, node, 'maximumNumberOfItems')
            self.validate_INT_NUMBER(self.maximumNumberOfItems)    # validate type INT-NUMBER
        value = find_attr_value_('minimumNumberOfAntecedentItems', node)
        if value is not None and 'minimumNumberOfAntecedentItems' not in already_processed:
            already_processed.add('minimumNumberOfAntecedentItems')
            self.minimumNumberOfAntecedentItems = self.gds_parse_integer(value, node, 'minimumNumberOfAntecedentItems')
            self.validate_INT_NUMBER(self.minimumNumberOfAntecedentItems)    # validate type INT-NUMBER
        value = find_attr_value_('maximumNumberOfAntecedentItems', node)
        if value is not None and 'maximumNumberOfAntecedentItems' not in already_processed:
            already_processed.add('maximumNumberOfAntecedentItems')
            self.maximumNumberOfAntecedentItems = self.gds_parse_integer(value, node, 'maximumNumberOfAntecedentItems')
            self.validate_INT_NUMBER(self.maximumNumberOfAntecedentItems)    # validate type INT-NUMBER
        value = find_attr_value_('minimumNumberOfConsequentItems', node)
        if value is not None and 'minimumNumberOfConsequentItems' not in already_processed:
            already_processed.add('minimumNumberOfConsequentItems')
            self.minimumNumberOfConsequentItems = self.gds_parse_integer(value, node, 'minimumNumberOfConsequentItems')
            self.validate_INT_NUMBER(self.minimumNumberOfConsequentItems)    # validate type INT-NUMBER
        value = find_attr_value_('maximumNumberOfConsequentItems', node)
        if value is not None and 'maximumNumberOfConsequentItems' not in already_processed:
            already_processed.add('maximumNumberOfConsequentItems')
            self.maximumNumberOfConsequentItems = self.gds_parse_integer(value, node, 'maximumNumberOfConsequentItems')
            self.validate_INT_NUMBER(self.maximumNumberOfConsequentItems)    # validate type INT-NUMBER
        value = find_attr_value_('minimumSupport', node)
        if value is not None and 'minimumSupport' not in already_processed:
            already_processed.add('minimumSupport')
            value = self.gds_parse_double(value, node, 'minimumSupport')
            self.minimumSupport = value
            self.validate_REAL_NUMBER(self.minimumSupport)    # validate type REAL-NUMBER
        value = find_attr_value_('minimumConfidence', node)
        if value is not None and 'minimumConfidence' not in already_processed:
            already_processed.add('minimumConfidence')
            value = self.gds_parse_double(value, node, 'minimumConfidence')
            self.minimumConfidence = value
            self.validate_REAL_NUMBER(self.minimumConfidence)    # validate type REAL-NUMBER
        value = find_attr_value_('minimumLift', node)
        if value is not None and 'minimumLift' not in already_processed:
            already_processed.add('minimumLift')
            value = self.gds_parse_double(value, node, 'minimumLift')
            self.minimumLift = value
            self.validate_REAL_NUMBER(self.minimumLift)    # validate type REAL-NUMBER
        value = find_attr_value_('minimumTotalSequenceTime', node)
        if value is not None and 'minimumTotalSequenceTime' not in already_processed:
            already_processed.add('minimumTotalSequenceTime')
            value = self.gds_parse_double(value, node, 'minimumTotalSequenceTime')
            self.minimumTotalSequenceTime = value
            self.validate_REAL_NUMBER(self.minimumTotalSequenceTime)    # validate type REAL-NUMBER
        value = find_attr_value_('maximumTotalSequenceTime', node)
        if value is not None and 'maximumTotalSequenceTime' not in already_processed:
            already_processed.add('maximumTotalSequenceTime')
            value = self.gds_parse_double(value, node, 'maximumTotalSequenceTime')
            self.maximumTotalSequenceTime = value
            self.validate_REAL_NUMBER(self.maximumTotalSequenceTime)    # validate type REAL-NUMBER
        value = find_attr_value_('minimumItemsetSeparationTime', node)
        if value is not None and 'minimumItemsetSeparationTime' not in already_processed:
            already_processed.add('minimumItemsetSeparationTime')
            value = self.gds_parse_double(value, node, 'minimumItemsetSeparationTime')
            self.minimumItemsetSeparationTime = value
            self.validate_REAL_NUMBER(self.minimumItemsetSeparationTime)    # validate type REAL-NUMBER
        value = find_attr_value_('maximumItemsetSeparationTime', node)
        if value is not None and 'maximumItemsetSeparationTime' not in already_processed:
            already_processed.add('maximumItemsetSeparationTime')
            value = self.gds_parse_double(value, node, 'maximumItemsetSeparationTime')
            self.maximumItemsetSeparationTime = value
            self.validate_REAL_NUMBER(self.maximumItemsetSeparationTime)    # validate type REAL-NUMBER
        value = find_attr_value_('minimumAntConsSeparationTime', node)
        if value is not None and 'minimumAntConsSeparationTime' not in already_processed:
            already_processed.add('minimumAntConsSeparationTime')
            value = self.gds_parse_double(value, node, 'minimumAntConsSeparationTime')
            self.minimumAntConsSeparationTime = value
            self.validate_REAL_NUMBER(self.minimumAntConsSeparationTime)    # validate type REAL-NUMBER
        value = find_attr_value_('maximumAntConsSeparationTime', node)
        if value is not None and 'maximumAntConsSeparationTime' not in already_processed:
            already_processed.add('maximumAntConsSeparationTime')
            value = self.gds_parse_double(value, node, 'maximumAntConsSeparationTime')
            self.maximumAntConsSeparationTime = value
            self.validate_REAL_NUMBER(self.maximumAntConsSeparationTime)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Constraints


class SetPredicate(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, field=None, operator='supersetOf', Extension=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        self.operator = _cast(None, operator)
        self.operator_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetPredicate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetPredicate.subclass:
            return SetPredicate.subclass(*args_, **kwargs_)
        else:
            return SetPredicate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def validate_ELEMENT_ID(self, value):
        # Validate type ELEMENT-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SetPredicate', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SetPredicate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SetPredicate':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SetPredicate')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SetPredicate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SetPredicate'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.operator != "supersetOf" and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.operator), input_name='operator')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SetPredicate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ELEMENT_ID(self.id)    # validate type ELEMENT-ID
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
            self.validate_FIELD_NAME(self.field)    # validate type FIELD-NAME
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class SetPredicate


class Delimiter(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, delimiter=None, gap=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.delimiter = _cast(None, delimiter)
        self.delimiter_nsprefix_ = None
        self.gap = _cast(None, gap)
        self.gap_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Delimiter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Delimiter.subclass:
            return Delimiter.subclass(*args_, **kwargs_)
        else:
            return Delimiter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_delimiter(self):
        return self.delimiter
    def set_delimiter(self, delimiter):
        self.delimiter = delimiter
    def get_gap(self):
        return self.gap
    def set_gap(self, gap):
        self.gap = gap
    def validate_DELIMITER(self, value):
        # Validate type DELIMITER, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['sameTimeWindow', 'acrossTimeWindows']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DELIMITER' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_GAP(self, value):
        # Validate type GAP, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['true', 'false', 'unknown']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on GAP' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Delimiter', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Delimiter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Delimiter':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Delimiter')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Delimiter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Delimiter'):
        if self.delimiter is not None and 'delimiter' not in already_processed:
            already_processed.add('delimiter')
            outfile.write(' delimiter=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delimiter), input_name='delimiter')), ))
        if self.gap is not None and 'gap' not in already_processed:
            already_processed.add('gap')
            outfile.write(' gap=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gap), input_name='gap')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Delimiter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delimiter', node)
        if value is not None and 'delimiter' not in already_processed:
            already_processed.add('delimiter')
            self.delimiter = value
            self.validate_DELIMITER(self.delimiter)    # validate type DELIMITER
        value = find_attr_value_('gap', node)
        if value is not None and 'gap' not in already_processed:
            already_processed.add('gap')
            self.gap = value
            self.validate_GAP(self.gap)    # validate type GAP
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Delimiter


class Time(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, min=None, max=None, mean=None, standardDeviation=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.min = _cast(float, min)
        self.min_nsprefix_ = None
        self.max = _cast(float, max)
        self.max_nsprefix_ = None
        self.mean = _cast(float, mean)
        self.mean_nsprefix_ = None
        self.standardDeviation = _cast(float, standardDeviation)
        self.standardDeviation_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Time)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Time.subclass:
            return Time.subclass(*args_, **kwargs_)
        else:
            return Time(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_min(self):
        return self.min
    def set_min(self, min):
        self.min = min
    def get_max(self):
        return self.max
    def set_max(self, max):
        self.max = max
    def get_mean(self):
        return self.mean
    def set_mean(self, mean):
        self.mean = mean
    def get_standardDeviation(self):
        return self.standardDeviation
    def set_standardDeviation(self, standardDeviation):
        self.standardDeviation = standardDeviation
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Time', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Time')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Time':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Time')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Time', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Time'):
        if self.min is not None and 'min' not in already_processed:
            already_processed.add('min')
            outfile.write(' min="%s"' % self.gds_format_double(self.min, input_name='min'))
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max="%s"' % self.gds_format_double(self.max, input_name='max'))
        if self.mean is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            outfile.write(' mean="%s"' % self.gds_format_double(self.mean, input_name='mean'))
        if self.standardDeviation is not None and 'standardDeviation' not in already_processed:
            already_processed.add('standardDeviation')
            outfile.write(' standardDeviation="%s"' % self.gds_format_double(self.standardDeviation, input_name='standardDeviation'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Time', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('min', node)
        if value is not None and 'min' not in already_processed:
            already_processed.add('min')
            value = self.gds_parse_double(value, node, 'min')
            self.min = value
            self.validate_NUMBER(self.min)    # validate type NUMBER
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            value = self.gds_parse_double(value, node, 'max')
            self.max = value
            self.validate_NUMBER(self.max)    # validate type NUMBER
        value = find_attr_value_('mean', node)
        if value is not None and 'mean' not in already_processed:
            already_processed.add('mean')
            value = self.gds_parse_double(value, node, 'mean')
            self.mean = value
            self.validate_NUMBER(self.mean)    # validate type NUMBER
        value = find_attr_value_('standardDeviation', node)
        if value is not None and 'standardDeviation' not in already_processed:
            already_processed.add('standardDeviation')
            value = self.gds_parse_double(value, node, 'standardDeviation')
            self.standardDeviation = value
            self.validate_NUMBER(self.standardDeviation)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class Time


class Sequence(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, numberOfSets=None, occurrence=None, support=None, Extension=None, Delimiter=None, SetReference=None, Time=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.numberOfSets = _cast(int, numberOfSets)
        self.numberOfSets_nsprefix_ = None
        self.occurrence = _cast(int, occurrence)
        self.occurrence_nsprefix_ = None
        self.support = _cast(float, support)
        self.support_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if Delimiter is None:
            self.Delimiter = []
        else:
            self.Delimiter = Delimiter
        self.Delimiter_nsprefix_ = None
        if SetReference is None:
            self.SetReference = []
        else:
            self.SetReference = SetReference
        self.SetReference_nsprefix_ = None
        self.Time = Time
        self.Time_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Sequence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Sequence.subclass:
            return Sequence.subclass(*args_, **kwargs_)
        else:
            return Sequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Delimiter(self):
        return self.Delimiter
    def set_Delimiter(self, Delimiter):
        self.Delimiter = Delimiter
    def add_Delimiter(self, value):
        self.Delimiter.append(value)
    def insert_Delimiter_at(self, index, value):
        self.Delimiter.insert(index, value)
    def replace_Delimiter_at(self, index, value):
        self.Delimiter[index] = value
    def get_SetReference(self):
        return self.SetReference
    def set_SetReference(self, SetReference):
        self.SetReference = SetReference
    def add_SetReference(self, value):
        self.SetReference.append(value)
    def insert_SetReference_at(self, index, value):
        self.SetReference.insert(index, value)
    def replace_SetReference_at(self, index, value):
        self.SetReference[index] = value
    def get_Time(self):
        return self.Time
    def set_Time(self, Time):
        self.Time = Time
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_numberOfSets(self):
        return self.numberOfSets
    def set_numberOfSets(self, numberOfSets):
        self.numberOfSets = numberOfSets
    def get_occurrence(self):
        return self.occurrence
    def set_occurrence(self, occurrence):
        self.occurrence = occurrence
    def get_support(self):
        return self.support
    def set_support(self, support):
        self.support = support
    def validate_ELEMENT_ID(self, value):
        # Validate type ELEMENT-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.Delimiter or
            self.SetReference or
            self.Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Sequence', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Sequence')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Sequence':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Sequence')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Sequence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Sequence'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.numberOfSets is not None and 'numberOfSets' not in already_processed:
            already_processed.add('numberOfSets')
            outfile.write(' numberOfSets="%s"' % self.gds_format_integer(self.numberOfSets, input_name='numberOfSets'))
        if self.occurrence is not None and 'occurrence' not in already_processed:
            already_processed.add('occurrence')
            outfile.write(' occurrence="%s"' % self.gds_format_integer(self.occurrence, input_name='occurrence'))
        if self.support is not None and 'support' not in already_processed:
            already_processed.add('support')
            outfile.write(' support="%s"' % self.gds_format_double(self.support, input_name='support'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Sequence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for Delimiter_ in self.Delimiter:
            namespaceprefix_ = self.Delimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.Delimiter_nsprefix_) else ''
            Delimiter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Delimiter', pretty_print=pretty_print)
        for SetReference_ in self.SetReference:
            namespaceprefix_ = self.SetReference_nsprefix_ + ':' if (UseCapturedNS_ and self.SetReference_nsprefix_) else ''
            SetReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SetReference', pretty_print=pretty_print)
        if self.Time is not None:
            namespaceprefix_ = self.Time_nsprefix_ + ':' if (UseCapturedNS_ and self.Time_nsprefix_) else ''
            self.Time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Time', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ELEMENT_ID(self.id)    # validate type ELEMENT-ID
        value = find_attr_value_('numberOfSets', node)
        if value is not None and 'numberOfSets' not in already_processed:
            already_processed.add('numberOfSets')
            self.numberOfSets = self.gds_parse_integer(value, node, 'numberOfSets')
            self.validate_INT_NUMBER(self.numberOfSets)    # validate type INT-NUMBER
        value = find_attr_value_('occurrence', node)
        if value is not None and 'occurrence' not in already_processed:
            already_processed.add('occurrence')
            self.occurrence = self.gds_parse_integer(value, node, 'occurrence')
            self.validate_INT_NUMBER(self.occurrence)    # validate type INT-NUMBER
        value = find_attr_value_('support', node)
        if value is not None and 'support' not in already_processed:
            already_processed.add('support')
            value = self.gds_parse_double(value, node, 'support')
            self.support = value
            self.validate_REAL_NUMBER(self.support)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Delimiter':
            obj_ = Delimiter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Delimiter.append(obj_)
            obj_.original_tagname_ = 'Delimiter'
        elif nodeName_ == 'SetReference':
            obj_ = SetReference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SetReference.append(obj_)
            obj_.original_tagname_ = 'SetReference'
        elif nodeName_ == 'Time':
            obj_ = Time.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Time = obj_
            obj_.original_tagname_ = 'Time'
# end class Sequence


class SetReference(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, setId=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.setId = _cast(None, setId)
        self.setId_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetReference.subclass:
            return SetReference.subclass(*args_, **kwargs_)
        else:
            return SetReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_setId(self):
        return self.setId
    def set_setId(self, setId):
        self.setId = setId
    def validate_ELEMENT_ID(self, value):
        # Validate type ELEMENT-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SetReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SetReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SetReference':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SetReference')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SetReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SetReference'):
        if self.setId is not None and 'setId' not in already_processed:
            already_processed.add('setId')
            outfile.write(' setId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.setId), input_name='setId')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SetReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('setId', node)
        if value is not None and 'setId' not in already_processed:
            already_processed.add('setId')
            self.setId = value
            self.validate_ELEMENT_ID(self.setId)    # validate type ELEMENT-ID
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SetReference


class SequenceRule(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, numberOfSets=None, occurrence=None, support=None, confidence=None, lift=None, Extension=None, AntecedentSequence=None, Delimiter=None, ConsequentSequence=None, Time=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.numberOfSets = _cast(int, numberOfSets)
        self.numberOfSets_nsprefix_ = None
        self.occurrence = _cast(int, occurrence)
        self.occurrence_nsprefix_ = None
        self.support = _cast(float, support)
        self.support_nsprefix_ = None
        self.confidence = _cast(float, confidence)
        self.confidence_nsprefix_ = None
        self.lift = _cast(float, lift)
        self.lift_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.AntecedentSequence = AntecedentSequence
        self.AntecedentSequence_nsprefix_ = None
        self.Delimiter = Delimiter
        self.Delimiter_nsprefix_ = None
        self.ConsequentSequence = ConsequentSequence
        self.ConsequentSequence_nsprefix_ = None
        self.Time = Time
        self.Time_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequenceRule)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequenceRule.subclass:
            return SequenceRule.subclass(*args_, **kwargs_)
        else:
            return SequenceRule(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_AntecedentSequence(self):
        return self.AntecedentSequence
    def set_AntecedentSequence(self, AntecedentSequence):
        self.AntecedentSequence = AntecedentSequence
    def get_Delimiter(self):
        return self.Delimiter
    def set_Delimiter(self, Delimiter):
        self.Delimiter = Delimiter
    def get_ConsequentSequence(self):
        return self.ConsequentSequence
    def set_ConsequentSequence(self, ConsequentSequence):
        self.ConsequentSequence = ConsequentSequence
    def get_Time(self):
        return self.Time
    def set_Time(self, Time):
        self.Time = Time
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_numberOfSets(self):
        return self.numberOfSets
    def set_numberOfSets(self, numberOfSets):
        self.numberOfSets = numberOfSets
    def get_occurrence(self):
        return self.occurrence
    def set_occurrence(self, occurrence):
        self.occurrence = occurrence
    def get_support(self):
        return self.support
    def set_support(self, support):
        self.support = support
    def get_confidence(self):
        return self.confidence
    def set_confidence(self, confidence):
        self.confidence = confidence
    def get_lift(self):
        return self.lift
    def set_lift(self, lift):
        self.lift = lift
    def validate_ELEMENT_ID(self, value):
        # Validate type ELEMENT-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.AntecedentSequence is not None or
            self.Delimiter is not None or
            self.ConsequentSequence is not None or
            self.Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SequenceRule', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SequenceRule')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SequenceRule':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SequenceRule')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SequenceRule', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SequenceRule'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.numberOfSets is not None and 'numberOfSets' not in already_processed:
            already_processed.add('numberOfSets')
            outfile.write(' numberOfSets="%s"' % self.gds_format_integer(self.numberOfSets, input_name='numberOfSets'))
        if self.occurrence is not None and 'occurrence' not in already_processed:
            already_processed.add('occurrence')
            outfile.write(' occurrence="%s"' % self.gds_format_integer(self.occurrence, input_name='occurrence'))
        if self.support is not None and 'support' not in already_processed:
            already_processed.add('support')
            outfile.write(' support="%s"' % self.gds_format_double(self.support, input_name='support'))
        if self.confidence is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            outfile.write(' confidence="%s"' % self.gds_format_double(self.confidence, input_name='confidence'))
        if self.lift is not None and 'lift' not in already_processed:
            already_processed.add('lift')
            outfile.write(' lift="%s"' % self.gds_format_double(self.lift, input_name='lift'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SequenceRule', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.AntecedentSequence is not None:
            namespaceprefix_ = self.AntecedentSequence_nsprefix_ + ':' if (UseCapturedNS_ and self.AntecedentSequence_nsprefix_) else ''
            self.AntecedentSequence.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AntecedentSequence', pretty_print=pretty_print)
        if self.Delimiter is not None:
            namespaceprefix_ = self.Delimiter_nsprefix_ + ':' if (UseCapturedNS_ and self.Delimiter_nsprefix_) else ''
            self.Delimiter.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Delimiter', pretty_print=pretty_print)
        if self.ConsequentSequence is not None:
            namespaceprefix_ = self.ConsequentSequence_nsprefix_ + ':' if (UseCapturedNS_ and self.ConsequentSequence_nsprefix_) else ''
            self.ConsequentSequence.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ConsequentSequence', pretty_print=pretty_print)
        if self.Time is not None:
            namespaceprefix_ = self.Time_nsprefix_ + ':' if (UseCapturedNS_ and self.Time_nsprefix_) else ''
            self.Time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Time', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ELEMENT_ID(self.id)    # validate type ELEMENT-ID
        value = find_attr_value_('numberOfSets', node)
        if value is not None and 'numberOfSets' not in already_processed:
            already_processed.add('numberOfSets')
            self.numberOfSets = self.gds_parse_integer(value, node, 'numberOfSets')
            self.validate_INT_NUMBER(self.numberOfSets)    # validate type INT-NUMBER
        value = find_attr_value_('occurrence', node)
        if value is not None and 'occurrence' not in already_processed:
            already_processed.add('occurrence')
            self.occurrence = self.gds_parse_integer(value, node, 'occurrence')
            self.validate_INT_NUMBER(self.occurrence)    # validate type INT-NUMBER
        value = find_attr_value_('support', node)
        if value is not None and 'support' not in already_processed:
            already_processed.add('support')
            value = self.gds_parse_double(value, node, 'support')
            self.support = value
            self.validate_REAL_NUMBER(self.support)    # validate type REAL-NUMBER
        value = find_attr_value_('confidence', node)
        if value is not None and 'confidence' not in already_processed:
            already_processed.add('confidence')
            value = self.gds_parse_double(value, node, 'confidence')
            self.confidence = value
            self.validate_REAL_NUMBER(self.confidence)    # validate type REAL-NUMBER
        value = find_attr_value_('lift', node)
        if value is not None and 'lift' not in already_processed:
            already_processed.add('lift')
            value = self.gds_parse_double(value, node, 'lift')
            self.lift = value
            self.validate_REAL_NUMBER(self.lift)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'AntecedentSequence':
            obj_ = AntecedentSequence.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AntecedentSequence = obj_
            obj_.original_tagname_ = 'AntecedentSequence'
        elif nodeName_ == 'Delimiter':
            obj_ = Delimiter.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Delimiter = obj_
            obj_.original_tagname_ = 'Delimiter'
        elif nodeName_ == 'ConsequentSequence':
            obj_ = ConsequentSequence.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConsequentSequence = obj_
            obj_.original_tagname_ = 'ConsequentSequence'
        elif nodeName_ == 'Time':
            obj_ = Time.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Time = obj_
            obj_.original_tagname_ = 'Time'
# end class SequenceRule


class SequenceReference(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, seqId=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.seqId = _cast(None, seqId)
        self.seqId_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SequenceReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SequenceReference.subclass:
            return SequenceReference.subclass(*args_, **kwargs_)
        else:
            return SequenceReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_seqId(self):
        return self.seqId
    def set_seqId(self, seqId):
        self.seqId = seqId
    def validate_ELEMENT_ID(self, value):
        # Validate type ELEMENT-ID, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SequenceReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SequenceReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SequenceReference':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SequenceReference')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SequenceReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SequenceReference'):
        if self.seqId is not None and 'seqId' not in already_processed:
            already_processed.add('seqId')
            outfile.write(' seqId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.seqId), input_name='seqId')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='SequenceReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('seqId', node)
        if value is not None and 'seqId' not in already_processed:
            already_processed.add('seqId')
            self.seqId = value
            self.validate_ELEMENT_ID(self.seqId)    # validate type ELEMENT-ID
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class SequenceReference


class AntecedentSequence(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, SequenceReference=None, Time=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.SequenceReference = SequenceReference
        self.SequenceReference_nsprefix_ = None
        self.Time = Time
        self.Time_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AntecedentSequence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AntecedentSequence.subclass:
            return AntecedentSequence.subclass(*args_, **kwargs_)
        else:
            return AntecedentSequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_SequenceReference(self):
        return self.SequenceReference
    def set_SequenceReference(self, SequenceReference):
        self.SequenceReference = SequenceReference
    def get_Time(self):
        return self.Time
    def set_Time(self, Time):
        self.Time = Time
    def _hasContent(self):
        if (
            self.Extension or
            self.SequenceReference is not None or
            self.Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='AntecedentSequence', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AntecedentSequence')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AntecedentSequence':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AntecedentSequence')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AntecedentSequence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AntecedentSequence'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='AntecedentSequence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.SequenceReference is not None:
            namespaceprefix_ = self.SequenceReference_nsprefix_ + ':' if (UseCapturedNS_ and self.SequenceReference_nsprefix_) else ''
            self.SequenceReference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SequenceReference', pretty_print=pretty_print)
        if self.Time is not None:
            namespaceprefix_ = self.Time_nsprefix_ + ':' if (UseCapturedNS_ and self.Time_nsprefix_) else ''
            self.Time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Time', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SequenceReference':
            obj_ = SequenceReference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SequenceReference = obj_
            obj_.original_tagname_ = 'SequenceReference'
        elif nodeName_ == 'Time':
            obj_ = Time.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Time = obj_
            obj_.original_tagname_ = 'Time'
# end class AntecedentSequence


class ConsequentSequence(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, SequenceReference=None, Time=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.SequenceReference = SequenceReference
        self.SequenceReference_nsprefix_ = None
        self.Time = Time
        self.Time_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConsequentSequence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConsequentSequence.subclass:
            return ConsequentSequence.subclass(*args_, **kwargs_)
        else:
            return ConsequentSequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_SequenceReference(self):
        return self.SequenceReference
    def set_SequenceReference(self, SequenceReference):
        self.SequenceReference = SequenceReference
    def get_Time(self):
        return self.Time
    def set_Time(self, Time):
        self.Time = Time
    def _hasContent(self):
        if (
            self.Extension or
            self.SequenceReference is not None or
            self.Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ConsequentSequence', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConsequentSequence')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConsequentSequence':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConsequentSequence')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConsequentSequence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConsequentSequence'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ConsequentSequence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.SequenceReference is not None:
            namespaceprefix_ = self.SequenceReference_nsprefix_ + ':' if (UseCapturedNS_ and self.SequenceReference_nsprefix_) else ''
            self.SequenceReference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SequenceReference', pretty_print=pretty_print)
        if self.Time is not None:
            namespaceprefix_ = self.Time_nsprefix_ + ':' if (UseCapturedNS_ and self.Time_nsprefix_) else ''
            self.Time.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Time', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'SequenceReference':
            obj_ = SequenceReference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SequenceReference = obj_
            obj_.original_tagname_ = 'SequenceReference'
        elif nodeName_ == 'Time':
            obj_ = Time.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Time = obj_
            obj_.original_tagname_ = 'Time'
# end class ConsequentSequence


class NaiveBayesModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, threshold=None, functionName=None, algorithmName=None, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, BayesInputs=None, BayesOutput=None, ModelVerification=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.threshold = _cast(float, threshold)
        self.threshold_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.MiningSchema = MiningSchema
        self.MiningSchema_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.ModelExplanation = ModelExplanation
        self.ModelExplanation_nsprefix_ = None
        self.Targets = Targets
        self.Targets_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        self.BayesInputs = BayesInputs
        self.BayesInputs_nsprefix_ = None
        self.BayesOutput = BayesOutput
        self.BayesOutput_nsprefix_ = None
        self.ModelVerification = ModelVerification
        self.ModelVerification_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NaiveBayesModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NaiveBayesModel.subclass:
            return NaiveBayesModel.subclass(*args_, **kwargs_)
        else:
            return NaiveBayesModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MiningSchema(self):
        return self.MiningSchema
    def set_MiningSchema(self, MiningSchema):
        self.MiningSchema = MiningSchema
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_ModelExplanation(self):
        return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation):
        self.ModelExplanation = ModelExplanation
    def get_Targets(self):
        return self.Targets
    def set_Targets(self, Targets):
        self.Targets = Targets
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_BayesInputs(self):
        return self.BayesInputs
    def set_BayesInputs(self, BayesInputs):
        self.BayesInputs = BayesInputs
    def get_BayesOutput(self):
        return self.BayesOutput
    def set_BayesOutput(self, BayesOutput):
        self.BayesOutput = BayesOutput
    def get_ModelVerification(self):
        return self.ModelVerification
    def set_ModelVerification(self, ModelVerification):
        self.ModelVerification = ModelVerification
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_threshold(self):
        return self.threshold
    def set_threshold(self, threshold):
        self.threshold = threshold
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.BayesInputs is not None or
            self.BayesOutput is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NaiveBayesModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NaiveBayesModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NaiveBayesModel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NaiveBayesModel')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NaiveBayesModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NaiveBayesModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.threshold is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            outfile.write(' threshold="%s"' % self.gds_format_double(self.threshold, input_name='threshold'))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='NaiveBayesModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            namespaceprefix_ = self.MiningSchema_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningSchema_nsprefix_) else ''
            self.MiningSchema.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            namespaceprefix_ = self.ModelExplanation_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelExplanation_nsprefix_) else ''
            self.ModelExplanation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            namespaceprefix_ = self.Targets_nsprefix_ + ':' if (UseCapturedNS_ and self.Targets_nsprefix_) else ''
            self.Targets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        if self.BayesInputs is not None:
            namespaceprefix_ = self.BayesInputs_nsprefix_ + ':' if (UseCapturedNS_ and self.BayesInputs_nsprefix_) else ''
            self.BayesInputs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BayesInputs', pretty_print=pretty_print)
        if self.BayesOutput is not None:
            namespaceprefix_ = self.BayesOutput_nsprefix_ + ':' if (UseCapturedNS_ and self.BayesOutput_nsprefix_) else ''
            self.BayesOutput.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BayesOutput', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            namespaceprefix_ = self.ModelVerification_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelVerification_nsprefix_) else ''
            self.ModelVerification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('threshold', node)
        if value is not None and 'threshold' not in already_processed:
            already_processed.add('threshold')
            value = self.gds_parse_double(value, node, 'threshold')
            self.threshold = value
            self.validate_REAL_NUMBER(self.threshold)    # validate type REAL-NUMBER
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'BayesInputs':
            obj_ = BayesInputs.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BayesInputs = obj_
            obj_.original_tagname_ = 'BayesInputs'
        elif nodeName_ == 'BayesOutput':
            obj_ = BayesOutput.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BayesOutput = obj_
            obj_.original_tagname_ = 'BayesOutput'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class NaiveBayesModel


class BayesInputs(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, BayesInput=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if BayesInput is None:
            self.BayesInput = []
        else:
            self.BayesInput = BayesInput
        self.BayesInput_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BayesInputs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BayesInputs.subclass:
            return BayesInputs.subclass(*args_, **kwargs_)
        else:
            return BayesInputs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_BayesInput(self):
        return self.BayesInput
    def set_BayesInput(self, BayesInput):
        self.BayesInput = BayesInput
    def add_BayesInput(self, value):
        self.BayesInput.append(value)
    def insert_BayesInput_at(self, index, value):
        self.BayesInput.insert(index, value)
    def replace_BayesInput_at(self, index, value):
        self.BayesInput[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.BayesInput
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BayesInputs', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BayesInputs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BayesInputs':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BayesInputs')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BayesInputs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BayesInputs'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BayesInputs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for BayesInput_ in self.BayesInput:
            namespaceprefix_ = self.BayesInput_nsprefix_ + ':' if (UseCapturedNS_ and self.BayesInput_nsprefix_) else ''
            BayesInput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BayesInput', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'BayesInput':
            obj_ = BayesInput.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BayesInput.append(obj_)
            obj_.original_tagname_ = 'BayesInput'
# end class BayesInputs


class BayesInput(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, fieldName=None, Extension=None, DerivedField=None, PairCounts=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fieldName = _cast(None, fieldName)
        self.fieldName_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.DerivedField = DerivedField
        self.DerivedField_nsprefix_ = None
        if PairCounts is None:
            self.PairCounts = []
        else:
            self.PairCounts = PairCounts
        self.PairCounts_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BayesInput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BayesInput.subclass:
            return BayesInput.subclass(*args_, **kwargs_)
        else:
            return BayesInput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_DerivedField(self):
        return self.DerivedField
    def set_DerivedField(self, DerivedField):
        self.DerivedField = DerivedField
    def get_PairCounts(self):
        return self.PairCounts
    def set_PairCounts(self, PairCounts):
        self.PairCounts = PairCounts
    def add_PairCounts(self, value):
        self.PairCounts.append(value)
    def insert_PairCounts_at(self, index, value):
        self.PairCounts.insert(index, value)
    def replace_PairCounts_at(self, index, value):
        self.PairCounts[index] = value
    def get_fieldName(self):
        return self.fieldName
    def set_fieldName(self, fieldName):
        self.fieldName = fieldName
    def _hasContent(self):
        if (
            self.Extension or
            self.DerivedField is not None or
            self.PairCounts
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BayesInput', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BayesInput')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BayesInput':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BayesInput')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BayesInput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BayesInput'):
        if self.fieldName is not None and 'fieldName' not in already_processed:
            already_processed.add('fieldName')
            outfile.write(' fieldName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fieldName), input_name='fieldName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BayesInput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.DerivedField is not None:
            namespaceprefix_ = self.DerivedField_nsprefix_ + ':' if (UseCapturedNS_ and self.DerivedField_nsprefix_) else ''
            self.DerivedField.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DerivedField', pretty_print=pretty_print)
        for PairCounts_ in self.PairCounts:
            namespaceprefix_ = self.PairCounts_nsprefix_ + ':' if (UseCapturedNS_ and self.PairCounts_nsprefix_) else ''
            PairCounts_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PairCounts', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fieldName', node)
        if value is not None and 'fieldName' not in already_processed:
            already_processed.add('fieldName')
            self.fieldName = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'DerivedField':
            obj_ = DerivedField.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DerivedField = obj_
            obj_.original_tagname_ = 'DerivedField'
        elif nodeName_ == 'PairCounts':
            obj_ = PairCounts.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PairCounts.append(obj_)
            obj_.original_tagname_ = 'PairCounts'
# end class BayesInput


class BayesOutput(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, fieldName=None, Extension=None, TargetValueCounts=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.fieldName = _cast(None, fieldName)
        self.fieldName_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.TargetValueCounts = TargetValueCounts
        self.TargetValueCounts_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BayesOutput)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BayesOutput.subclass:
            return BayesOutput.subclass(*args_, **kwargs_)
        else:
            return BayesOutput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_TargetValueCounts(self):
        return self.TargetValueCounts
    def set_TargetValueCounts(self, TargetValueCounts):
        self.TargetValueCounts = TargetValueCounts
    def get_fieldName(self):
        return self.fieldName
    def set_fieldName(self, fieldName):
        self.fieldName = fieldName
    def _hasContent(self):
        if (
            self.Extension or
            self.TargetValueCounts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BayesOutput', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BayesOutput')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BayesOutput':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BayesOutput')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BayesOutput', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BayesOutput'):
        if self.fieldName is not None and 'fieldName' not in already_processed:
            already_processed.add('fieldName')
            outfile.write(' fieldName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fieldName), input_name='fieldName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BayesOutput', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.TargetValueCounts is not None:
            namespaceprefix_ = self.TargetValueCounts_nsprefix_ + ':' if (UseCapturedNS_ and self.TargetValueCounts_nsprefix_) else ''
            self.TargetValueCounts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TargetValueCounts', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fieldName', node)
        if value is not None and 'fieldName' not in already_processed:
            already_processed.add('fieldName')
            self.fieldName = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TargetValueCounts':
            obj_ = TargetValueCounts.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TargetValueCounts = obj_
            obj_.original_tagname_ = 'TargetValueCounts'
# end class BayesOutput


class PairCounts(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value=None, Extension=None, TargetValueCounts=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.TargetValueCounts = TargetValueCounts
        self.TargetValueCounts_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PairCounts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PairCounts.subclass:
            return PairCounts.subclass(*args_, **kwargs_)
        else:
            return PairCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_TargetValueCounts(self):
        return self.TargetValueCounts
    def set_TargetValueCounts(self, TargetValueCounts):
        self.TargetValueCounts = TargetValueCounts
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def _hasContent(self):
        if (
            self.Extension or
            self.TargetValueCounts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PairCounts', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PairCounts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PairCounts':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PairCounts')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PairCounts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PairCounts'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PairCounts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.TargetValueCounts is not None:
            namespaceprefix_ = self.TargetValueCounts_nsprefix_ + ':' if (UseCapturedNS_ and self.TargetValueCounts_nsprefix_) else ''
            self.TargetValueCounts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TargetValueCounts', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TargetValueCounts':
            obj_ = TargetValueCounts.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TargetValueCounts = obj_
            obj_.original_tagname_ = 'TargetValueCounts'
# end class PairCounts


class TargetValueCounts(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, TargetValueCount=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if TargetValueCount is None:
            self.TargetValueCount = []
        else:
            self.TargetValueCount = TargetValueCount
        self.TargetValueCount_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetValueCounts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetValueCounts.subclass:
            return TargetValueCounts.subclass(*args_, **kwargs_)
        else:
            return TargetValueCounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_TargetValueCount(self):
        return self.TargetValueCount
    def set_TargetValueCount(self, TargetValueCount):
        self.TargetValueCount = TargetValueCount
    def add_TargetValueCount(self, value):
        self.TargetValueCount.append(value)
    def insert_TargetValueCount_at(self, index, value):
        self.TargetValueCount.insert(index, value)
    def replace_TargetValueCount_at(self, index, value):
        self.TargetValueCount[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.TargetValueCount
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TargetValueCounts', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetValueCounts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TargetValueCounts':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TargetValueCounts')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TargetValueCounts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TargetValueCounts'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TargetValueCounts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for TargetValueCount_ in self.TargetValueCount:
            namespaceprefix_ = self.TargetValueCount_nsprefix_ + ':' if (UseCapturedNS_ and self.TargetValueCount_nsprefix_) else ''
            TargetValueCount_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TargetValueCount', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'TargetValueCount':
            obj_ = TargetValueCount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TargetValueCount.append(obj_)
            obj_.original_tagname_ = 'TargetValueCount'
# end class TargetValueCounts


class TargetValueCount(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value=None, count=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        self.count = _cast(float, count)
        self.count_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetValueCount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetValueCount.subclass:
            return TargetValueCount.subclass(*args_, **kwargs_)
        else:
            return TargetValueCount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TargetValueCount', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetValueCount')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TargetValueCount':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TargetValueCount')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TargetValueCount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TargetValueCount'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_double(self.count, input_name='count'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TargetValueCount', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            value = self.gds_parse_double(value, node, 'count')
            self.count = value
            self.validate_REAL_NUMBER(self.count)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TargetValueCount


class ModelVerification(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, recordCount=None, fieldCount=None, Extension=None, VerificationFields=None, InlineTable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.recordCount = _cast(int, recordCount)
        self.recordCount_nsprefix_ = None
        self.fieldCount = _cast(int, fieldCount)
        self.fieldCount_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.VerificationFields = VerificationFields
        self.VerificationFields_nsprefix_ = None
        self.InlineTable = InlineTable
        self.InlineTable_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModelVerification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModelVerification.subclass:
            return ModelVerification.subclass(*args_, **kwargs_)
        else:
            return ModelVerification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_VerificationFields(self):
        return self.VerificationFields
    def set_VerificationFields(self, VerificationFields):
        self.VerificationFields = VerificationFields
    def get_InlineTable(self):
        return self.InlineTable
    def set_InlineTable(self, InlineTable):
        self.InlineTable = InlineTable
    def get_recordCount(self):
        return self.recordCount
    def set_recordCount(self, recordCount):
        self.recordCount = recordCount
    def get_fieldCount(self):
        return self.fieldCount
    def set_fieldCount(self, fieldCount):
        self.fieldCount = fieldCount
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.VerificationFields is not None or
            self.InlineTable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ModelVerification', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ModelVerification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ModelVerification':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ModelVerification')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ModelVerification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ModelVerification'):
        if self.recordCount is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            outfile.write(' recordCount="%s"' % self.gds_format_integer(self.recordCount, input_name='recordCount'))
        if self.fieldCount is not None and 'fieldCount' not in already_processed:
            already_processed.add('fieldCount')
            outfile.write(' fieldCount="%s"' % self.gds_format_integer(self.fieldCount, input_name='fieldCount'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ModelVerification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.VerificationFields is not None:
            namespaceprefix_ = self.VerificationFields_nsprefix_ + ':' if (UseCapturedNS_ and self.VerificationFields_nsprefix_) else ''
            self.VerificationFields.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VerificationFields', pretty_print=pretty_print)
        if self.InlineTable is not None:
            namespaceprefix_ = self.InlineTable_nsprefix_ + ':' if (UseCapturedNS_ and self.InlineTable_nsprefix_) else ''
            self.InlineTable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='InlineTable', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('recordCount', node)
        if value is not None and 'recordCount' not in already_processed:
            already_processed.add('recordCount')
            self.recordCount = self.gds_parse_integer(value, node, 'recordCount')
            self.validate_INT_NUMBER(self.recordCount)    # validate type INT-NUMBER
        value = find_attr_value_('fieldCount', node)
        if value is not None and 'fieldCount' not in already_processed:
            already_processed.add('fieldCount')
            self.fieldCount = self.gds_parse_integer(value, node, 'fieldCount')
            self.validate_INT_NUMBER(self.fieldCount)    # validate type INT-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'VerificationFields':
            obj_ = VerificationFields.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VerificationFields = obj_
            obj_.original_tagname_ = 'VerificationFields'
        elif nodeName_ == 'InlineTable':
            obj_ = InlineTable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.InlineTable = obj_
            obj_.original_tagname_ = 'InlineTable'
# end class ModelVerification


class VerificationFields(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, VerificationField=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if VerificationField is None:
            self.VerificationField = []
        else:
            self.VerificationField = VerificationField
        self.VerificationField_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerificationFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerificationFields.subclass:
            return VerificationFields.subclass(*args_, **kwargs_)
        else:
            return VerificationFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_VerificationField(self):
        return self.VerificationField
    def set_VerificationField(self, VerificationField):
        self.VerificationField = VerificationField
    def add_VerificationField(self, value):
        self.VerificationField.append(value)
    def insert_VerificationField_at(self, index, value):
        self.VerificationField.insert(index, value)
    def replace_VerificationField_at(self, index, value):
        self.VerificationField[index] = value
    def _hasContent(self):
        if (
            self.Extension or
            self.VerificationField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='VerificationFields', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VerificationFields')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VerificationFields':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VerificationFields')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VerificationFields', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VerificationFields'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='VerificationFields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for VerificationField_ in self.VerificationField:
            namespaceprefix_ = self.VerificationField_nsprefix_ + ':' if (UseCapturedNS_ and self.VerificationField_nsprefix_) else ''
            VerificationField_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='VerificationField', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'VerificationField':
            obj_ = VerificationField.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.VerificationField.append(obj_)
            obj_.original_tagname_ = 'VerificationField'
# end class VerificationFields


class VerificationField(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, field=None, column=None, precision=1E-6, zeroThreshold=1E-16, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.field = _cast(None, field)
        self.field_nsprefix_ = None
        self.column = _cast(None, column)
        self.column_nsprefix_ = None
        self.precision = _cast(float, precision)
        self.precision_nsprefix_ = None
        self.zeroThreshold = _cast(float, zeroThreshold)
        self.zeroThreshold_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VerificationField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VerificationField.subclass:
            return VerificationField.subclass(*args_, **kwargs_)
        else:
            return VerificationField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_column(self):
        return self.column
    def set_column(self, column):
        self.column = column
    def get_precision(self):
        return self.precision
    def set_precision(self, precision):
        self.precision = precision
    def get_zeroThreshold(self):
        return self.zeroThreshold
    def set_zeroThreshold(self, zeroThreshold):
        self.zeroThreshold = zeroThreshold
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='VerificationField', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VerificationField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VerificationField':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VerificationField')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VerificationField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VerificationField'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.column is not None and 'column' not in already_processed:
            already_processed.add('column')
            outfile.write(' column=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.column), input_name='column')), ))
        if self.precision != 1E-6 and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision="%s"' % self.gds_format_double(self.precision, input_name='precision'))
        if self.zeroThreshold != 1E-16 and 'zeroThreshold' not in already_processed:
            already_processed.add('zeroThreshold')
            outfile.write(' zeroThreshold="%s"' % self.gds_format_double(self.zeroThreshold, input_name='zeroThreshold'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='VerificationField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
        value = find_attr_value_('column', node)
        if value is not None and 'column' not in already_processed:
            already_processed.add('column')
            self.column = value
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            value = self.gds_parse_double(value, node, 'precision')
            self.precision = value
        value = find_attr_value_('zeroThreshold', node)
        if value is not None and 'zeroThreshold' not in already_processed:
            already_processed.add('zeroThreshold')
            value = self.gds_parse_double(value, node, 'zeroThreshold')
            self.zeroThreshold = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class VerificationField


class ModelExplanation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, PredictiveModelQuality=None, ClusteringModelQuality=None, Correlations=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        if PredictiveModelQuality is None:
            self.PredictiveModelQuality = []
        else:
            self.PredictiveModelQuality = PredictiveModelQuality
        self.PredictiveModelQuality_nsprefix_ = None
        if ClusteringModelQuality is None:
            self.ClusteringModelQuality = []
        else:
            self.ClusteringModelQuality = ClusteringModelQuality
        self.ClusteringModelQuality_nsprefix_ = None
        self.Correlations = Correlations
        self.Correlations_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModelExplanation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModelExplanation.subclass:
            return ModelExplanation.subclass(*args_, **kwargs_)
        else:
            return ModelExplanation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_PredictiveModelQuality(self):
        return self.PredictiveModelQuality
    def set_PredictiveModelQuality(self, PredictiveModelQuality):
        self.PredictiveModelQuality = PredictiveModelQuality
    def add_PredictiveModelQuality(self, value):
        self.PredictiveModelQuality.append(value)
    def insert_PredictiveModelQuality_at(self, index, value):
        self.PredictiveModelQuality.insert(index, value)
    def replace_PredictiveModelQuality_at(self, index, value):
        self.PredictiveModelQuality[index] = value
    def get_ClusteringModelQuality(self):
        return self.ClusteringModelQuality
    def set_ClusteringModelQuality(self, ClusteringModelQuality):
        self.ClusteringModelQuality = ClusteringModelQuality
    def add_ClusteringModelQuality(self, value):
        self.ClusteringModelQuality.append(value)
    def insert_ClusteringModelQuality_at(self, index, value):
        self.ClusteringModelQuality.insert(index, value)
    def replace_ClusteringModelQuality_at(self, index, value):
        self.ClusteringModelQuality[index] = value
    def get_Correlations(self):
        return self.Correlations
    def set_Correlations(self, Correlations):
        self.Correlations = Correlations
    def _hasContent(self):
        if (
            self.Extension or
            self.PredictiveModelQuality or
            self.ClusteringModelQuality or
            self.Correlations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ModelExplanation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ModelExplanation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ModelExplanation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ModelExplanation')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ModelExplanation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ModelExplanation'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ModelExplanation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        for PredictiveModelQuality_ in self.PredictiveModelQuality:
            namespaceprefix_ = self.PredictiveModelQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.PredictiveModelQuality_nsprefix_) else ''
            PredictiveModelQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PredictiveModelQuality', pretty_print=pretty_print)
        for ClusteringModelQuality_ in self.ClusteringModelQuality:
            namespaceprefix_ = self.ClusteringModelQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.ClusteringModelQuality_nsprefix_) else ''
            ClusteringModelQuality_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClusteringModelQuality', pretty_print=pretty_print)
        if self.Correlations is not None:
            namespaceprefix_ = self.Correlations_nsprefix_ + ':' if (UseCapturedNS_ and self.Correlations_nsprefix_) else ''
            self.Correlations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Correlations', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'PredictiveModelQuality':
            obj_ = PredictiveModelQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PredictiveModelQuality.append(obj_)
            obj_.original_tagname_ = 'PredictiveModelQuality'
        elif nodeName_ == 'ClusteringModelQuality':
            obj_ = ClusteringModelQuality.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClusteringModelQuality.append(obj_)
            obj_.original_tagname_ = 'ClusteringModelQuality'
        elif nodeName_ == 'Correlations':
            obj_ = Correlations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Correlations = obj_
            obj_.original_tagname_ = 'Correlations'
# end class ModelExplanation


class PredictiveModelQuality(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, targetField=None, dataName=None, dataUsage='training', meanError=None, meanAbsoluteError=None, meanSquaredError=None, r_squared=None, Extension=None, ConfusionMatrix=None, LiftData=None, ROC=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.targetField = _cast(None, targetField)
        self.targetField_nsprefix_ = None
        self.dataName = _cast(None, dataName)
        self.dataName_nsprefix_ = None
        self.dataUsage = _cast(None, dataUsage)
        self.dataUsage_nsprefix_ = None
        self.meanError = _cast(float, meanError)
        self.meanError_nsprefix_ = None
        self.meanAbsoluteError = _cast(float, meanAbsoluteError)
        self.meanAbsoluteError_nsprefix_ = None
        self.meanSquaredError = _cast(float, meanSquaredError)
        self.meanSquaredError_nsprefix_ = None
        self.r_squared = _cast(float, r_squared)
        self.r_squared_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.ConfusionMatrix = ConfusionMatrix
        self.ConfusionMatrix_nsprefix_ = None
        self.LiftData = LiftData
        self.LiftData_nsprefix_ = None
        self.ROC = ROC
        self.ROC_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PredictiveModelQuality)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PredictiveModelQuality.subclass:
            return PredictiveModelQuality.subclass(*args_, **kwargs_)
        else:
            return PredictiveModelQuality(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_ConfusionMatrix(self):
        return self.ConfusionMatrix
    def set_ConfusionMatrix(self, ConfusionMatrix):
        self.ConfusionMatrix = ConfusionMatrix
    def get_LiftData(self):
        return self.LiftData
    def set_LiftData(self, LiftData):
        self.LiftData = LiftData
    def get_ROC(self):
        return self.ROC
    def set_ROC(self, ROC):
        self.ROC = ROC
    def get_targetField(self):
        return self.targetField
    def set_targetField(self, targetField):
        self.targetField = targetField
    def get_dataName(self):
        return self.dataName
    def set_dataName(self, dataName):
        self.dataName = dataName
    def get_dataUsage(self):
        return self.dataUsage
    def set_dataUsage(self, dataUsage):
        self.dataUsage = dataUsage
    def get_meanError(self):
        return self.meanError
    def set_meanError(self, meanError):
        self.meanError = meanError
    def get_meanAbsoluteError(self):
        return self.meanAbsoluteError
    def set_meanAbsoluteError(self, meanAbsoluteError):
        self.meanAbsoluteError = meanAbsoluteError
    def get_meanSquaredError(self):
        return self.meanSquaredError
    def set_meanSquaredError(self, meanSquaredError):
        self.meanSquaredError = meanSquaredError
    def get_r_squared(self):
        return self.r_squared
    def set_r_squared(self, r_squared):
        self.r_squared = r_squared
    def validate_dataUsageType(self, value):
        # Validate type dataUsageType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['training', 'test', 'validation']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on dataUsageType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.ConfusionMatrix is not None or
            self.LiftData is not None or
            self.ROC is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PredictiveModelQuality', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PredictiveModelQuality')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PredictiveModelQuality':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PredictiveModelQuality')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PredictiveModelQuality', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PredictiveModelQuality'):
        if self.targetField is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            outfile.write(' targetField=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetField), input_name='targetField')), ))
        if self.dataName is not None and 'dataName' not in already_processed:
            already_processed.add('dataName')
            outfile.write(' dataName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataName), input_name='dataName')), ))
        if self.dataUsage != "training" and 'dataUsage' not in already_processed:
            already_processed.add('dataUsage')
            outfile.write(' dataUsage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataUsage), input_name='dataUsage')), ))
        if self.meanError is not None and 'meanError' not in already_processed:
            already_processed.add('meanError')
            outfile.write(' meanError="%s"' % self.gds_format_double(self.meanError, input_name='meanError'))
        if self.meanAbsoluteError is not None and 'meanAbsoluteError' not in already_processed:
            already_processed.add('meanAbsoluteError')
            outfile.write(' meanAbsoluteError="%s"' % self.gds_format_double(self.meanAbsoluteError, input_name='meanAbsoluteError'))
        if self.meanSquaredError is not None and 'meanSquaredError' not in already_processed:
            already_processed.add('meanSquaredError')
            outfile.write(' meanSquaredError="%s"' % self.gds_format_double(self.meanSquaredError, input_name='meanSquaredError'))
        if self.r_squared is not None and 'r_squared' not in already_processed:
            already_processed.add('r_squared')
            outfile.write(' r-squared="%s"' % self.gds_format_double(self.r_squared, input_name='r-squared'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='PredictiveModelQuality', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.ConfusionMatrix is not None:
            namespaceprefix_ = self.ConfusionMatrix_nsprefix_ + ':' if (UseCapturedNS_ and self.ConfusionMatrix_nsprefix_) else ''
            self.ConfusionMatrix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ConfusionMatrix', pretty_print=pretty_print)
        if self.LiftData is not None:
            namespaceprefix_ = self.LiftData_nsprefix_ + ':' if (UseCapturedNS_ and self.LiftData_nsprefix_) else ''
            self.LiftData.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LiftData', pretty_print=pretty_print)
        if self.ROC is not None:
            namespaceprefix_ = self.ROC_nsprefix_ + ':' if (UseCapturedNS_ and self.ROC_nsprefix_) else ''
            self.ROC.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ROC', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetField', node)
        if value is not None and 'targetField' not in already_processed:
            already_processed.add('targetField')
            self.targetField = value
        value = find_attr_value_('dataName', node)
        if value is not None and 'dataName' not in already_processed:
            already_processed.add('dataName')
            self.dataName = value
        value = find_attr_value_('dataUsage', node)
        if value is not None and 'dataUsage' not in already_processed:
            already_processed.add('dataUsage')
            self.dataUsage = value
            self.validate_dataUsageType(self.dataUsage)    # validate type dataUsageType
        value = find_attr_value_('meanError', node)
        if value is not None and 'meanError' not in already_processed:
            already_processed.add('meanError')
            value = self.gds_parse_double(value, node, 'meanError')
            self.meanError = value
            self.validate_NUMBER(self.meanError)    # validate type NUMBER
        value = find_attr_value_('meanAbsoluteError', node)
        if value is not None and 'meanAbsoluteError' not in already_processed:
            already_processed.add('meanAbsoluteError')
            value = self.gds_parse_double(value, node, 'meanAbsoluteError')
            self.meanAbsoluteError = value
            self.validate_NUMBER(self.meanAbsoluteError)    # validate type NUMBER
        value = find_attr_value_('meanSquaredError', node)
        if value is not None and 'meanSquaredError' not in already_processed:
            already_processed.add('meanSquaredError')
            value = self.gds_parse_double(value, node, 'meanSquaredError')
            self.meanSquaredError = value
            self.validate_NUMBER(self.meanSquaredError)    # validate type NUMBER
        value = find_attr_value_('r-squared', node)
        if value is not None and 'r-squared' not in already_processed:
            already_processed.add('r-squared')
            value = self.gds_parse_double(value, node, 'r-squared')
            self.r_squared = value
            self.validate_NUMBER(self.r_squared)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ConfusionMatrix':
            obj_ = ConfusionMatrix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConfusionMatrix = obj_
            obj_.original_tagname_ = 'ConfusionMatrix'
        elif nodeName_ == 'LiftData':
            obj_ = LiftData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LiftData = obj_
            obj_.original_tagname_ = 'LiftData'
        elif nodeName_ == 'ROC':
            obj_ = ROC.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ROC = obj_
            obj_.original_tagname_ = 'ROC'
# end class PredictiveModelQuality


class ClusteringModelQuality(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dataName=None, SSE=None, SSB=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dataName = _cast(None, dataName)
        self.dataName_nsprefix_ = None
        self.SSE = _cast(float, SSE)
        self.SSE_nsprefix_ = None
        self.SSB = _cast(float, SSB)
        self.SSB_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClusteringModelQuality)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClusteringModelQuality.subclass:
            return ClusteringModelQuality.subclass(*args_, **kwargs_)
        else:
            return ClusteringModelQuality(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dataName(self):
        return self.dataName
    def set_dataName(self, dataName):
        self.dataName = dataName
    def get_SSE(self):
        return self.SSE
    def set_SSE(self, SSE):
        self.SSE = SSE
    def get_SSB(self):
        return self.SSB
    def set_SSB(self, SSB):
        self.SSB = SSB
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ClusteringModelQuality', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClusteringModelQuality')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ClusteringModelQuality':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClusteringModelQuality')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClusteringModelQuality', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClusteringModelQuality'):
        if self.dataName is not None and 'dataName' not in already_processed:
            already_processed.add('dataName')
            outfile.write(' dataName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataName), input_name='dataName')), ))
        if self.SSE is not None and 'SSE' not in already_processed:
            already_processed.add('SSE')
            outfile.write(' SSE="%s"' % self.gds_format_double(self.SSE, input_name='SSE'))
        if self.SSB is not None and 'SSB' not in already_processed:
            already_processed.add('SSB')
            outfile.write(' SSB="%s"' % self.gds_format_double(self.SSB, input_name='SSB'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ClusteringModelQuality', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataName', node)
        if value is not None and 'dataName' not in already_processed:
            already_processed.add('dataName')
            self.dataName = value
        value = find_attr_value_('SSE', node)
        if value is not None and 'SSE' not in already_processed:
            already_processed.add('SSE')
            value = self.gds_parse_double(value, node, 'SSE')
            self.SSE = value
            self.validate_NUMBER(self.SSE)    # validate type NUMBER
        value = find_attr_value_('SSB', node)
        if value is not None and 'SSB' not in already_processed:
            already_processed.add('SSB')
            value = self.gds_parse_double(value, node, 'SSB')
            self.SSB = value
            self.validate_NUMBER(self.SSB)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ClusteringModelQuality


class LiftData(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, targetFieldValue=None, targetFieldDisplayValue=None, rankingQuality=None, Extension=None, ModelLiftGraph=None, OptimumLiftGraph=None, RandomLiftGraph=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.targetFieldValue = _cast(None, targetFieldValue)
        self.targetFieldValue_nsprefix_ = None
        self.targetFieldDisplayValue = _cast(None, targetFieldDisplayValue)
        self.targetFieldDisplayValue_nsprefix_ = None
        self.rankingQuality = _cast(float, rankingQuality)
        self.rankingQuality_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.ModelLiftGraph = ModelLiftGraph
        self.ModelLiftGraph_nsprefix_ = None
        self.OptimumLiftGraph = OptimumLiftGraph
        self.OptimumLiftGraph_nsprefix_ = None
        self.RandomLiftGraph = RandomLiftGraph
        self.RandomLiftGraph_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LiftData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LiftData.subclass:
            return LiftData.subclass(*args_, **kwargs_)
        else:
            return LiftData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_ModelLiftGraph(self):
        return self.ModelLiftGraph
    def set_ModelLiftGraph(self, ModelLiftGraph):
        self.ModelLiftGraph = ModelLiftGraph
    def get_OptimumLiftGraph(self):
        return self.OptimumLiftGraph
    def set_OptimumLiftGraph(self, OptimumLiftGraph):
        self.OptimumLiftGraph = OptimumLiftGraph
    def get_RandomLiftGraph(self):
        return self.RandomLiftGraph
    def set_RandomLiftGraph(self, RandomLiftGraph):
        self.RandomLiftGraph = RandomLiftGraph
    def get_targetFieldValue(self):
        return self.targetFieldValue
    def set_targetFieldValue(self, targetFieldValue):
        self.targetFieldValue = targetFieldValue
    def get_targetFieldDisplayValue(self):
        return self.targetFieldDisplayValue
    def set_targetFieldDisplayValue(self, targetFieldDisplayValue):
        self.targetFieldDisplayValue = targetFieldDisplayValue
    def get_rankingQuality(self):
        return self.rankingQuality
    def set_rankingQuality(self, rankingQuality):
        self.rankingQuality = rankingQuality
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Extension or
            self.ModelLiftGraph is not None or
            self.OptimumLiftGraph is not None or
            self.RandomLiftGraph is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='LiftData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LiftData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LiftData':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LiftData')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LiftData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LiftData'):
        if self.targetFieldValue is not None and 'targetFieldValue' not in already_processed:
            already_processed.add('targetFieldValue')
            outfile.write(' targetFieldValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetFieldValue), input_name='targetFieldValue')), ))
        if self.targetFieldDisplayValue is not None and 'targetFieldDisplayValue' not in already_processed:
            already_processed.add('targetFieldDisplayValue')
            outfile.write(' targetFieldDisplayValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.targetFieldDisplayValue), input_name='targetFieldDisplayValue')), ))
        if self.rankingQuality is not None and 'rankingQuality' not in already_processed:
            already_processed.add('rankingQuality')
            outfile.write(' rankingQuality="%s"' % self.gds_format_double(self.rankingQuality, input_name='rankingQuality'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='LiftData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.ModelLiftGraph is not None:
            namespaceprefix_ = self.ModelLiftGraph_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelLiftGraph_nsprefix_) else ''
            self.ModelLiftGraph.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelLiftGraph', pretty_print=pretty_print)
        if self.OptimumLiftGraph is not None:
            namespaceprefix_ = self.OptimumLiftGraph_nsprefix_ + ':' if (UseCapturedNS_ and self.OptimumLiftGraph_nsprefix_) else ''
            self.OptimumLiftGraph.export(outfile, level, namespaceprefix_, namespacedef_='', name_='OptimumLiftGraph', pretty_print=pretty_print)
        if self.RandomLiftGraph is not None:
            namespaceprefix_ = self.RandomLiftGraph_nsprefix_ + ':' if (UseCapturedNS_ and self.RandomLiftGraph_nsprefix_) else ''
            self.RandomLiftGraph.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RandomLiftGraph', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('targetFieldValue', node)
        if value is not None and 'targetFieldValue' not in already_processed:
            already_processed.add('targetFieldValue')
            self.targetFieldValue = value
        value = find_attr_value_('targetFieldDisplayValue', node)
        if value is not None and 'targetFieldDisplayValue' not in already_processed:
            already_processed.add('targetFieldDisplayValue')
            self.targetFieldDisplayValue = value
        value = find_attr_value_('rankingQuality', node)
        if value is not None and 'rankingQuality' not in already_processed:
            already_processed.add('rankingQuality')
            value = self.gds_parse_double(value, node, 'rankingQuality')
            self.rankingQuality = value
            self.validate_NUMBER(self.rankingQuality)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ModelLiftGraph':
            obj_ = ModelLiftGraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelLiftGraph = obj_
            obj_.original_tagname_ = 'ModelLiftGraph'
        elif nodeName_ == 'OptimumLiftGraph':
            obj_ = OptimumLiftGraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.OptimumLiftGraph = obj_
            obj_.original_tagname_ = 'OptimumLiftGraph'
        elif nodeName_ == 'RandomLiftGraph':
            obj_ = RandomLiftGraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RandomLiftGraph = obj_
            obj_.original_tagname_ = 'RandomLiftGraph'
# end class LiftData


class ModelLiftGraph(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, LiftGraph=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.LiftGraph = LiftGraph
        self.LiftGraph_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ModelLiftGraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ModelLiftGraph.subclass:
            return ModelLiftGraph.subclass(*args_, **kwargs_)
        else:
            return ModelLiftGraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_LiftGraph(self):
        return self.LiftGraph
    def set_LiftGraph(self, LiftGraph):
        self.LiftGraph = LiftGraph
    def _hasContent(self):
        if (
            self.Extension or
            self.LiftGraph is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ModelLiftGraph', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ModelLiftGraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ModelLiftGraph':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ModelLiftGraph')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ModelLiftGraph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ModelLiftGraph'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ModelLiftGraph', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.LiftGraph is not None:
            namespaceprefix_ = self.LiftGraph_nsprefix_ + ':' if (UseCapturedNS_ and self.LiftGraph_nsprefix_) else ''
            self.LiftGraph.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LiftGraph', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'LiftGraph':
            obj_ = LiftGraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LiftGraph = obj_
            obj_.original_tagname_ = 'LiftGraph'
# end class ModelLiftGraph


class OptimumLiftGraph(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, LiftGraph=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.LiftGraph = LiftGraph
        self.LiftGraph_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptimumLiftGraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptimumLiftGraph.subclass:
            return OptimumLiftGraph.subclass(*args_, **kwargs_)
        else:
            return OptimumLiftGraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_LiftGraph(self):
        return self.LiftGraph
    def set_LiftGraph(self, LiftGraph):
        self.LiftGraph = LiftGraph
    def _hasContent(self):
        if (
            self.Extension or
            self.LiftGraph is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='OptimumLiftGraph', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OptimumLiftGraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OptimumLiftGraph':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OptimumLiftGraph')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OptimumLiftGraph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OptimumLiftGraph'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='OptimumLiftGraph', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.LiftGraph is not None:
            namespaceprefix_ = self.LiftGraph_nsprefix_ + ':' if (UseCapturedNS_ and self.LiftGraph_nsprefix_) else ''
            self.LiftGraph.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LiftGraph', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'LiftGraph':
            obj_ = LiftGraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LiftGraph = obj_
            obj_.original_tagname_ = 'LiftGraph'
# end class OptimumLiftGraph


class RandomLiftGraph(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, LiftGraph=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.LiftGraph = LiftGraph
        self.LiftGraph_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RandomLiftGraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RandomLiftGraph.subclass:
            return RandomLiftGraph.subclass(*args_, **kwargs_)
        else:
            return RandomLiftGraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_LiftGraph(self):
        return self.LiftGraph
    def set_LiftGraph(self, LiftGraph):
        self.LiftGraph = LiftGraph
    def _hasContent(self):
        if (
            self.Extension or
            self.LiftGraph is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RandomLiftGraph', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RandomLiftGraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RandomLiftGraph':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RandomLiftGraph')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RandomLiftGraph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RandomLiftGraph'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='RandomLiftGraph', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.LiftGraph is not None:
            namespaceprefix_ = self.LiftGraph_nsprefix_ + ':' if (UseCapturedNS_ and self.LiftGraph_nsprefix_) else ''
            self.LiftGraph.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LiftGraph', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'LiftGraph':
            obj_ = LiftGraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LiftGraph = obj_
            obj_.original_tagname_ = 'LiftGraph'
# end class RandomLiftGraph


class LiftGraph(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, XCoordinates=None, YCoordinates=None, BoundaryValues=None, BoundaryValueMeans=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.XCoordinates = XCoordinates
        self.XCoordinates_nsprefix_ = None
        self.YCoordinates = YCoordinates
        self.YCoordinates_nsprefix_ = None
        self.BoundaryValues = BoundaryValues
        self.BoundaryValues_nsprefix_ = None
        self.BoundaryValueMeans = BoundaryValueMeans
        self.BoundaryValueMeans_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LiftGraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LiftGraph.subclass:
            return LiftGraph.subclass(*args_, **kwargs_)
        else:
            return LiftGraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_XCoordinates(self):
        return self.XCoordinates
    def set_XCoordinates(self, XCoordinates):
        self.XCoordinates = XCoordinates
    def get_YCoordinates(self):
        return self.YCoordinates
    def set_YCoordinates(self, YCoordinates):
        self.YCoordinates = YCoordinates
    def get_BoundaryValues(self):
        return self.BoundaryValues
    def set_BoundaryValues(self, BoundaryValues):
        self.BoundaryValues = BoundaryValues
    def get_BoundaryValueMeans(self):
        return self.BoundaryValueMeans
    def set_BoundaryValueMeans(self, BoundaryValueMeans):
        self.BoundaryValueMeans = BoundaryValueMeans
    def _hasContent(self):
        if (
            self.Extension or
            self.XCoordinates is not None or
            self.YCoordinates is not None or
            self.BoundaryValues is not None or
            self.BoundaryValueMeans is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='LiftGraph', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LiftGraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LiftGraph':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LiftGraph')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LiftGraph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LiftGraph'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='LiftGraph', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.XCoordinates is not None:
            namespaceprefix_ = self.XCoordinates_nsprefix_ + ':' if (UseCapturedNS_ and self.XCoordinates_nsprefix_) else ''
            self.XCoordinates.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XCoordinates', pretty_print=pretty_print)
        if self.YCoordinates is not None:
            namespaceprefix_ = self.YCoordinates_nsprefix_ + ':' if (UseCapturedNS_ and self.YCoordinates_nsprefix_) else ''
            self.YCoordinates.export(outfile, level, namespaceprefix_, namespacedef_='', name_='YCoordinates', pretty_print=pretty_print)
        if self.BoundaryValues is not None:
            namespaceprefix_ = self.BoundaryValues_nsprefix_ + ':' if (UseCapturedNS_ and self.BoundaryValues_nsprefix_) else ''
            self.BoundaryValues.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BoundaryValues', pretty_print=pretty_print)
        if self.BoundaryValueMeans is not None:
            namespaceprefix_ = self.BoundaryValueMeans_nsprefix_ + ':' if (UseCapturedNS_ and self.BoundaryValueMeans_nsprefix_) else ''
            self.BoundaryValueMeans.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BoundaryValueMeans', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'XCoordinates':
            obj_ = XCoordinates.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XCoordinates = obj_
            obj_.original_tagname_ = 'XCoordinates'
        elif nodeName_ == 'YCoordinates':
            obj_ = YCoordinates.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.YCoordinates = obj_
            obj_.original_tagname_ = 'YCoordinates'
        elif nodeName_ == 'BoundaryValues':
            obj_ = BoundaryValues.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BoundaryValues = obj_
            obj_.original_tagname_ = 'BoundaryValues'
        elif nodeName_ == 'BoundaryValueMeans':
            obj_ = BoundaryValueMeans.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BoundaryValueMeans = obj_
            obj_.original_tagname_ = 'BoundaryValueMeans'
# end class LiftGraph


class XCoordinates(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XCoordinates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XCoordinates.subclass:
            return XCoordinates.subclass(*args_, **kwargs_)
        else:
            return XCoordinates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def _hasContent(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='XCoordinates', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XCoordinates')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'XCoordinates':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XCoordinates')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='XCoordinates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='XCoordinates'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='XCoordinates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class XCoordinates


class YCoordinates(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, YCoordinates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if YCoordinates.subclass:
            return YCoordinates.subclass(*args_, **kwargs_)
        else:
            return YCoordinates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def _hasContent(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='YCoordinates', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('YCoordinates')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'YCoordinates':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='YCoordinates')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='YCoordinates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='YCoordinates'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='YCoordinates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class YCoordinates


class BoundaryValues(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoundaryValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoundaryValues.subclass:
            return BoundaryValues.subclass(*args_, **kwargs_)
        else:
            return BoundaryValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def _hasContent(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BoundaryValues', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BoundaryValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BoundaryValues':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BoundaryValues')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BoundaryValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BoundaryValues'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BoundaryValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class BoundaryValues


class BoundaryValueMeans(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BoundaryValueMeans)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BoundaryValueMeans.subclass:
            return BoundaryValueMeans.subclass(*args_, **kwargs_)
        else:
            return BoundaryValueMeans(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def _hasContent(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BoundaryValueMeans', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BoundaryValueMeans')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BoundaryValueMeans':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BoundaryValueMeans')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BoundaryValueMeans', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BoundaryValueMeans'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='BoundaryValueMeans', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class BoundaryValueMeans


class ROC(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, positiveTargetFieldValue=None, positiveTargetFieldDisplayValue=None, negativeTargetFieldValue=None, negativeTargetFieldDisplayValue=None, Extension=None, ROCGraph=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.positiveTargetFieldValue = _cast(None, positiveTargetFieldValue)
        self.positiveTargetFieldValue_nsprefix_ = None
        self.positiveTargetFieldDisplayValue = _cast(None, positiveTargetFieldDisplayValue)
        self.positiveTargetFieldDisplayValue_nsprefix_ = None
        self.negativeTargetFieldValue = _cast(None, negativeTargetFieldValue)
        self.negativeTargetFieldValue_nsprefix_ = None
        self.negativeTargetFieldDisplayValue = _cast(None, negativeTargetFieldDisplayValue)
        self.negativeTargetFieldDisplayValue_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.ROCGraph = ROCGraph
        self.ROCGraph_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ROC)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ROC.subclass:
            return ROC.subclass(*args_, **kwargs_)
        else:
            return ROC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_ROCGraph(self):
        return self.ROCGraph
    def set_ROCGraph(self, ROCGraph):
        self.ROCGraph = ROCGraph
    def get_positiveTargetFieldValue(self):
        return self.positiveTargetFieldValue
    def set_positiveTargetFieldValue(self, positiveTargetFieldValue):
        self.positiveTargetFieldValue = positiveTargetFieldValue
    def get_positiveTargetFieldDisplayValue(self):
        return self.positiveTargetFieldDisplayValue
    def set_positiveTargetFieldDisplayValue(self, positiveTargetFieldDisplayValue):
        self.positiveTargetFieldDisplayValue = positiveTargetFieldDisplayValue
    def get_negativeTargetFieldValue(self):
        return self.negativeTargetFieldValue
    def set_negativeTargetFieldValue(self, negativeTargetFieldValue):
        self.negativeTargetFieldValue = negativeTargetFieldValue
    def get_negativeTargetFieldDisplayValue(self):
        return self.negativeTargetFieldDisplayValue
    def set_negativeTargetFieldDisplayValue(self, negativeTargetFieldDisplayValue):
        self.negativeTargetFieldDisplayValue = negativeTargetFieldDisplayValue
    def _hasContent(self):
        if (
            self.Extension or
            self.ROCGraph is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ROC', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ROC')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ROC':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ROC')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ROC', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ROC'):
        if self.positiveTargetFieldValue is not None and 'positiveTargetFieldValue' not in already_processed:
            already_processed.add('positiveTargetFieldValue')
            outfile.write(' positiveTargetFieldValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.positiveTargetFieldValue), input_name='positiveTargetFieldValue')), ))
        if self.positiveTargetFieldDisplayValue is not None and 'positiveTargetFieldDisplayValue' not in already_processed:
            already_processed.add('positiveTargetFieldDisplayValue')
            outfile.write(' positiveTargetFieldDisplayValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.positiveTargetFieldDisplayValue), input_name='positiveTargetFieldDisplayValue')), ))
        if self.negativeTargetFieldValue is not None and 'negativeTargetFieldValue' not in already_processed:
            already_processed.add('negativeTargetFieldValue')
            outfile.write(' negativeTargetFieldValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.negativeTargetFieldValue), input_name='negativeTargetFieldValue')), ))
        if self.negativeTargetFieldDisplayValue is not None and 'negativeTargetFieldDisplayValue' not in already_processed:
            already_processed.add('negativeTargetFieldDisplayValue')
            outfile.write(' negativeTargetFieldDisplayValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.negativeTargetFieldDisplayValue), input_name='negativeTargetFieldDisplayValue')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ROC', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.ROCGraph is not None:
            namespaceprefix_ = self.ROCGraph_nsprefix_ + ':' if (UseCapturedNS_ and self.ROCGraph_nsprefix_) else ''
            self.ROCGraph.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ROCGraph', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('positiveTargetFieldValue', node)
        if value is not None and 'positiveTargetFieldValue' not in already_processed:
            already_processed.add('positiveTargetFieldValue')
            self.positiveTargetFieldValue = value
        value = find_attr_value_('positiveTargetFieldDisplayValue', node)
        if value is not None and 'positiveTargetFieldDisplayValue' not in already_processed:
            already_processed.add('positiveTargetFieldDisplayValue')
            self.positiveTargetFieldDisplayValue = value
        value = find_attr_value_('negativeTargetFieldValue', node)
        if value is not None and 'negativeTargetFieldValue' not in already_processed:
            already_processed.add('negativeTargetFieldValue')
            self.negativeTargetFieldValue = value
        value = find_attr_value_('negativeTargetFieldDisplayValue', node)
        if value is not None and 'negativeTargetFieldDisplayValue' not in already_processed:
            already_processed.add('negativeTargetFieldDisplayValue')
            self.negativeTargetFieldDisplayValue = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ROCGraph':
            obj_ = ROCGraph.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ROCGraph = obj_
            obj_.original_tagname_ = 'ROCGraph'
# end class ROC


class ROCGraph(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, XCoordinates=None, YCoordinates=None, BoundaryValues=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.XCoordinates = XCoordinates
        self.XCoordinates_nsprefix_ = None
        self.YCoordinates = YCoordinates
        self.YCoordinates_nsprefix_ = None
        self.BoundaryValues = BoundaryValues
        self.BoundaryValues_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ROCGraph)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ROCGraph.subclass:
            return ROCGraph.subclass(*args_, **kwargs_)
        else:
            return ROCGraph(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_XCoordinates(self):
        return self.XCoordinates
    def set_XCoordinates(self, XCoordinates):
        self.XCoordinates = XCoordinates
    def get_YCoordinates(self):
        return self.YCoordinates
    def set_YCoordinates(self, YCoordinates):
        self.YCoordinates = YCoordinates
    def get_BoundaryValues(self):
        return self.BoundaryValues
    def set_BoundaryValues(self, BoundaryValues):
        self.BoundaryValues = BoundaryValues
    def _hasContent(self):
        if (
            self.Extension or
            self.XCoordinates is not None or
            self.YCoordinates is not None or
            self.BoundaryValues is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ROCGraph', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ROCGraph')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ROCGraph':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ROCGraph')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ROCGraph', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ROCGraph'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ROCGraph', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.XCoordinates is not None:
            namespaceprefix_ = self.XCoordinates_nsprefix_ + ':' if (UseCapturedNS_ and self.XCoordinates_nsprefix_) else ''
            self.XCoordinates.export(outfile, level, namespaceprefix_, namespacedef_='', name_='XCoordinates', pretty_print=pretty_print)
        if self.YCoordinates is not None:
            namespaceprefix_ = self.YCoordinates_nsprefix_ + ':' if (UseCapturedNS_ and self.YCoordinates_nsprefix_) else ''
            self.YCoordinates.export(outfile, level, namespaceprefix_, namespacedef_='', name_='YCoordinates', pretty_print=pretty_print)
        if self.BoundaryValues is not None:
            namespaceprefix_ = self.BoundaryValues_nsprefix_ + ':' if (UseCapturedNS_ and self.BoundaryValues_nsprefix_) else ''
            self.BoundaryValues.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BoundaryValues', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'XCoordinates':
            obj_ = XCoordinates.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.XCoordinates = obj_
            obj_.original_tagname_ = 'XCoordinates'
        elif nodeName_ == 'YCoordinates':
            obj_ = YCoordinates.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.YCoordinates = obj_
            obj_.original_tagname_ = 'YCoordinates'
        elif nodeName_ == 'BoundaryValues':
            obj_ = BoundaryValues.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BoundaryValues = obj_
            obj_.original_tagname_ = 'BoundaryValues'
# end class ROCGraph


class ConfusionMatrix(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, ClassLabels=None, Matrix=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.ClassLabels = ClassLabels
        self.ClassLabels_nsprefix_ = None
        self.Matrix = Matrix
        self.Matrix_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConfusionMatrix)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConfusionMatrix.subclass:
            return ConfusionMatrix.subclass(*args_, **kwargs_)
        else:
            return ConfusionMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_ClassLabels(self):
        return self.ClassLabels
    def set_ClassLabels(self, ClassLabels):
        self.ClassLabels = ClassLabels
    def get_Matrix(self):
        return self.Matrix
    def set_Matrix(self, Matrix):
        self.Matrix = Matrix
    def _hasContent(self):
        if (
            self.Extension or
            self.ClassLabels is not None or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ConfusionMatrix', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConfusionMatrix')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConfusionMatrix':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConfusionMatrix')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConfusionMatrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConfusionMatrix'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ConfusionMatrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.ClassLabels is not None:
            namespaceprefix_ = self.ClassLabels_nsprefix_ + ':' if (UseCapturedNS_ and self.ClassLabels_nsprefix_) else ''
            self.ClassLabels.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClassLabels', pretty_print=pretty_print)
        if self.Matrix is not None:
            namespaceprefix_ = self.Matrix_nsprefix_ + ':' if (UseCapturedNS_ and self.Matrix_nsprefix_) else ''
            self.Matrix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Matrix', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'ClassLabels':
            obj_ = ClassLabels.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClassLabels = obj_
            obj_.original_tagname_ = 'ClassLabels'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class ConfusionMatrix


class ClassLabels(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ClassLabels)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ClassLabels.subclass:
            return ClassLabels.subclass(*args_, **kwargs_)
        else:
            return ClassLabels(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def _hasContent(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ClassLabels', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ClassLabels')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ClassLabels':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ClassLabels')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ClassLabels', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ClassLabels'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ClassLabels', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class ClassLabels


class Correlations(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, CorrelationFields=None, CorrelationValues=None, CorrelationMethods=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.CorrelationFields = CorrelationFields
        self.CorrelationFields_nsprefix_ = None
        self.CorrelationValues = CorrelationValues
        self.CorrelationValues_nsprefix_ = None
        self.CorrelationMethods = CorrelationMethods
        self.CorrelationMethods_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Correlations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Correlations.subclass:
            return Correlations.subclass(*args_, **kwargs_)
        else:
            return Correlations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_CorrelationFields(self):
        return self.CorrelationFields
    def set_CorrelationFields(self, CorrelationFields):
        self.CorrelationFields = CorrelationFields
    def get_CorrelationValues(self):
        return self.CorrelationValues
    def set_CorrelationValues(self, CorrelationValues):
        self.CorrelationValues = CorrelationValues
    def get_CorrelationMethods(self):
        return self.CorrelationMethods
    def set_CorrelationMethods(self, CorrelationMethods):
        self.CorrelationMethods = CorrelationMethods
    def _hasContent(self):
        if (
            self.Extension or
            self.CorrelationFields is not None or
            self.CorrelationValues is not None or
            self.CorrelationMethods is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Correlations', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Correlations')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Correlations':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Correlations')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Correlations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Correlations'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Correlations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.CorrelationFields is not None:
            namespaceprefix_ = self.CorrelationFields_nsprefix_ + ':' if (UseCapturedNS_ and self.CorrelationFields_nsprefix_) else ''
            self.CorrelationFields.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CorrelationFields', pretty_print=pretty_print)
        if self.CorrelationValues is not None:
            namespaceprefix_ = self.CorrelationValues_nsprefix_ + ':' if (UseCapturedNS_ and self.CorrelationValues_nsprefix_) else ''
            self.CorrelationValues.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CorrelationValues', pretty_print=pretty_print)
        if self.CorrelationMethods is not None:
            namespaceprefix_ = self.CorrelationMethods_nsprefix_ + ':' if (UseCapturedNS_ and self.CorrelationMethods_nsprefix_) else ''
            self.CorrelationMethods.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CorrelationMethods', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'CorrelationFields':
            obj_ = CorrelationFields.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CorrelationFields = obj_
            obj_.original_tagname_ = 'CorrelationFields'
        elif nodeName_ == 'CorrelationValues':
            obj_ = CorrelationValues.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CorrelationValues = obj_
            obj_.original_tagname_ = 'CorrelationValues'
        elif nodeName_ == 'CorrelationMethods':
            obj_ = CorrelationMethods.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CorrelationMethods = obj_
            obj_.original_tagname_ = 'CorrelationMethods'
# end class Correlations


class CorrelationFields(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrelationFields)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrelationFields.subclass:
            return CorrelationFields.subclass(*args_, **kwargs_)
        else:
            return CorrelationFields(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def _hasContent(self):
        if (
            self.Extension or
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CorrelationFields', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CorrelationFields')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CorrelationFields':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CorrelationFields')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CorrelationFields', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CorrelationFields'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CorrelationFields', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class CorrelationFields


class CorrelationValues(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Matrix = Matrix
        self.Matrix_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrelationValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrelationValues.subclass:
            return CorrelationValues.subclass(*args_, **kwargs_)
        else:
            return CorrelationValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Matrix(self):
        return self.Matrix
    def set_Matrix(self, Matrix):
        self.Matrix = Matrix
    def _hasContent(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CorrelationValues', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CorrelationValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CorrelationValues':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CorrelationValues')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CorrelationValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CorrelationValues'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CorrelationValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            namespaceprefix_ = self.Matrix_nsprefix_ + ':' if (UseCapturedNS_ and self.Matrix_nsprefix_) else ''
            self.Matrix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Matrix', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class CorrelationValues


class CorrelationMethods(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, Extension=None, Matrix=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Matrix = Matrix
        self.Matrix_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CorrelationMethods)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CorrelationMethods.subclass:
            return CorrelationMethods.subclass(*args_, **kwargs_)
        else:
            return CorrelationMethods(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Matrix(self):
        return self.Matrix
    def set_Matrix(self, Matrix):
        self.Matrix = Matrix
    def _hasContent(self):
        if (
            self.Extension or
            self.Matrix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CorrelationMethods', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CorrelationMethods')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CorrelationMethods':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CorrelationMethods')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CorrelationMethods', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CorrelationMethods'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='CorrelationMethods', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Matrix is not None:
            namespaceprefix_ = self.Matrix_nsprefix_ + ':' if (UseCapturedNS_ and self.Matrix_nsprefix_) else ''
            self.Matrix.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Matrix', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Matrix':
            obj_ = Matrix.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Matrix = obj_
            obj_.original_tagname_ = 'Matrix'
# end class CorrelationMethods


class MiningModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, MiningSchema=None, Output=None, ModelStats=None, ModelExplanation=None, Targets=None, LocalTransformations=None, Regression=None, DecisionTree=None, Segmentation=None, ModelVerification=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.MiningSchema = MiningSchema
        self.MiningSchema_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.ModelExplanation = ModelExplanation
        self.ModelExplanation_nsprefix_ = None
        self.Targets = Targets
        self.Targets_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        if Regression is None:
            self.Regression = []
        else:
            self.Regression = Regression
        self.Regression_nsprefix_ = None
        if DecisionTree is None:
            self.DecisionTree = []
        else:
            self.DecisionTree = DecisionTree
        self.DecisionTree_nsprefix_ = None
        self.Segmentation = Segmentation
        self.Segmentation_nsprefix_ = None
        self.ModelVerification = ModelVerification
        self.ModelVerification_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MiningModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MiningModel.subclass:
            return MiningModel.subclass(*args_, **kwargs_)
        else:
            return MiningModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MiningSchema(self):
        return self.MiningSchema
    def set_MiningSchema(self, MiningSchema):
        self.MiningSchema = MiningSchema
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_ModelExplanation(self):
        return self.ModelExplanation
    def set_ModelExplanation(self, ModelExplanation):
        self.ModelExplanation = ModelExplanation
    def get_Targets(self):
        return self.Targets
    def set_Targets(self, Targets):
        self.Targets = Targets
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_Regression(self):
        return self.Regression
    def set_Regression(self, Regression):
        self.Regression = Regression
    def add_Regression(self, value):
        self.Regression.append(value)
    def insert_Regression_at(self, index, value):
        self.Regression.insert(index, value)
    def replace_Regression_at(self, index, value):
        self.Regression[index] = value
    def get_DecisionTree(self):
        return self.DecisionTree
    def set_DecisionTree(self, DecisionTree):
        self.DecisionTree = DecisionTree
    def add_DecisionTree(self, value):
        self.DecisionTree.append(value)
    def insert_DecisionTree_at(self, index, value):
        self.DecisionTree.insert(index, value)
    def replace_DecisionTree_at(self, index, value):
        self.DecisionTree[index] = value
    def get_Segmentation(self):
        return self.Segmentation
    def set_Segmentation(self, Segmentation):
        self.Segmentation = Segmentation
    def get_ModelVerification(self):
        return self.ModelVerification
    def set_ModelVerification(self, ModelVerification):
        self.ModelVerification = ModelVerification
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.ModelExplanation is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.Regression or
            self.DecisionTree or
            self.Segmentation is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='MiningModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MiningModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MiningModel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MiningModel')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MiningModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MiningModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='MiningModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            namespaceprefix_ = self.MiningSchema_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningSchema_nsprefix_) else ''
            self.MiningSchema.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.ModelExplanation is not None:
            namespaceprefix_ = self.ModelExplanation_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelExplanation_nsprefix_) else ''
            self.ModelExplanation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelExplanation', pretty_print=pretty_print)
        if self.Targets is not None:
            namespaceprefix_ = self.Targets_nsprefix_ + ':' if (UseCapturedNS_ and self.Targets_nsprefix_) else ''
            self.Targets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        for Regression_ in self.Regression:
            namespaceprefix_ = self.Regression_nsprefix_ + ':' if (UseCapturedNS_ and self.Regression_nsprefix_) else ''
            Regression_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Regression', pretty_print=pretty_print)
        for DecisionTree_ in self.DecisionTree:
            namespaceprefix_ = self.DecisionTree_nsprefix_ + ':' if (UseCapturedNS_ and self.DecisionTree_nsprefix_) else ''
            DecisionTree_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DecisionTree', pretty_print=pretty_print)
        if self.Segmentation is not None:
            namespaceprefix_ = self.Segmentation_nsprefix_ + ':' if (UseCapturedNS_ and self.Segmentation_nsprefix_) else ''
            self.Segmentation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Segmentation', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            namespaceprefix_ = self.ModelVerification_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelVerification_nsprefix_) else ''
            self.ModelVerification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'ModelExplanation':
            obj_ = ModelExplanation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelExplanation = obj_
            obj_.original_tagname_ = 'ModelExplanation'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'Regression':
            obj_ = Regression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Regression.append(obj_)
            obj_.original_tagname_ = 'Regression'
        elif nodeName_ == 'DecisionTree':
            obj_ = DecisionTree.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DecisionTree.append(obj_)
            obj_.original_tagname_ = 'DecisionTree'
        elif nodeName_ == 'Segmentation':
            obj_ = Segmentation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Segmentation = obj_
            obj_.original_tagname_ = 'Segmentation'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class MiningModel


class Segmentation(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multipleModelMethod=None, Extension=None, LocalTransformations=None, Segment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multipleModelMethod = _cast(None, multipleModelMethod)
        self.multipleModelMethod_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        if Segment is None:
            self.Segment = []
        else:
            self.Segment = Segment
        self.Segment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Segmentation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Segmentation.subclass:
            return Segmentation.subclass(*args_, **kwargs_)
        else:
            return Segmentation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_Segment(self):
        return self.Segment
    def set_Segment(self, Segment):
        self.Segment = Segment
    def add_Segment(self, value):
        self.Segment.append(value)
    def insert_Segment_at(self, index, value):
        self.Segment.insert(index, value)
    def replace_Segment_at(self, index, value):
        self.Segment[index] = value
    def get_multipleModelMethod(self):
        return self.multipleModelMethod
    def set_multipleModelMethod(self, multipleModelMethod):
        self.multipleModelMethod = multipleModelMethod
    def validate_MULTIPLE_MODEL_METHOD(self, value):
        # Validate type MULTIPLE-MODEL-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['majorityVote', 'weightedMajorityVote', 'average', 'weightedAverage', 'median', 'max', 'sum', 'selectFirst', 'selectAll']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MULTIPLE-MODEL-METHOD' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.LocalTransformations is not None or
            self.Segment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Segmentation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Segmentation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Segmentation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Segmentation')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Segmentation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Segmentation'):
        if self.multipleModelMethod is not None and 'multipleModelMethod' not in already_processed:
            already_processed.add('multipleModelMethod')
            outfile.write(' multipleModelMethod=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.multipleModelMethod), input_name='multipleModelMethod')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Segmentation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        for Segment_ in self.Segment:
            namespaceprefix_ = self.Segment_nsprefix_ + ':' if (UseCapturedNS_ and self.Segment_nsprefix_) else ''
            Segment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Segment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('multipleModelMethod', node)
        if value is not None and 'multipleModelMethod' not in already_processed:
            already_processed.add('multipleModelMethod')
            self.multipleModelMethod = value
            self.validate_MULTIPLE_MODEL_METHOD(self.multipleModelMethod)    # validate type MULTIPLE-MODEL-METHOD
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'Segment':
            obj_ = Segment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Segment.append(obj_)
            obj_.original_tagname_ = 'Segment'
# end class Segmentation


class Segment(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, weight=None, SimplePredicate=None, CompoundPredicate=None, SimpleSetPredicate=None, True_=None, False_=None, ClusteringModel=None, GeneralRegressionModel=None, NaiveBayesModel=None, NeuralNetwork=None, RegressionModel=None, RuleSetModel=None, SupportVectorMachineModel=None, TreeModel=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.weight = _cast(float, weight)
        self.weight_nsprefix_ = None
        self.SimplePredicate = SimplePredicate
        self.SimplePredicate_nsprefix_ = None
        self.CompoundPredicate = CompoundPredicate
        self.CompoundPredicate_nsprefix_ = None
        self.SimpleSetPredicate = SimpleSetPredicate
        self.SimpleSetPredicate_nsprefix_ = None
        self.True_ = True_
        self.True__nsprefix_ = None
        self.False_ = False_
        self.False__nsprefix_ = None
        self.ClusteringModel = ClusteringModel
        self.ClusteringModel_nsprefix_ = None
        self.GeneralRegressionModel = GeneralRegressionModel
        self.GeneralRegressionModel_nsprefix_ = None
        self.NaiveBayesModel = NaiveBayesModel
        self.NaiveBayesModel_nsprefix_ = None
        self.NeuralNetwork = NeuralNetwork
        self.NeuralNetwork_nsprefix_ = None
        self.RegressionModel = RegressionModel
        self.RegressionModel_nsprefix_ = None
        self.RuleSetModel = RuleSetModel
        self.RuleSetModel_nsprefix_ = None
        self.SupportVectorMachineModel = SupportVectorMachineModel
        self.SupportVectorMachineModel_nsprefix_ = None
        self.TreeModel = TreeModel
        self.TreeModel_nsprefix_ = None
        self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Segment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Segment.subclass:
            return Segment.subclass(*args_, **kwargs_)
        else:
            return Segment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SimplePredicate(self):
        return self.SimplePredicate
    def set_SimplePredicate(self, SimplePredicate):
        self.SimplePredicate = SimplePredicate
    def get_CompoundPredicate(self):
        return self.CompoundPredicate
    def set_CompoundPredicate(self, CompoundPredicate):
        self.CompoundPredicate = CompoundPredicate
    def get_SimpleSetPredicate(self):
        return self.SimpleSetPredicate
    def set_SimpleSetPredicate(self, SimpleSetPredicate):
        self.SimpleSetPredicate = SimpleSetPredicate
    def get_True(self):
        return self.True_
    def set_True(self, True_):
        self.True_ = True_
    def get_False(self):
        return self.False_
    def set_False(self, False_):
        self.False_ = False_
    def get_ClusteringModel(self):
        return self.ClusteringModel
    def set_ClusteringModel(self, ClusteringModel):
        self.ClusteringModel = ClusteringModel
    def get_GeneralRegressionModel(self):
        return self.GeneralRegressionModel
    def set_GeneralRegressionModel(self, GeneralRegressionModel):
        self.GeneralRegressionModel = GeneralRegressionModel
    def get_NaiveBayesModel(self):
        return self.NaiveBayesModel
    def set_NaiveBayesModel(self, NaiveBayesModel):
        self.NaiveBayesModel = NaiveBayesModel
    def get_NeuralNetwork(self):
        return self.NeuralNetwork
    def set_NeuralNetwork(self, NeuralNetwork):
        self.NeuralNetwork = NeuralNetwork
    def get_RegressionModel(self):
        return self.RegressionModel
    def set_RegressionModel(self, RegressionModel):
        self.RegressionModel = RegressionModel
    def get_RuleSetModel(self):
        return self.RuleSetModel
    def set_RuleSetModel(self, RuleSetModel):
        self.RuleSetModel = RuleSetModel
    def get_SupportVectorMachineModel(self):
        return self.SupportVectorMachineModel
    def set_SupportVectorMachineModel(self, SupportVectorMachineModel):
        self.SupportVectorMachineModel = SupportVectorMachineModel
    def get_TreeModel(self):
        return self.TreeModel
    def set_TreeModel(self, TreeModel):
        self.TreeModel = TreeModel
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_weight(self):
        return self.weight
    def set_weight(self, weight):
        self.weight = weight
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.SimplePredicate is not None or
            self.CompoundPredicate is not None or
            self.SimpleSetPredicate is not None or
            self.True_ is not None or
            self.False_ is not None or
            self.ClusteringModel is not None or
            self.GeneralRegressionModel is not None or
            self.NaiveBayesModel is not None or
            self.NeuralNetwork is not None or
            self.RegressionModel is not None or
            self.RuleSetModel is not None or
            self.SupportVectorMachineModel is not None or
            self.TreeModel is not None or
            self.Extension is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Segment', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Segment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Segment':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Segment')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Segment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Segment'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            outfile.write(' weight="%s"' % self.gds_format_double(self.weight, input_name='weight'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Segment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SimplePredicate is not None:
            namespaceprefix_ = self.SimplePredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.SimplePredicate_nsprefix_) else ''
            self.SimplePredicate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SimplePredicate', pretty_print=pretty_print)
        if self.CompoundPredicate is not None:
            namespaceprefix_ = self.CompoundPredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.CompoundPredicate_nsprefix_) else ''
            self.CompoundPredicate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CompoundPredicate', pretty_print=pretty_print)
        if self.SimpleSetPredicate is not None:
            namespaceprefix_ = self.SimpleSetPredicate_nsprefix_ + ':' if (UseCapturedNS_ and self.SimpleSetPredicate_nsprefix_) else ''
            self.SimpleSetPredicate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SimpleSetPredicate', pretty_print=pretty_print)
        if self.True_ is not None:
            namespaceprefix_ = self.True__nsprefix_ + ':' if (UseCapturedNS_ and self.True__nsprefix_) else ''
            self.True_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='True', pretty_print=pretty_print)
        if self.False_ is not None:
            namespaceprefix_ = self.False__nsprefix_ + ':' if (UseCapturedNS_ and self.False__nsprefix_) else ''
            self.False_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='False', pretty_print=pretty_print)
        if self.ClusteringModel is not None:
            namespaceprefix_ = self.ClusteringModel_nsprefix_ + ':' if (UseCapturedNS_ and self.ClusteringModel_nsprefix_) else ''
            self.ClusteringModel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ClusteringModel', pretty_print=pretty_print)
        if self.GeneralRegressionModel is not None:
            namespaceprefix_ = self.GeneralRegressionModel_nsprefix_ + ':' if (UseCapturedNS_ and self.GeneralRegressionModel_nsprefix_) else ''
            self.GeneralRegressionModel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='GeneralRegressionModel', pretty_print=pretty_print)
        if self.NaiveBayesModel is not None:
            namespaceprefix_ = self.NaiveBayesModel_nsprefix_ + ':' if (UseCapturedNS_ and self.NaiveBayesModel_nsprefix_) else ''
            self.NaiveBayesModel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NaiveBayesModel', pretty_print=pretty_print)
        if self.NeuralNetwork is not None:
            namespaceprefix_ = self.NeuralNetwork_nsprefix_ + ':' if (UseCapturedNS_ and self.NeuralNetwork_nsprefix_) else ''
            self.NeuralNetwork.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NeuralNetwork', pretty_print=pretty_print)
        if self.RegressionModel is not None:
            namespaceprefix_ = self.RegressionModel_nsprefix_ + ':' if (UseCapturedNS_ and self.RegressionModel_nsprefix_) else ''
            self.RegressionModel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RegressionModel', pretty_print=pretty_print)
        if self.RuleSetModel is not None:
            namespaceprefix_ = self.RuleSetModel_nsprefix_ + ':' if (UseCapturedNS_ and self.RuleSetModel_nsprefix_) else ''
            self.RuleSetModel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RuleSetModel', pretty_print=pretty_print)
        if self.SupportVectorMachineModel is not None:
            namespaceprefix_ = self.SupportVectorMachineModel_nsprefix_ + ':' if (UseCapturedNS_ and self.SupportVectorMachineModel_nsprefix_) else ''
            self.SupportVectorMachineModel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SupportVectorMachineModel', pretty_print=pretty_print)
        if self.TreeModel is not None:
            namespaceprefix_ = self.TreeModel_nsprefix_ + ':' if (UseCapturedNS_ and self.TreeModel_nsprefix_) else ''
            self.TreeModel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TreeModel', pretty_print=pretty_print)
        if self.Extension is not None:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            self.Extension.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.add('weight')
            value = self.gds_parse_double(value, node, 'weight')
            self.weight = value
            self.validate_NUMBER(self.weight)    # validate type NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SimplePredicate':
            obj_ = SimplePredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SimplePredicate = obj_
            obj_.original_tagname_ = 'SimplePredicate'
        elif nodeName_ == 'CompoundPredicate':
            obj_ = CompoundPredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CompoundPredicate = obj_
            obj_.original_tagname_ = 'CompoundPredicate'
        elif nodeName_ == 'SimpleSetPredicate':
            obj_ = SimpleSetPredicate.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SimpleSetPredicate = obj_
            obj_.original_tagname_ = 'SimpleSetPredicate'
        elif nodeName_ == 'True':
            obj_ = True_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.True_ = obj_
            obj_.original_tagname_ = 'True'
        elif nodeName_ == 'False':
            obj_ = False_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.False_ = obj_
            obj_.original_tagname_ = 'False'
        elif nodeName_ == 'ClusteringModel':
            obj_ = ClusteringModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ClusteringModel = obj_
            obj_.original_tagname_ = 'ClusteringModel'
        elif nodeName_ == 'GeneralRegressionModel':
            obj_ = GeneralRegressionModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.GeneralRegressionModel = obj_
            obj_.original_tagname_ = 'GeneralRegressionModel'
        elif nodeName_ == 'NaiveBayesModel':
            obj_ = NaiveBayesModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NaiveBayesModel = obj_
            obj_.original_tagname_ = 'NaiveBayesModel'
        elif nodeName_ == 'NeuralNetwork':
            obj_ = NeuralNetwork.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NeuralNetwork = obj_
            obj_.original_tagname_ = 'NeuralNetwork'
        elif nodeName_ == 'RegressionModel':
            obj_ = RegressionModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RegressionModel = obj_
            obj_.original_tagname_ = 'RegressionModel'
        elif nodeName_ == 'RuleSetModel':
            obj_ = RuleSetModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RuleSetModel = obj_
            obj_.original_tagname_ = 'RuleSetModel'
        elif nodeName_ == 'SupportVectorMachineModel':
            obj_ = SupportVectorMachineModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SupportVectorMachineModel = obj_
            obj_.original_tagname_ = 'SupportVectorMachineModel'
        elif nodeName_ == 'TreeModel':
            obj_ = TreeModel.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TreeModel = obj_
            obj_.original_tagname_ = 'TreeModel'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension = obj_
            obj_.original_tagname_ = 'Extension'
# end class Segment


class ResultField(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, optype=None, dataType=None, feature=None, value=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.optype = _cast(None, optype)
        self.optype_nsprefix_ = None
        self.dataType = _cast(None, dataType)
        self.dataType_nsprefix_ = None
        self.feature = _cast(None, feature)
        self.feature_nsprefix_ = None
        self.value = _cast(None, value)
        self.value_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResultField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResultField.subclass:
            return ResultField.subclass(*args_, **kwargs_)
        else:
            return ResultField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_optype(self):
        return self.optype
    def set_optype(self, optype):
        self.optype = optype
    def get_dataType(self):
        return self.dataType
    def set_dataType(self, dataType):
        self.dataType = dataType
    def get_feature(self):
        return self.feature
    def set_feature(self, feature):
        self.feature = feature
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_FIELD_NAME(self, value):
        # Validate type FIELD-NAME, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_OPTYPE(self, value):
        # Validate type OPTYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['categorical', 'ordinal', 'continuous']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on OPTYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DATATYPE(self, value):
        # Validate type DATATYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['string', 'integer', 'float', 'double', 'boolean', 'date', 'time', 'dateTime', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'timeSeconds', 'dateTimeSecondsSince[0]', 'dateTimeSecondsSince[1960]', 'dateTimeSecondsSince[1970]', 'dateTimeSecondsSince[1980]']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DATATYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_RESULT_FEATURE(self, value):
        # Validate type RESULT-FEATURE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['predictedValue', 'predictedDisplayValue', 'probability', 'residual', 'standardError', 'clusterId', 'clusterAffinity', 'entityId', 'entityAffinity', 'warning', 'ruleValue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on RESULT-FEATURE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ResultField', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResultField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ResultField':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResultField')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResultField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResultField'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
        if self.optype is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            outfile.write(' optype=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.optype), input_name='optype')), ))
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataType), input_name='dataType')), ))
        if self.feature is not None and 'feature' not in already_processed:
            already_processed.add('feature')
            outfile.write(' feature=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.feature), input_name='feature')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ResultField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_FIELD_NAME(self.name)    # validate type FIELD-NAME
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
        value = find_attr_value_('optype', node)
        if value is not None and 'optype' not in already_processed:
            already_processed.add('optype')
            self.optype = value
            self.validate_OPTYPE(self.optype)    # validate type OPTYPE
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_DATATYPE(self.dataType)    # validate type DATATYPE
        value = find_attr_value_('feature', node)
        if value is not None and 'feature' not in already_processed:
            already_processed.add('feature')
            self.feature = value
            self.validate_RESULT_FEATURE(self.feature)    # validate type RESULT-FEATURE
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class ResultField


class Regression(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, normalizationMethod='none', Extension=None, Output=None, ModelStats=None, Targets=None, LocalTransformations=None, ResultField=None, RegressionTable=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.normalizationMethod = _cast(None, normalizationMethod)
        self.normalizationMethod_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.Targets = Targets
        self.Targets_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        if ResultField is None:
            self.ResultField = []
        else:
            self.ResultField = ResultField
        self.ResultField_nsprefix_ = None
        if RegressionTable is None:
            self.RegressionTable = []
        else:
            self.RegressionTable = RegressionTable
        self.RegressionTable_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Regression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Regression.subclass:
            return Regression.subclass(*args_, **kwargs_)
        else:
            return Regression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_Targets(self):
        return self.Targets
    def set_Targets(self, Targets):
        self.Targets = Targets
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_ResultField(self):
        return self.ResultField
    def set_ResultField(self, ResultField):
        self.ResultField = ResultField
    def add_ResultField(self, value):
        self.ResultField.append(value)
    def insert_ResultField_at(self, index, value):
        self.ResultField.insert(index, value)
    def replace_ResultField_at(self, index, value):
        self.ResultField[index] = value
    def get_RegressionTable(self):
        return self.RegressionTable
    def set_RegressionTable(self, RegressionTable):
        self.RegressionTable = RegressionTable
    def add_RegressionTable(self, value):
        self.RegressionTable.append(value)
    def insert_RegressionTable_at(self, index, value):
        self.RegressionTable.insert(index, value)
    def replace_RegressionTable_at(self, index, value):
        self.RegressionTable[index] = value
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def get_normalizationMethod(self):
        return self.normalizationMethod
    def set_normalizationMethod(self, normalizationMethod):
        self.normalizationMethod = normalizationMethod
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_REGRESSIONNORMALIZATIONMETHOD(self, value):
        # Validate type REGRESSIONNORMALIZATIONMETHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'simplemax', 'softmax', 'logit', 'probit', 'cloglog', 'exp', 'loglog', 'cauchit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on REGRESSIONNORMALIZATIONMETHOD' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.Output is not None or
            self.ModelStats is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.ResultField or
            self.RegressionTable
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Regression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Regression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Regression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Regression')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Regression', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Regression'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.normalizationMethod != "none" and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            outfile.write(' normalizationMethod=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.normalizationMethod), input_name='normalizationMethod')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Regression', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.Targets is not None:
            namespaceprefix_ = self.Targets_nsprefix_ + ':' if (UseCapturedNS_ and self.Targets_nsprefix_) else ''
            self.Targets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        for ResultField_ in self.ResultField:
            namespaceprefix_ = self.ResultField_nsprefix_ + ':' if (UseCapturedNS_ and self.ResultField_nsprefix_) else ''
            ResultField_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResultField', pretty_print=pretty_print)
        for RegressionTable_ in self.RegressionTable:
            namespaceprefix_ = self.RegressionTable_nsprefix_ + ':' if (UseCapturedNS_ and self.RegressionTable_nsprefix_) else ''
            RegressionTable_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RegressionTable', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('normalizationMethod', node)
        if value is not None and 'normalizationMethod' not in already_processed:
            already_processed.add('normalizationMethod')
            self.normalizationMethod = value
            self.validate_REGRESSIONNORMALIZATIONMETHOD(self.normalizationMethod)    # validate type REGRESSIONNORMALIZATIONMETHOD
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'ResultField':
            obj_ = ResultField.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResultField.append(obj_)
            obj_.original_tagname_ = 'ResultField'
        elif nodeName_ == 'RegressionTable':
            obj_ = RegressionTable.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RegressionTable.append(obj_)
            obj_.original_tagname_ = 'RegressionTable'
# end class Regression


class DecisionTree(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, missingValueStrategy='none', missingValuePenalty='1.0', noTrueChildStrategy='returnNullPrediction', splitCharacteristic='multiSplit', Extension=None, Output=None, ModelStats=None, Targets=None, LocalTransformations=None, ResultField=None, Node=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.missingValueStrategy = _cast(None, missingValueStrategy)
        self.missingValueStrategy_nsprefix_ = None
        self.missingValuePenalty = _cast(float, missingValuePenalty)
        self.missingValuePenalty_nsprefix_ = None
        self.noTrueChildStrategy = _cast(None, noTrueChildStrategy)
        self.noTrueChildStrategy_nsprefix_ = None
        self.splitCharacteristic = _cast(None, splitCharacteristic)
        self.splitCharacteristic_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.Targets = Targets
        self.Targets_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        if ResultField is None:
            self.ResultField = []
        else:
            self.ResultField = ResultField
        self.ResultField_nsprefix_ = None
        self.Node = Node
        self.Node_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DecisionTree)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DecisionTree.subclass:
            return DecisionTree.subclass(*args_, **kwargs_)
        else:
            return DecisionTree(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_Targets(self):
        return self.Targets
    def set_Targets(self, Targets):
        self.Targets = Targets
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_ResultField(self):
        return self.ResultField
    def set_ResultField(self, ResultField):
        self.ResultField = ResultField
    def add_ResultField(self, value):
        self.ResultField.append(value)
    def insert_ResultField_at(self, index, value):
        self.ResultField.insert(index, value)
    def replace_ResultField_at(self, index, value):
        self.ResultField[index] = value
    def get_Node(self):
        return self.Node
    def set_Node(self, Node):
        self.Node = Node
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def get_missingValueStrategy(self):
        return self.missingValueStrategy
    def set_missingValueStrategy(self, missingValueStrategy):
        self.missingValueStrategy = missingValueStrategy
    def get_missingValuePenalty(self):
        return self.missingValuePenalty
    def set_missingValuePenalty(self, missingValuePenalty):
        self.missingValuePenalty = missingValuePenalty
    def get_noTrueChildStrategy(self):
        return self.noTrueChildStrategy
    def set_noTrueChildStrategy(self, noTrueChildStrategy):
        self.noTrueChildStrategy = noTrueChildStrategy
    def get_splitCharacteristic(self):
        return self.splitCharacteristic
    def set_splitCharacteristic(self, splitCharacteristic):
        self.splitCharacteristic = splitCharacteristic
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_MISSING_VALUE_STRATEGY(self, value):
        # Validate type MISSING-VALUE-STRATEGY, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['lastPrediction', 'nullPrediction', 'defaultChild', 'weightedConfidence', 'aggregateNodes', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MISSING-VALUE-STRATEGY' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_PROB_NUMBER(self, value):
        # Validate type PROB-NUMBER, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, decimal_.Decimal):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (decimal_.Decimal)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_NO_TRUE_CHILD_STRATEGY(self, value):
        # Validate type NO-TRUE-CHILD-STRATEGY, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['returnNullPrediction', 'returnLastPrediction']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on NO-TRUE-CHILD-STRATEGY' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_splitCharacteristicType7(self, value):
        # Validate type splitCharacteristicType7, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['binarySplit', 'multiSplit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on splitCharacteristicType7' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Extension or
            self.Output is not None or
            self.ModelStats is not None or
            self.Targets is not None or
            self.LocalTransformations is not None or
            self.ResultField or
            self.Node is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DecisionTree', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DecisionTree')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DecisionTree':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DecisionTree')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DecisionTree', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DecisionTree'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.missingValueStrategy != "none" and 'missingValueStrategy' not in already_processed:
            already_processed.add('missingValueStrategy')
            outfile.write(' missingValueStrategy=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.missingValueStrategy), input_name='missingValueStrategy')), ))
        if self.missingValuePenalty != 1.0 and 'missingValuePenalty' not in already_processed:
            already_processed.add('missingValuePenalty')
            outfile.write(' missingValuePenalty="%s"' % self.gds_format_decimal(self.missingValuePenalty, input_name='missingValuePenalty'))
        if self.noTrueChildStrategy != "returnNullPrediction" and 'noTrueChildStrategy' not in already_processed:
            already_processed.add('noTrueChildStrategy')
            outfile.write(' noTrueChildStrategy=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.noTrueChildStrategy), input_name='noTrueChildStrategy')), ))
        if self.splitCharacteristic != "multiSplit" and 'splitCharacteristic' not in already_processed:
            already_processed.add('splitCharacteristic')
            outfile.write(' splitCharacteristic=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.splitCharacteristic), input_name='splitCharacteristic')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='DecisionTree', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.Targets is not None:
            namespaceprefix_ = self.Targets_nsprefix_ + ':' if (UseCapturedNS_ and self.Targets_nsprefix_) else ''
            self.Targets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Targets', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        for ResultField_ in self.ResultField:
            namespaceprefix_ = self.ResultField_nsprefix_ + ':' if (UseCapturedNS_ and self.ResultField_nsprefix_) else ''
            ResultField_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResultField', pretty_print=pretty_print)
        if self.Node is not None:
            namespaceprefix_ = self.Node_nsprefix_ + ':' if (UseCapturedNS_ and self.Node_nsprefix_) else ''
            self.Node.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Node', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('missingValueStrategy', node)
        if value is not None and 'missingValueStrategy' not in already_processed:
            already_processed.add('missingValueStrategy')
            self.missingValueStrategy = value
            self.validate_MISSING_VALUE_STRATEGY(self.missingValueStrategy)    # validate type MISSING-VALUE-STRATEGY
        value = find_attr_value_('missingValuePenalty', node)
        if value is not None and 'missingValuePenalty' not in already_processed:
            already_processed.add('missingValuePenalty')
            value = self.gds_parse_decimal(value, node, 'missingValuePenalty')
            self.missingValuePenalty = value
            self.validate_PROB_NUMBER(self.missingValuePenalty)    # validate type PROB-NUMBER
        value = find_attr_value_('noTrueChildStrategy', node)
        if value is not None and 'noTrueChildStrategy' not in already_processed:
            already_processed.add('noTrueChildStrategy')
            self.noTrueChildStrategy = value
            self.validate_NO_TRUE_CHILD_STRATEGY(self.noTrueChildStrategy)    # validate type NO-TRUE-CHILD-STRATEGY
        value = find_attr_value_('splitCharacteristic', node)
        if value is not None and 'splitCharacteristic' not in already_processed:
            already_processed.add('splitCharacteristic')
            self.splitCharacteristic = value
            self.validate_splitCharacteristicType7(self.splitCharacteristic)    # validate type splitCharacteristicType7
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'Targets':
            obj_ = Targets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Targets = obj_
            obj_.original_tagname_ = 'Targets'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'ResultField':
            obj_ = ResultField.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResultField.append(obj_)
            obj_.original_tagname_ = 'ResultField'
        elif nodeName_ == 'Node':
            obj_ = Node.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Node = obj_
            obj_.original_tagname_ = 'Node'
# end class DecisionTree


class TimeSeriesModel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, modelName=None, functionName=None, algorithmName=None, bestFit=None, MiningSchema=None, Output=None, ModelStats=None, LocalTransformations=None, TimeSeries=None, SpectralAnalysis=None, ARIMA=None, ExponentialSmoothing=None, SeasonalTrendDecomposition=None, ModelVerification=None, Extension=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modelName = _cast(None, modelName)
        self.modelName_nsprefix_ = None
        self.functionName = _cast(None, functionName)
        self.functionName_nsprefix_ = None
        self.algorithmName = _cast(None, algorithmName)
        self.algorithmName_nsprefix_ = None
        self.bestFit = _cast(None, bestFit)
        self.bestFit_nsprefix_ = None
        self.MiningSchema = MiningSchema
        self.MiningSchema_nsprefix_ = None
        self.Output = Output
        self.Output_nsprefix_ = None
        self.ModelStats = ModelStats
        self.ModelStats_nsprefix_ = None
        self.LocalTransformations = LocalTransformations
        self.LocalTransformations_nsprefix_ = None
        if TimeSeries is None:
            self.TimeSeries = []
        else:
            self.TimeSeries = TimeSeries
        self.TimeSeries_nsprefix_ = None
        self.SpectralAnalysis = SpectralAnalysis
        self.SpectralAnalysis_nsprefix_ = None
        self.ARIMA = ARIMA
        self.ARIMA_nsprefix_ = None
        self.ExponentialSmoothing = ExponentialSmoothing
        self.ExponentialSmoothing_nsprefix_ = None
        self.SeasonalTrendDecomposition = SeasonalTrendDecomposition
        self.SeasonalTrendDecomposition_nsprefix_ = None
        self.ModelVerification = ModelVerification
        self.ModelVerification_nsprefix_ = None
        if Extension is None:
            self.Extension = []
        else:
            self.Extension = Extension
        self.Extension_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeSeriesModel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeSeriesModel.subclass:
            return TimeSeriesModel.subclass(*args_, **kwargs_)
        else:
            return TimeSeriesModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MiningSchema(self):
        return self.MiningSchema
    def set_MiningSchema(self, MiningSchema):
        self.MiningSchema = MiningSchema
    def get_Output(self):
        return self.Output
    def set_Output(self, Output):
        self.Output = Output
    def get_ModelStats(self):
        return self.ModelStats
    def set_ModelStats(self, ModelStats):
        self.ModelStats = ModelStats
    def get_LocalTransformations(self):
        return self.LocalTransformations
    def set_LocalTransformations(self, LocalTransformations):
        self.LocalTransformations = LocalTransformations
    def get_TimeSeries(self):
        return self.TimeSeries
    def set_TimeSeries(self, TimeSeries):
        self.TimeSeries = TimeSeries
    def add_TimeSeries(self, value):
        self.TimeSeries.append(value)
    def insert_TimeSeries_at(self, index, value):
        self.TimeSeries.insert(index, value)
    def replace_TimeSeries_at(self, index, value):
        self.TimeSeries[index] = value
    def get_SpectralAnalysis(self):
        return self.SpectralAnalysis
    def set_SpectralAnalysis(self, SpectralAnalysis):
        self.SpectralAnalysis = SpectralAnalysis
    def get_ARIMA(self):
        return self.ARIMA
    def set_ARIMA(self, ARIMA):
        self.ARIMA = ARIMA
    def get_ExponentialSmoothing(self):
        return self.ExponentialSmoothing
    def set_ExponentialSmoothing(self, ExponentialSmoothing):
        self.ExponentialSmoothing = ExponentialSmoothing
    def get_SeasonalTrendDecomposition(self):
        return self.SeasonalTrendDecomposition
    def set_SeasonalTrendDecomposition(self, SeasonalTrendDecomposition):
        self.SeasonalTrendDecomposition = SeasonalTrendDecomposition
    def get_ModelVerification(self):
        return self.ModelVerification
    def set_ModelVerification(self, ModelVerification):
        self.ModelVerification = ModelVerification
    def get_Extension(self):
        return self.Extension
    def set_Extension(self, Extension):
        self.Extension = Extension
    def add_Extension(self, value):
        self.Extension.append(value)
    def insert_Extension_at(self, index, value):
        self.Extension.insert(index, value)
    def replace_Extension_at(self, index, value):
        self.Extension[index] = value
    def get_modelName(self):
        return self.modelName
    def set_modelName(self, modelName):
        self.modelName = modelName
    def get_functionName(self):
        return self.functionName
    def set_functionName(self, functionName):
        self.functionName = functionName
    def get_algorithmName(self):
        return self.algorithmName
    def set_algorithmName(self, algorithmName):
        self.algorithmName = algorithmName
    def get_bestFit(self):
        return self.bestFit
    def set_bestFit(self, bestFit):
        self.bestFit = bestFit
    def validate_MINING_FUNCTION(self, value):
        # Validate type MINING-FUNCTION, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['associationRules', 'sequences', 'classification', 'regression', 'clustering', 'timeSeries']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MINING-FUNCTION' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_TIMESERIES_ALGORITHM(self, value):
        # Validate type TIMESERIES-ALGORITHM, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ARIMA', 'ExponentialSmoothing', 'SeasonalTrendDecomposition', 'SpectralAnalysis']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TIMESERIES-ALGORITHM' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.MiningSchema is not None or
            self.Output is not None or
            self.ModelStats is not None or
            self.LocalTransformations is not None or
            self.TimeSeries or
            self.SpectralAnalysis is not None or
            self.ARIMA is not None or
            self.ExponentialSmoothing is not None or
            self.SeasonalTrendDecomposition is not None or
            self.ModelVerification is not None or
            self.Extension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TimeSeriesModel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeSeriesModel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeSeriesModel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeSeriesModel')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeSeriesModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeSeriesModel'):
        if self.modelName is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            outfile.write(' modelName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modelName), input_name='modelName')), ))
        if self.functionName is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            outfile.write(' functionName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.functionName), input_name='functionName')), ))
        if self.algorithmName is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            outfile.write(' algorithmName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithmName), input_name='algorithmName')), ))
        if self.bestFit is not None and 'bestFit' not in already_processed:
            already_processed.add('bestFit')
            outfile.write(' bestFit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bestFit), input_name='bestFit')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TimeSeriesModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MiningSchema is not None:
            namespaceprefix_ = self.MiningSchema_nsprefix_ + ':' if (UseCapturedNS_ and self.MiningSchema_nsprefix_) else ''
            self.MiningSchema.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MiningSchema', pretty_print=pretty_print)
        if self.Output is not None:
            namespaceprefix_ = self.Output_nsprefix_ + ':' if (UseCapturedNS_ and self.Output_nsprefix_) else ''
            self.Output.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Output', pretty_print=pretty_print)
        if self.ModelStats is not None:
            namespaceprefix_ = self.ModelStats_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelStats_nsprefix_) else ''
            self.ModelStats.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelStats', pretty_print=pretty_print)
        if self.LocalTransformations is not None:
            namespaceprefix_ = self.LocalTransformations_nsprefix_ + ':' if (UseCapturedNS_ and self.LocalTransformations_nsprefix_) else ''
            self.LocalTransformations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LocalTransformations', pretty_print=pretty_print)
        for TimeSeries_ in self.TimeSeries:
            namespaceprefix_ = self.TimeSeries_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeSeries_nsprefix_) else ''
            TimeSeries_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeSeries', pretty_print=pretty_print)
        if self.SpectralAnalysis is not None:
            namespaceprefix_ = self.SpectralAnalysis_nsprefix_ + ':' if (UseCapturedNS_ and self.SpectralAnalysis_nsprefix_) else ''
            self.SpectralAnalysis.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SpectralAnalysis', pretty_print=pretty_print)
        if self.ARIMA is not None:
            namespaceprefix_ = self.ARIMA_nsprefix_ + ':' if (UseCapturedNS_ and self.ARIMA_nsprefix_) else ''
            self.ARIMA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ARIMA', pretty_print=pretty_print)
        if self.ExponentialSmoothing is not None:
            namespaceprefix_ = self.ExponentialSmoothing_nsprefix_ + ':' if (UseCapturedNS_ and self.ExponentialSmoothing_nsprefix_) else ''
            self.ExponentialSmoothing.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ExponentialSmoothing', pretty_print=pretty_print)
        if self.SeasonalTrendDecomposition is not None:
            namespaceprefix_ = self.SeasonalTrendDecomposition_nsprefix_ + ':' if (UseCapturedNS_ and self.SeasonalTrendDecomposition_nsprefix_) else ''
            self.SeasonalTrendDecomposition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SeasonalTrendDecomposition', pretty_print=pretty_print)
        if self.ModelVerification is not None:
            namespaceprefix_ = self.ModelVerification_nsprefix_ + ':' if (UseCapturedNS_ and self.ModelVerification_nsprefix_) else ''
            self.ModelVerification.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ModelVerification', pretty_print=pretty_print)
        for Extension_ in self.Extension:
            namespaceprefix_ = self.Extension_nsprefix_ + ':' if (UseCapturedNS_ and self.Extension_nsprefix_) else ''
            Extension_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Extension', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modelName', node)
        if value is not None and 'modelName' not in already_processed:
            already_processed.add('modelName')
            self.modelName = value
        value = find_attr_value_('functionName', node)
        if value is not None and 'functionName' not in already_processed:
            already_processed.add('functionName')
            self.functionName = value
            self.validate_MINING_FUNCTION(self.functionName)    # validate type MINING-FUNCTION
        value = find_attr_value_('algorithmName', node)
        if value is not None and 'algorithmName' not in already_processed:
            already_processed.add('algorithmName')
            self.algorithmName = value
        value = find_attr_value_('bestFit', node)
        if value is not None and 'bestFit' not in already_processed:
            already_processed.add('bestFit')
            self.bestFit = value
            self.validate_TIMESERIES_ALGORITHM(self.bestFit)    # validate type TIMESERIES-ALGORITHM
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MiningSchema':
            obj_ = MiningSchema.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MiningSchema = obj_
            obj_.original_tagname_ = 'MiningSchema'
        elif nodeName_ == 'Output':
            obj_ = Output.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Output = obj_
            obj_.original_tagname_ = 'Output'
        elif nodeName_ == 'ModelStats':
            obj_ = ModelStats.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelStats = obj_
            obj_.original_tagname_ = 'ModelStats'
        elif nodeName_ == 'LocalTransformations':
            obj_ = LocalTransformations.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LocalTransformations = obj_
            obj_.original_tagname_ = 'LocalTransformations'
        elif nodeName_ == 'TimeSeries':
            obj_ = TimeSeries.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeSeries.append(obj_)
            obj_.original_tagname_ = 'TimeSeries'
        elif nodeName_ == 'SpectralAnalysis':
            obj_ = SpectralAnalysis.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SpectralAnalysis = obj_
            obj_.original_tagname_ = 'SpectralAnalysis'
        elif nodeName_ == 'ARIMA':
            obj_ = ARIMA.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ARIMA = obj_
            obj_.original_tagname_ = 'ARIMA'
        elif nodeName_ == 'ExponentialSmoothing':
            obj_ = ExponentialSmoothing.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ExponentialSmoothing = obj_
            obj_.original_tagname_ = 'ExponentialSmoothing'
        elif nodeName_ == 'SeasonalTrendDecomposition':
            obj_ = SeasonalTrendDecomposition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SeasonalTrendDecomposition = obj_
            obj_.original_tagname_ = 'SeasonalTrendDecomposition'
        elif nodeName_ == 'ModelVerification':
            obj_ = ModelVerification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ModelVerification = obj_
            obj_.original_tagname_ = 'ModelVerification'
        elif nodeName_ == 'Extension':
            obj_ = Extension.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Extension.append(obj_)
            obj_.original_tagname_ = 'Extension'
# end class TimeSeriesModel


class TimeSeries(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, usage='original', startTime=None, endTime=None, interpolationMethod='none', TimeAnchor=None, TimeException=None, TimeValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.usage = _cast(None, usage)
        self.usage_nsprefix_ = None
        self.startTime = _cast(float, startTime)
        self.startTime_nsprefix_ = None
        self.endTime = _cast(float, endTime)
        self.endTime_nsprefix_ = None
        self.interpolationMethod = _cast(None, interpolationMethod)
        self.interpolationMethod_nsprefix_ = None
        self.TimeAnchor = TimeAnchor
        self.TimeAnchor_nsprefix_ = None
        if TimeException is None:
            self.TimeException = []
        else:
            self.TimeException = TimeException
        self.TimeException_nsprefix_ = None
        if TimeValue is None:
            self.TimeValue = []
        else:
            self.TimeValue = TimeValue
        self.TimeValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeSeries)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeSeries.subclass:
            return TimeSeries.subclass(*args_, **kwargs_)
        else:
            return TimeSeries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TimeAnchor(self):
        return self.TimeAnchor
    def set_TimeAnchor(self, TimeAnchor):
        self.TimeAnchor = TimeAnchor
    def get_TimeException(self):
        return self.TimeException
    def set_TimeException(self, TimeException):
        self.TimeException = TimeException
    def add_TimeException(self, value):
        self.TimeException.append(value)
    def insert_TimeException_at(self, index, value):
        self.TimeException.insert(index, value)
    def replace_TimeException_at(self, index, value):
        self.TimeException[index] = value
    def get_TimeValue(self):
        return self.TimeValue
    def set_TimeValue(self, TimeValue):
        self.TimeValue = TimeValue
    def add_TimeValue(self, value):
        self.TimeValue.append(value)
    def insert_TimeValue_at(self, index, value):
        self.TimeValue.insert(index, value)
    def replace_TimeValue_at(self, index, value):
        self.TimeValue[index] = value
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_startTime(self):
        return self.startTime
    def set_startTime(self, startTime):
        self.startTime = startTime
    def get_endTime(self):
        return self.endTime
    def set_endTime(self, endTime):
        self.endTime = endTime
    def get_interpolationMethod(self):
        return self.interpolationMethod
    def set_interpolationMethod(self, interpolationMethod):
        self.interpolationMethod = interpolationMethod
    def validate_TIMESERIES_USAGE(self, value):
        # Validate type TIMESERIES-USAGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['original', 'logical', 'prediction']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TIMESERIES-USAGE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_INTERPOLATION_METHOD(self, value):
        # Validate type INTERPOLATION-METHOD, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'linear', 'exponentialSpline', 'cubicSpline']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on INTERPOLATION-METHOD' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.TimeAnchor is not None or
            self.TimeException or
            self.TimeValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TimeSeries', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeSeries')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeSeries':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeSeries')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeSeries', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeSeries'):
        if self.usage != "original" and 'usage' not in already_processed:
            already_processed.add('usage')
            outfile.write(' usage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usage), input_name='usage')), ))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            outfile.write(' startTime="%s"' % self.gds_format_double(self.startTime, input_name='startTime'))
        if self.endTime is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            outfile.write(' endTime="%s"' % self.gds_format_double(self.endTime, input_name='endTime'))
        if self.interpolationMethod != "none" and 'interpolationMethod' not in already_processed:
            already_processed.add('interpolationMethod')
            outfile.write(' interpolationMethod=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.interpolationMethod), input_name='interpolationMethod')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TimeSeries', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TimeAnchor is not None:
            namespaceprefix_ = self.TimeAnchor_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeAnchor_nsprefix_) else ''
            self.TimeAnchor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeAnchor', pretty_print=pretty_print)
        for TimeException_ in self.TimeException:
            namespaceprefix_ = self.TimeException_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeException_nsprefix_) else ''
            TimeException_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeException', pretty_print=pretty_print)
        for TimeValue_ in self.TimeValue:
            namespaceprefix_ = self.TimeValue_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeValue_nsprefix_) else ''
            TimeValue_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeValue', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('usage', node)
        if value is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            self.usage = value
            self.validate_TIMESERIES_USAGE(self.usage)    # validate type TIMESERIES-USAGE
        value = find_attr_value_('startTime', node)
        if value is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            value = self.gds_parse_double(value, node, 'startTime')
            self.startTime = value
            self.validate_REAL_NUMBER(self.startTime)    # validate type REAL-NUMBER
        value = find_attr_value_('endTime', node)
        if value is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            value = self.gds_parse_double(value, node, 'endTime')
            self.endTime = value
            self.validate_REAL_NUMBER(self.endTime)    # validate type REAL-NUMBER
        value = find_attr_value_('interpolationMethod', node)
        if value is not None and 'interpolationMethod' not in already_processed:
            already_processed.add('interpolationMethod')
            self.interpolationMethod = value
            self.validate_INTERPOLATION_METHOD(self.interpolationMethod)    # validate type INTERPOLATION-METHOD
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TimeAnchor':
            obj_ = TimeAnchor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeAnchor = obj_
            obj_.original_tagname_ = 'TimeAnchor'
        elif nodeName_ == 'TimeException':
            obj_ = TimeException.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeException.append(obj_)
            obj_.original_tagname_ = 'TimeException'
        elif nodeName_ == 'TimeValue':
            obj_ = TimeValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeValue.append(obj_)
            obj_.original_tagname_ = 'TimeValue'
# end class TimeSeries


class TimeValue(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, index=None, time=None, value=None, standardError=None, Timestamp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.index = _cast(int, index)
        self.index_nsprefix_ = None
        self.time = _cast(float, time)
        self.time_nsprefix_ = None
        self.value = _cast(float, value)
        self.value_nsprefix_ = None
        self.standardError = _cast(float, standardError)
        self.standardError_nsprefix_ = None
        self.Timestamp = Timestamp
        self.Timestamp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeValue.subclass:
            return TimeValue.subclass(*args_, **kwargs_)
        else:
            return TimeValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Timestamp(self):
        return self.Timestamp
    def set_Timestamp(self, Timestamp):
        self.Timestamp = Timestamp
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_standardError(self):
        return self.standardError
    def set_standardError(self, standardError):
        self.standardError = standardError
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_NUMBER(self, value):
        # Validate type NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Timestamp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TimeValue', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeValue':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeValue')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeValue'):
        if self.index is not None and 'index' not in already_processed:
            already_processed.add('index')
            outfile.write(' index="%s"' % self.gds_format_integer(self.index, input_name='index'))
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time="%s"' % self.gds_format_double(self.time, input_name='time'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
        if self.standardError is not None and 'standardError' not in already_processed:
            already_processed.add('standardError')
            outfile.write(' standardError="%s"' % self.gds_format_double(self.standardError, input_name='standardError'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TimeValue', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Timestamp is not None:
            namespaceprefix_ = self.Timestamp_nsprefix_ + ':' if (UseCapturedNS_ and self.Timestamp_nsprefix_) else ''
            self.Timestamp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Timestamp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.add('index')
            self.index = self.gds_parse_integer(value, node, 'index')
            self.validate_INT_NUMBER(self.index)    # validate type INT-NUMBER
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            value = self.gds_parse_double(value, node, 'time')
            self.time = value
            self.validate_NUMBER(self.time)    # validate type NUMBER
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            value = self.gds_parse_double(value, node, 'value')
            self.value = value
            self.validate_REAL_NUMBER(self.value)    # validate type REAL-NUMBER
        value = find_attr_value_('standardError', node)
        if value is not None and 'standardError' not in already_processed:
            already_processed.add('standardError')
            value = self.gds_parse_double(value, node, 'standardError')
            self.standardError = value
            self.validate_REAL_NUMBER(self.standardError)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Timestamp':
            obj_ = Timestamp.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Timestamp = obj_
            obj_.original_tagname_ = 'Timestamp'
# end class TimeValue


class TimeAnchor(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, offset=None, stepsize=None, displayName=None, TimeCycle=None, TimeException=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.offset = _cast(int, offset)
        self.offset_nsprefix_ = None
        self.stepsize = _cast(int, stepsize)
        self.stepsize_nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        if TimeCycle is None:
            self.TimeCycle = []
        else:
            self.TimeCycle = TimeCycle
        self.TimeCycle_nsprefix_ = None
        if TimeException is None:
            self.TimeException = []
        else:
            self.TimeException = TimeException
        self.TimeException_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeAnchor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeAnchor.subclass:
            return TimeAnchor.subclass(*args_, **kwargs_)
        else:
            return TimeAnchor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TimeCycle(self):
        return self.TimeCycle
    def set_TimeCycle(self, TimeCycle):
        self.TimeCycle = TimeCycle
    def add_TimeCycle(self, value):
        self.TimeCycle.append(value)
    def insert_TimeCycle_at(self, index, value):
        self.TimeCycle.insert(index, value)
    def replace_TimeCycle_at(self, index, value):
        self.TimeCycle[index] = value
    def get_TimeException(self):
        return self.TimeException
    def set_TimeException(self, TimeException):
        self.TimeException = TimeException
    def add_TimeException(self, value):
        self.TimeException.append(value)
    def insert_TimeException_at(self, index, value):
        self.TimeException.insert(index, value)
    def replace_TimeException_at(self, index, value):
        self.TimeException[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def get_stepsize(self):
        return self.stepsize
    def set_stepsize(self, stepsize):
        self.stepsize = stepsize
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def validate_TIME_ANCHOR(self, value):
        # Validate type TIME-ANCHOR, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['dateTimeMillisecdondsSince[0]', 'dateTimeMillisecdondsSince[1960]', 'dateTimeMillisecdondsSince[1970]', 'dateTimeMillisecdondsSince[1980]', 'dateTimeSecdondsSince[0]', 'dateTimeSecdondsSince[1960]', 'dateTimeSecdondsSince[1970]', 'dateTimeSecdondsSince[1980]', 'dateDaysSince[0]', 'dateDaysSince[1960]', 'dateDaysSince[1970]', 'dateDaysSince[1980]', 'dateMonthsSince[0]', 'dateMonthsSince[1960]', 'dateMonthsSince[1970]', 'dateMonthsSince[1980]', 'dateYearsSince[0]']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TIME-ANCHOR' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.TimeCycle or
            self.TimeException
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TimeAnchor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeAnchor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeAnchor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeAnchor')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeAnchor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeAnchor'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
        if self.stepsize is not None and 'stepsize' not in already_processed:
            already_processed.add('stepsize')
            outfile.write(' stepsize="%s"' % self.gds_format_integer(self.stepsize, input_name='stepsize'))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TimeAnchor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TimeCycle_ in self.TimeCycle:
            namespaceprefix_ = self.TimeCycle_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeCycle_nsprefix_) else ''
            TimeCycle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeCycle', pretty_print=pretty_print)
        for TimeException_ in self.TimeException:
            namespaceprefix_ = self.TimeException_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeException_nsprefix_) else ''
            TimeException_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeException', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_TIME_ANCHOR(self.type_)    # validate type TIME-ANCHOR
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.add('offset')
            self.offset = self.gds_parse_integer(value, node, 'offset')
            self.validate_INT_NUMBER(self.offset)    # validate type INT-NUMBER
        value = find_attr_value_('stepsize', node)
        if value is not None and 'stepsize' not in already_processed:
            already_processed.add('stepsize')
            self.stepsize = self.gds_parse_integer(value, node, 'stepsize')
            self.validate_INT_NUMBER(self.stepsize)    # validate type INT-NUMBER
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TimeCycle':
            obj_ = TimeCycle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeCycle.append(obj_)
            obj_.original_tagname_ = 'TimeCycle'
        elif nodeName_ == 'TimeException':
            obj_ = TimeException.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeException.append(obj_)
            obj_.original_tagname_ = 'TimeException'
# end class TimeAnchor


class TimeCycle(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, length=None, type_=None, displayName=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.length = _cast(int, length)
        self.length_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.displayName = _cast(None, displayName)
        self.displayName_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeCycle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeCycle.subclass:
            return TimeCycle.subclass(*args_, **kwargs_)
        else:
            return TimeCycle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_VALID_TIME_SPEC(self, value):
        # Validate type VALID-TIME-SPEC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['includeAll', 'includeFromTo', 'excludeFromTo', 'includeSet', 'excludeSet']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on VALID-TIME-SPEC' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TimeCycle', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeCycle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeCycle':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeCycle')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeCycle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeCycle'):
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_integer(self.length, input_name='length'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayName), input_name='displayName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TimeCycle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            self.length = self.gds_parse_integer(value, node, 'length')
            self.validate_INT_NUMBER(self.length)    # validate type INT-NUMBER
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_VALID_TIME_SPEC(self.type_)    # validate type VALID-TIME-SPEC
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class TimeCycle


class TimeException(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, count=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.count = _cast(int, count)
        self.count_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeException)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeException.subclass:
            return TimeException.subclass(*args_, **kwargs_)
        else:
            return TimeException(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def validate_TIME_EXCEPTION_TYPE(self, value):
        # Validate type TIME-EXCEPTION-TYPE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['exclude', 'include']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on TIME-EXCEPTION-TYPE' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TimeException', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeException')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeException':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeException')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeException', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeException'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='TimeException', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_TIME_EXCEPTION_TYPE(self.type_)    # validate type TIME-EXCEPTION-TYPE
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            self.count = self.gds_parse_integer(value, node, 'count')
            self.validate_INT_NUMBER(self.count)    # validate type INT-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class TimeException


class ExponentialSmoothing(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, RMSE=None, transformation='none', Level=None, Trend=None, Seasonality_ExpoSmooth=None, TimeValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.RMSE = _cast(float, RMSE)
        self.RMSE_nsprefix_ = None
        self.transformation = _cast(None, transformation)
        self.transformation_nsprefix_ = None
        self.Level = Level
        self.Level_nsprefix_ = None
        self.Trend = Trend
        self.Trend_nsprefix_ = None
        self.Seasonality_ExpoSmooth = Seasonality_ExpoSmooth
        self.Seasonality_ExpoSmooth_nsprefix_ = None
        if TimeValue is None:
            self.TimeValue = []
        else:
            self.TimeValue = TimeValue
        self.TimeValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExponentialSmoothing)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExponentialSmoothing.subclass:
            return ExponentialSmoothing.subclass(*args_, **kwargs_)
        else:
            return ExponentialSmoothing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Level(self):
        return self.Level
    def set_Level(self, Level):
        self.Level = Level
    def get_Trend(self):
        return self.Trend
    def set_Trend(self, Trend):
        self.Trend = Trend
    def get_Seasonality_ExpoSmooth(self):
        return self.Seasonality_ExpoSmooth
    def set_Seasonality_ExpoSmooth(self, Seasonality_ExpoSmooth):
        self.Seasonality_ExpoSmooth = Seasonality_ExpoSmooth
    def get_TimeValue(self):
        return self.TimeValue
    def set_TimeValue(self, TimeValue):
        self.TimeValue = TimeValue
    def add_TimeValue(self, value):
        self.TimeValue.append(value)
    def insert_TimeValue_at(self, index, value):
        self.TimeValue.insert(index, value)
    def replace_TimeValue_at(self, index, value):
        self.TimeValue[index] = value
    def get_RMSE(self):
        return self.RMSE
    def set_RMSE(self, RMSE):
        self.RMSE = RMSE
    def get_transformation(self):
        return self.transformation
    def set_transformation(self, transformation):
        self.transformation = transformation
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_transformationType(self, value):
        # Validate type transformationType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['none', 'logarithmic', 'squareroot']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on transformationType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.Level is not None or
            self.Trend is not None or
            self.Seasonality_ExpoSmooth is not None or
            self.TimeValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ExponentialSmoothing', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExponentialSmoothing')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ExponentialSmoothing':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExponentialSmoothing')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ExponentialSmoothing', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExponentialSmoothing'):
        if self.RMSE is not None and 'RMSE' not in already_processed:
            already_processed.add('RMSE')
            outfile.write(' RMSE="%s"' % self.gds_format_double(self.RMSE, input_name='RMSE'))
        if self.transformation != "none" and 'transformation' not in already_processed:
            already_processed.add('transformation')
            outfile.write(' transformation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transformation), input_name='transformation')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='ExponentialSmoothing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Level is not None:
            namespaceprefix_ = self.Level_nsprefix_ + ':' if (UseCapturedNS_ and self.Level_nsprefix_) else ''
            self.Level.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Level', pretty_print=pretty_print)
        if self.Trend is not None:
            namespaceprefix_ = self.Trend_nsprefix_ + ':' if (UseCapturedNS_ and self.Trend_nsprefix_) else ''
            self.Trend.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Trend', pretty_print=pretty_print)
        if self.Seasonality_ExpoSmooth is not None:
            namespaceprefix_ = self.Seasonality_ExpoSmooth_nsprefix_ + ':' if (UseCapturedNS_ and self.Seasonality_ExpoSmooth_nsprefix_) else ''
            self.Seasonality_ExpoSmooth.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Seasonality_ExpoSmooth', pretty_print=pretty_print)
        for TimeValue_ in self.TimeValue:
            namespaceprefix_ = self.TimeValue_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeValue_nsprefix_) else ''
            TimeValue_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeValue', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('RMSE', node)
        if value is not None and 'RMSE' not in already_processed:
            already_processed.add('RMSE')
            value = self.gds_parse_double(value, node, 'RMSE')
            self.RMSE = value
            self.validate_REAL_NUMBER(self.RMSE)    # validate type REAL-NUMBER
        value = find_attr_value_('transformation', node)
        if value is not None and 'transformation' not in already_processed:
            already_processed.add('transformation')
            self.transformation = value
            self.validate_transformationType(self.transformation)    # validate type transformationType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Level':
            obj_ = Level.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Level = obj_
            obj_.original_tagname_ = 'Level'
        elif nodeName_ == 'Trend':
            obj_ = Trend.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Trend = obj_
            obj_.original_tagname_ = 'Trend'
        elif nodeName_ == 'Seasonality_ExpoSmooth':
            obj_ = Seasonality_ExpoSmooth.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Seasonality_ExpoSmooth = obj_
            obj_.original_tagname_ = 'Seasonality_ExpoSmooth'
        elif nodeName_ == 'TimeValue':
            obj_ = TimeValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeValue.append(obj_)
            obj_.original_tagname_ = 'TimeValue'
# end class ExponentialSmoothing


class Seasonality_ExpoSmooth(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, period=None, unit=None, phase=None, delta=None, Array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.period = _cast(int, period)
        self.period_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.phase = _cast(int, phase)
        self.phase_nsprefix_ = None
        self.delta = _cast(float, delta)
        self.delta_nsprefix_ = None
        self.Array = Array
        self.Array_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Seasonality_ExpoSmooth)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Seasonality_ExpoSmooth.subclass:
            return Seasonality_ExpoSmooth.subclass(*args_, **kwargs_)
        else:
            return Seasonality_ExpoSmooth(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Array(self):
        return self.Array
    def set_Array(self, Array):
        self.Array = Array
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_phase(self):
        return self.phase
    def set_phase(self, phase):
        self.phase = phase
    def get_delta(self):
        return self.delta
    def set_delta(self, delta):
        self.delta = delta
    def validate_typeType8(self, value):
        # Validate type typeType8, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['additive', 'multiplicative']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType8' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_INT_NUMBER(self, value):
        # Validate type INT-NUMBER, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Array is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Seasonality_ExpoSmooth', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Seasonality_ExpoSmooth')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Seasonality_ExpoSmooth':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Seasonality_ExpoSmooth')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Seasonality_ExpoSmooth', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Seasonality_ExpoSmooth'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.period is not None and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period="%s"' % self.gds_format_integer(self.period, input_name='period'))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.phase is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            outfile.write(' phase="%s"' % self.gds_format_integer(self.phase, input_name='phase'))
        if self.delta is not None and 'delta' not in already_processed:
            already_processed.add('delta')
            outfile.write(' delta="%s"' % self.gds_format_double(self.delta, input_name='delta'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="https://www.dmg.org/PMML-4_0" ', name_='Seasonality_ExpoSmooth', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Array is not None:
            namespaceprefix_ = self.Array_nsprefix_ + ':' if (UseCapturedNS_ and self.Array_nsprefix_) else ''
            self.Array.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_typeType8(self.type_)    # validate type typeType8
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            self.period = self.gds_parse_integer(value, node, 'period')
            self.validate_INT_NUMBER(self.period)    # validate type INT-NUMBER
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('phase', node)
        if value is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            self.phase = self.gds_parse_integer(value, node, 'phase')
            self.validate_INT_NUMBER(self.phase)    # validate type INT-NUMBER
        value = find_attr_value_('delta', node)
        if value is not None and 'delta' not in already_processed:
            already_processed.add('delta')
            value = self.gds_parse_double(value, node, 'delta')
            self.delta = value
            self.validate_REAL_NUMBER(self.delta)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Array':
            obj_ = ArrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Array = obj_
            obj_.original_tagname_ = 'Array'
# end class Seasonality_ExpoSmooth


class Level(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, alpha=None, smoothedValue=None, quadraticSmoothedValue=None, cubicSmoothedValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.alpha = _cast(float, alpha)
        self.alpha_nsprefix_ = None
        self.smoothedValue = _cast(float, smoothedValue)
        self.smoothedValue_nsprefix_ = None
        self.quadraticSmoothedValue = _cast(float, quadraticSmoothedValue)
        self.quadraticSmoothedValue_nsprefix_ = None
        self.cubicSmoothedValue = _cast(float, cubicSmoothedValue)
        self.cubicSmoothedValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Level)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Level.subclass:
            return Level.subclass(*args_, **kwargs_)
        else:
            return Level(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alpha(self):
        return self.alpha
    def set_alpha(self, alpha):
        self.alpha = alpha
    def get_smoothedValue(self):
        return self.smoothedValue
    def set_smoothedValue(self, smoothedValue):
        self.smoothedValue = smoothedValue
    def get_quadraticSmoothedValue(self):
        return self.quadraticSmoothedValue
    def set_quadraticSmoothedValue(self, quadraticSmoothedValue):
        self.quadraticSmoothedValue = quadraticSmoothedValue
    def get_cubicSmoothedValue(self):
        return self.cubicSmoothedValue
    def set_cubicSmoothedValue(self, cubicSmoothedValue):
        self.cubicSmoothedValue = cubicSmoothedValue
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Level', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Level')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Level':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Level')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Level', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Level'):
        if self.alpha is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            outfile.write(' alpha="%s"' % self.gds_format_double(self.alpha, input_name='alpha'))
        if self.smoothedValue is not None and 'smoothedValue' not in already_processed:
            already_processed.add('smoothedValue')
            outfile.write(' smoothedValue="%s"' % self.gds_format_double(self.smoothedValue, input_name='smoothedValue'))
        if self.quadraticSmoothedValue is not None and 'quadraticSmoothedValue' not in already_processed:
            already_processed.add('quadraticSmoothedValue')
            outfile.write(' quadraticSmoothedValue="%s"' % self.gds_format_double(self.quadraticSmoothedValue, input_name='quadraticSmoothedValue'))
        if self.cubicSmoothedValue is not None and 'cubicSmoothedValue' not in already_processed:
            already_processed.add('cubicSmoothedValue')
            outfile.write(' cubicSmoothedValue="%s"' % self.gds_format_double(self.cubicSmoothedValue, input_name='cubicSmoothedValue'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Level', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('alpha', node)
        if value is not None and 'alpha' not in already_processed:
            already_processed.add('alpha')
            value = self.gds_parse_double(value, node, 'alpha')
            self.alpha = value
            self.validate_REAL_NUMBER(self.alpha)    # validate type REAL-NUMBER
        value = find_attr_value_('smoothedValue', node)
        if value is not None and 'smoothedValue' not in already_processed:
            already_processed.add('smoothedValue')
            value = self.gds_parse_double(value, node, 'smoothedValue')
            self.smoothedValue = value
            self.validate_REAL_NUMBER(self.smoothedValue)    # validate type REAL-NUMBER
        value = find_attr_value_('quadraticSmoothedValue', node)
        if value is not None and 'quadraticSmoothedValue' not in already_processed:
            already_processed.add('quadraticSmoothedValue')
            value = self.gds_parse_double(value, node, 'quadraticSmoothedValue')
            self.quadraticSmoothedValue = value
            self.validate_REAL_NUMBER(self.quadraticSmoothedValue)    # validate type REAL-NUMBER
        value = find_attr_value_('cubicSmoothedValue', node)
        if value is not None and 'cubicSmoothedValue' not in already_processed:
            already_processed.add('cubicSmoothedValue')
            value = self.gds_parse_double(value, node, 'cubicSmoothedValue')
            self.cubicSmoothedValue = value
            self.validate_REAL_NUMBER(self.cubicSmoothedValue)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Level


class Trend(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, trend='additive', gamma=None, phi='1', smoothedValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.trend = _cast(None, trend)
        self.trend_nsprefix_ = None
        self.gamma = _cast(float, gamma)
        self.gamma_nsprefix_ = None
        self.phi = _cast(float, phi)
        self.phi_nsprefix_ = None
        self.smoothedValue = _cast(float, smoothedValue)
        self.smoothedValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Trend)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Trend.subclass:
            return Trend.subclass(*args_, **kwargs_)
        else:
            return Trend(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_trend(self):
        return self.trend
    def set_trend(self, trend):
        self.trend = trend
    def get_gamma(self):
        return self.gamma
    def set_gamma(self, gamma):
        self.gamma = gamma
    def get_phi(self):
        return self.phi
    def set_phi(self, phi):
        self.phi = phi
    def get_smoothedValue(self):
        return self.smoothedValue
    def set_smoothedValue(self, smoothedValue):
        self.smoothedValue = smoothedValue
    def validate_trendType(self, value):
        # Validate type trendType, a restriction on xs:NMTOKEN.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['additive', 'damped_additive', 'multiplicative', 'damped_multiplicative', 'double_exponential']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on trendType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_REAL_NUMBER(self, value):
        # Validate type REAL-NUMBER, a restriction on xs:double.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Trend', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Trend')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Trend':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Trend')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Trend', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Trend'):
        if self.trend != "additive" and 'trend' not in already_processed:
            already_processed.add('trend')
            outfile.write(' trend=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.trend), input_name='trend')), ))
        if self.gamma is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            outfile.write(' gamma="%s"' % self.gds_format_double(self.gamma, input_name='gamma'))
        if self.phi != 1 and 'phi' not in already_processed:
            already_processed.add('phi')
            outfile.write(' phi="%s"' % self.gds_format_double(self.phi, input_name='phi'))
        if self.smoothedValue is not None and 'smoothedValue' not in already_processed:
            already_processed.add('smoothedValue')
            outfile.write(' smoothedValue="%s"' % self.gds_format_double(self.smoothedValue, input_name='smoothedValue'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Trend', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('trend', node)
        if value is not None and 'trend' not in already_processed:
            already_processed.add('trend')
            self.trend = value
            self.validate_trendType(self.trend)    # validate type trendType
        value = find_attr_value_('gamma', node)
        if value is not None and 'gamma' not in already_processed:
            already_processed.add('gamma')
            value = self.gds_parse_double(value, node, 'gamma')
            self.gamma = value
            self.validate_REAL_NUMBER(self.gamma)    # validate type REAL-NUMBER
        value = find_attr_value_('phi', node)
        if value is not None and 'phi' not in already_processed:
            already_processed.add('phi')
            value = self.gds_parse_double(value, node, 'phi')
            self.phi = value
            self.validate_REAL_NUMBER(self.phi)    # validate type REAL-NUMBER
        value = find_attr_value_('smoothedValue', node)
        if value is not None and 'smoothedValue' not in already_processed:
            already_processed.add('smoothedValue')
            value = self.gds_parse_double(value, node, 'smoothedValue')
            self.smoothedValue = value
            self.validate_REAL_NUMBER(self.smoothedValue)    # validate type REAL-NUMBER
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Trend


class SpectralAnalysis(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpectralAnalysis)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpectralAnalysis.subclass:
            return SpectralAnalysis.subclass(*args_, **kwargs_)
        else:
            return SpectralAnalysis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpectralAnalysis', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SpectralAnalysis')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SpectralAnalysis':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SpectralAnalysis')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SpectralAnalysis', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SpectralAnalysis'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SpectralAnalysis', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SpectralAnalysis


class ARIMA(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ARIMA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ARIMA.subclass:
            return ARIMA.subclass(*args_, **kwargs_)
        else:
            return ARIMA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ARIMA', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ARIMA')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ARIMA':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ARIMA')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ARIMA', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ARIMA'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ARIMA', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ARIMA


class SeasonalTrendDecomposition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SeasonalTrendDecomposition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SeasonalTrendDecomposition.subclass:
            return SeasonalTrendDecomposition.subclass(*args_, **kwargs_)
        else:
            return SeasonalTrendDecomposition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SeasonalTrendDecomposition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SeasonalTrendDecomposition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SeasonalTrendDecomposition':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SeasonalTrendDecomposition')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SeasonalTrendDecomposition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SeasonalTrendDecomposition'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SeasonalTrendDecomposition', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SeasonalTrendDecomposition


GDSClassesMapping = {
    'Array': ArrayType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PMML'
        rootClass = PMML
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PMML'
        rootClass = PMML
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PMML'
        rootClass = PMML
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PMML'
        rootClass = PMML
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from pmml_40 import *\n\n')
        sys.stdout.write('import pmml_40 as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'https://www.dmg.org/PMML-4_0': [('MINING-FUNCTION', 'pmml-4-0.xsd', 'ST'),
                                  ('NUMBER', 'pmml-4-0.xsd', 'ST'),
                                  ('INT-NUMBER', 'pmml-4-0.xsd', 'ST'),
                                  ('REAL-NUMBER', 'pmml-4-0.xsd', 'ST'),
                                  ('PROB-NUMBER', 'pmml-4-0.xsd', 'ST'),
                                  ('PERCENTAGE-NUMBER', 'pmml-4-0.xsd', 'ST'),
                                  ('FIELD-NAME', 'pmml-4-0.xsd', 'ST'),
                                  ('OPTYPE', 'pmml-4-0.xsd', 'ST'),
                                  ('DATATYPE', 'pmml-4-0.xsd', 'ST'),
                                  ('FIELD-USAGE-TYPE', 'pmml-4-0.xsd', 'ST'),
                                  ('OUTLIER-TREATMENT-METHOD',
                                   'pmml-4-0.xsd',
                                   'ST'),
                                  ('MISSING-VALUE-TREATMENT-METHOD',
                                   'pmml-4-0.xsd',
                                   'ST'),
                                  ('INVALID-VALUE-TREATMENT-METHOD',
                                   'pmml-4-0.xsd',
                                   'ST'),
                                  ('RESULT-FEATURE', 'pmml-4-0.xsd', 'ST'),
                                  ('RULE-FEATURE', 'pmml-4-0.xsd', 'ST'),
                                  ('ACTIVATION-FUNCTION', 'pmml-4-0.xsd', 'ST'),
                                  ('NN-NORMALIZATION-METHOD',
                                   'pmml-4-0.xsd',
                                   'ST'),
                                  ('NN-NEURON-ID', 'pmml-4-0.xsd', 'ST'),
                                  ('NN-NEURON-IDREF', 'pmml-4-0.xsd', 'ST'),
                                  ('COMPARE-FUNCTION', 'pmml-4-0.xsd', 'ST'),
                                  ('MISSING-VALUE-STRATEGY',
                                   'pmml-4-0.xsd',
                                   'ST'),
                                  ('NO-TRUE-CHILD-STRATEGY',
                                   'pmml-4-0.xsd',
                                   'ST'),
                                  ('REGRESSIONNORMALIZATIONMETHOD',
                                   'pmml-4-0.xsd',
                                   'ST'),
                                  ('SVM-CLASSIFICATION-METHOD',
                                   'pmml-4-0.xsd',
                                   'ST'),
                                  ('SVM-REPRESENTATION', 'pmml-4-0.xsd', 'ST'),
                                  ('VECTOR-ID', 'pmml-4-0.xsd', 'ST'),
                                  ('CUMULATIVE-LINK-FUNCTION',
                                   'pmml-4-0.xsd',
                                   'ST'),
                                  ('LINK-FUNCTION', 'pmml-4-0.xsd', 'ST'),
                                  ('ELEMENT-ID', 'pmml-4-0.xsd', 'ST'),
                                  ('DELIMITER', 'pmml-4-0.xsd', 'ST'),
                                  ('GAP', 'pmml-4-0.xsd', 'ST'),
                                  ('MULTIPLE-MODEL-METHOD',
                                   'pmml-4-0.xsd',
                                   'ST'),
                                  ('TIMESERIES-ALGORITHM',
                                   'pmml-4-0.xsd',
                                   'ST'),
                                  ('TIMESERIES-USAGE', 'pmml-4-0.xsd', 'ST'),
                                  ('TIME-ANCHOR', 'pmml-4-0.xsd', 'ST'),
                                  ('VALID-TIME-SPEC', 'pmml-4-0.xsd', 'ST'),
                                  ('TIME-EXCEPTION-TYPE', 'pmml-4-0.xsd', 'ST'),
                                  ('INTERPOLATION-METHOD',
                                   'pmml-4-0.xsd',
                                   'ST'),
                                  ('ArrayType', 'pmml-4-0.xsd', 'CT')]}

__all__ = [
    "ARIMA",
    "Aggregate",
    "Annotation",
    "Anova",
    "AnovaRow",
    "AntecedentSequence",
    "Application",
    "Apply",
    "ArrayType",
    "AssociationModel",
    "AssociationRule",
    "BaseCumHazardTables",
    "BaselineCell",
    "BaselineStratum",
    "BayesInput",
    "BayesInputs",
    "BayesOutput",
    "BoundaryValueMeans",
    "BoundaryValues",
    "CategoricalPredictor",
    "ChildParent",
    "ClassLabels",
    "Cluster",
    "ClusteringField",
    "ClusteringModel",
    "ClusteringModelQuality",
    "Coefficient",
    "Coefficients",
    "ComparisonMeasure",
    "Comparisons",
    "CompoundPredicate",
    "CompoundRule",
    "Con",
    "ConfusionMatrix",
    "ConsequentSequence",
    "Constant",
    "Constraints",
    "ContStats",
    "CorrelationFields",
    "CorrelationMethods",
    "CorrelationValues",
    "Correlations",
    "Counts",
    "Covariances",
    "CovariateList",
    "DataDictionary",
    "DataField",
    "DecisionTree",
    "DefineFunction",
    "Delimiter",
    "DerivedField",
    "DiscrStats",
    "Discretize",
    "DiscretizeBin",
    "DocumentTermMatrix",
    "EventValues",
    "ExponentialSmoothing",
    "Extension",
    "FactorList",
    "False_",
    "FieldColumnPair",
    "FieldRef",
    "GeneralRegressionModel",
    "Header",
    "INT_Entries",
    "INT_SparseArray",
    "Indices",
    "InlineTable",
    "Interval",
    "Item",
    "ItemRef",
    "Itemset",
    "KohonenMap",
    "Level",
    "LiftData",
    "LiftGraph",
    "LinearKernelType",
    "LinearNorm",
    "LocalTransformations",
    "MapValues",
    "MatCell",
    "Matrix",
    "MiningBuildTask",
    "MiningField",
    "MiningModel",
    "MiningSchema",
    "MissingValueWeights",
    "ModelExplanation",
    "ModelLiftGraph",
    "ModelStats",
    "ModelVerification",
    "NaiveBayesModel",
    "NeuralInput",
    "NeuralInputs",
    "NeuralLayer",
    "NeuralNetwork",
    "NeuralOutput",
    "NeuralOutputs",
    "Neuron",
    "Node",
    "NormContinuous",
    "NormDiscrete",
    "NumericInfo",
    "NumericPredictor",
    "OptimumLiftGraph",
    "Output",
    "OutputField",
    "PCell",
    "PCovCell",
    "PCovMatrix",
    "PMML",
    "PPCell",
    "PPMatrix",
    "PairCounts",
    "ParamMatrix",
    "Parameter",
    "ParameterField",
    "ParameterList",
    "Partition",
    "PartitionFieldStats",
    "PolynomialKernelType",
    "PredictiveModelQuality",
    "Predictor",
    "PredictorTerm",
    "Quantile",
    "REAL_Entries",
    "REAL_SparseArray",
    "ROC",
    "ROCGraph",
    "RadialBasisKernelType",
    "RandomLiftGraph",
    "Regression",
    "RegressionModel",
    "RegressionTable",
    "ResultField",
    "RuleSelectionMethod",
    "RuleSet",
    "RuleSetModel",
    "ScoreDistribution",
    "SeasonalTrendDecomposition",
    "Seasonality_ExpoSmooth",
    "Segment",
    "Segmentation",
    "Sequence",
    "SequenceModel",
    "SequenceReference",
    "SequenceRule",
    "SetPredicate",
    "SetReference",
    "SigmoidKernelType",
    "SimplePredicate",
    "SimpleRule",
    "SimpleSetPredicate",
    "SpectralAnalysis",
    "SupportVector",
    "SupportVectorMachine",
    "SupportVectorMachineModel",
    "SupportVectors",
    "TableLocator",
    "Target",
    "TargetValue",
    "TargetValueCount",
    "TargetValueCounts",
    "Targets",
    "Taxonomy",
    "TextCorpus",
    "TextDictionary",
    "TextDocument",
    "TextModel",
    "TextModelNormalization",
    "TextModelSimiliarity",
    "Time",
    "TimeAnchor",
    "TimeCycle",
    "TimeException",
    "TimeSeries",
    "TimeSeriesModel",
    "TimeValue",
    "Timestamp",
    "TransformationDictionary",
    "TreeModel",
    "Trend",
    "True_",
    "UnivariateStats",
    "Value",
    "VectorDictionary",
    "VectorFields",
    "VectorInstance",
    "VerificationField",
    "VerificationFields",
    "XCoordinates",
    "YCoordinates",
    "binarySimilarity",
    "chebychev",
    "cityBlock",
    "euclidean",
    "jaccard",
    "minkowski",
    "row",
    "simpleMatching",
    "squaredEuclidean",
    "tanimoto"
]
